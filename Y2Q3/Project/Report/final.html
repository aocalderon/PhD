<h1 id="introduction">Introduction</h1>
<p>Nowadays, spatio-temporal data is ubiquitous. Thanks to new technologies and the proliferation of location devices (such as Internet of Things, Remote Sensing, Smart phones, GPS, RFID, etc.), the collection of huge amount of spatio-temporal data is now possible. With the appearance of this datasets also appears the need of new techniques which allow the analysis and detection of useful patterns in large spatio-temporal databases.</p>
<p>Applications for this kind of information are diverse and interesting, in particular if they come in the way of trajectory datasets <span class="citation" data-cites="jeung_trajectory_2011 huang_mining_2015"></span>. Case of studies range from transportation system management <span class="citation" data-cites="di_lorenzo_allaboard:_2016 johansson_efficiency_2015"></span> to Ecology <span class="citation" data-cites="johnston_abundance_2015 la_sorte_convergence_2016"></span>. For instance, <span class="citation" data-cites="turdukulov_visual_2014"></span> explore the finding of complex motion patterns to discover similarities between tropical cyclone paths. Similarly, <span class="citation" data-cites="amor_persistence_2016"></span> use eye trajectories to understand which strategies people use during a visual search. Also, <span class="citation" data-cites="holland_movements_1999"></span> track the behavior of tiger sharks in the coasts of Hawaii in order to understand their migration patters.</p>
<p>Recently, there has been an increasing interest in exploiting more complex movement patterns in spatio-temporal datasets. Traditional range and nearest neighbor queries do not capture the collective behavior of moving objects. Moving cluster <span class="citation" data-cites="kalnis_discovering_2005"></span>, convoys <span class="citation" data-cites="jeung_discovery_2008"></span> and flock patterns <span class="citation" data-cites="benkert_reporting_2008 gudmundsson_computing_2006"></span> are new movement patterns which unveil how entities move together during a minimum time interval.</p>
<p>In particular, a moving flock pattern show how objects move close enough during a given period of time. A better understanding on how entities move in space is of special interest in areas such as sports <span class="citation" data-cites="iwase_tracking_2002"></span>, surveillance and security <span class="citation" data-cites="makris_path_2002 piciarelli_trajectory_2005"></span>, urban development <span class="citation" data-cites="huang_trajgraph:_2016 long_combining_2015"></span> and socio-economic geography <span class="citation" data-cites="frank_life_2000"></span>.</p>
<p>Despite the fact that much more data become available, state-of-the-art techniques to mine complex movement patterns still depict low scalability and poor performance in big spatial data. The present work aims to find an initial solution to implement a parallel method to discover moving flock patterns in large spatio-temporal datasets. It is thought that new trends in distributed in-memory framework for spatial operations could help to speed up the detection of this kind of patterns.</p>
<p>The following section will state the related work in the area. Section [sec:flock] will explain the details of the implementation of the proposed solution while section [sec:experiments] will present their experimental results. Finally, section [sec:conclusions] will discuss some conclusions and future work.</p>
<h1 id="related-work">Related work</h1>
<p>Recently increase use of location-aware devices (such as GPS, Smart phones and RFID tags) has allowed the collection of a vast amount of data with a spatial and temporal component linked to them. Different studies have focused in analyzing and mining this kind of collections <span class="citation" data-cites="leung_knowledge_2010 miller_geographic_2001"></span>. In this area, trajectory datasets have emerged as an interesting field where diverse kind of patterns can be identified <span class="citation" data-cites="zheng_computing_2011 vieira_spatio-temporal_2013"></span>. For instance, authors have proposed techniques to discover motion spatial patterns such as moving clusters <span class="citation" data-cites="kalnis_discovering_2005"></span>, convoys <span class="citation" data-cites="jeung_discovery_2008"></span> and flocks <span class="citation" data-cites="benkert_reporting_2008 gudmundsson_computing_2006"></span>. In particular, <span class="citation" data-cites="vieira_-line_2009"></span> proposed BFE (Basic Flock Evaluation), a novel algorithm to find moving flock patterns in polynomial time over large spatio-temporal datasets.</p>
<p>A flock pattern is defined as a group of entities which move together for a defined lapse of time <span class="citation" data-cites="benkert_reporting_2008"></span> (figure [fig:flock]). Applications to this kind of patterns are rich and diverse. For example, <span class="citation" data-cites="calderon_romero_mining_2011"></span> finds moving flock patterns in iceberg trajectories to understand their movement behavior and how they related to changes in ocean‚Äôs currents.</p>
<figure>
<img src="./figures/flock" alt="Moving flock pattern example." style="width:50.0%" /><figcaption>Moving flock pattern example.<span data-label="fig:flock"></span></figcaption>
</figure>
<p>The BFE algorithm presents an initial strategy in order to detect flock patterns. In that, first it finds disks with a predefined diameter (<span class="math inline"><em>Œµ</em></span>) where moving entities could be close enough at a given time interval. This is a costly operation due to the large number of points and intervals to be analyzed (<span class="math inline">ùí™(2<em>n</em><sup>2</sup>)</span> per time interval). The technique uses a grid-based index and a stencil (see figure [fig:grid]) to speed up the process, but the complexity is still high.</p>
<p><span class="citation" data-cites="calderon_romero_mining_2011"></span> and <span class="citation" data-cites="turdukulov_visual_2014"></span> use a frequent pattern mining approach to improve performance during the combination of disks between time intervals. Similarly, <span class="citation" data-cites="tanaka_improved_2016"></span> introduce the use of plane sweeping along with binary signatures and inverted indexes to speedup the same process. However, the above-mentioned methods still keep the same strategy as BFE to find the disks at each interval.</p>
<p><span class="citation" data-cites="arimura_finding_2014"></span> and <span class="citation" data-cites="geng_enumeration_2014"></span> use depth-first algorithms to analyze the time intervals of each trajectory to report maximal duration flocks. However, these techniques are not suitable to find patterns in an on-line fashion.</p>
<p>Given the high complexity of the task, it should not be surprising the use of parallelism to increase performance. <span class="citation" data-cites="fort_parallel_2014"></span> use extremal and intersection sets to report maximal, longest and largest flocks on the GPU with the limitations of its memory model.</p>
<p>Indeed, despite the popularity of cluster computing frameworks (in particular whose supporting spatial capabilities <span class="citation" data-cites="eldawy_spatialhadoop:_2014 yu_demonstration_2016 pellechia_geomesa:_2015-1 xie_simba:_2016-1"></span>) there are not significant advances in this area. At the best of our knowledge, this work is the first to explore in-memory distributed systems towards the detection of moving flock patterns.</p>
<figure>
<img src="./figures/grid" alt="Grid-based index used in ." style="width:30.0%" /><figcaption>Grid-based index used in <span class="citation" data-cites="vieira_-line_2009"></span>.<span data-label="fig:grid"></span></figcaption>
</figure>
<h1 id="sec:flock">Parallelizing flock detection</h1>
<p>Given that the finding of disks at each time interval is one of the most costly operations towards the detection of moving flock patterns, the main goal of this work is to implement a parallel method to detect that set of disks. In order to do that, we will use the spatial operations offered by Simba <span class="citation" data-cites="xie_simba:_2016-1"></span>, a distributed in-memory spatial analytics engine based on Apache Spark. This section explains the details of the algorithm implemented in Simba and how some spatial predicates introduced by it can leverage the finding of disks.</p>
<h2 id="spatial-operations-on-simba">Spatial operations on Simba</h2>
<p>Simba (Spatial In-Memory Big data Analytics) extends the Spark SQL engine to provide rich spatial operations through both SQL and the DataFrame API. Besides, it introduces two-layer spatial indexing and cost-based optimizations to support efficient spatial queries in parallel. Simba is open source and public available at the project‚Äôs webpage<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>In particular, <code>DISTANCE JOIN</code> and <code>CIRCLERANGE</code> operators were used in order to find groups of points lying close enough each other. The algorithm uses a user-defined distance (<span class="math inline"><em>Œµ</em></span>) to define the diameter of the disk. Figure [fig:sql] shows the SQL statement used to find pairs of points inside an <span class="math inline"><em>Œµ</em></span> distance in parallel.</p>
<p>[fontsize=,tabsize=8,breaklines,framesep=10pt,frame=single, escapeinside=||,mathescape=true]<span>sql</span> SELECT * FROM points p1 || points p2 ON POINT(p2.x, p2.y) IN ||(POINT(p1.x, p1.y), |<span class="math inline"><em>Œµ</em></span>|) WHERE p1.id &lt; p2.id</p>
<h2 id="finding-disks-for-pairs-of-points">Finding disks for pairs of points</h2>
<p>Once the set of pairs of points has been found, a map function computes the center of the two possible disks per each pair according to the BFE algorithm. <span class="citation" data-cites="vieira_-line_2009"></span> states that: ‚ÄúFor each such pair there are exactly two disks with radius <span class="math inline">$\frac{\varepsilon}{2}$</span> that have those points on their circumference‚Äù. Figure [fig:theorem] illustrates how to find the center of those disks.</p>
<figure>
<img src="figures/theorem" alt="Disks for \{p_1,p_2\},\ d(p_1,p_2) \leq \varepsilon ." style="width:40.0%" /><figcaption>Disks for <span class="math inline">{<em>p</em><sub>1</sub>,‚ÄÜ<em>p</em><sub>2</sub>},¬†<em>d</em>(<em>p</em><sub>1</sub>,‚ÄÜ<em>p</em><sub>2</sub>)‚â§<em>Œµ</em></span> <span class="citation" data-cites="vieira_-line_2009"></span>.<span data-label="fig:theorem"></span></figcaption>
</figure>
<p>After that, the complete set of candidate disks is collected and ready to be processed by the following phases of the BFE algorithm.</p>
<p>The implementation of the proposed method was written in Scala 2.10.6 and tested in Simba/Spark 1.6.0. The current code can be accessed at the authors‚Äô repository<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<h1 id="sec:experiments">Experiments</h1>
<p>The main idea of the experiments is to assess the performance of the parallel method against a sequential version of the BFE algorithm proposed by <span class="citation" data-cites="vieira_-line_2009"></span>. A public available implementation written in Python can be accessed at this repository<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. The source code was modified to stop after the finding of the disks and report the total number of computed disks. Same configuration was followed by the parallel implementation.</p>
<p>Next, a set of experiments evaluates the execution time of both algorithms on two real datasets. Further details of the settings and datasets are discussed below.</p>
<h2 id="beijing-dataset">Beijing dataset</h2>
<p>This dataset was extracted from the Geolife project<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> <span class="citation" data-cites="zheng_understanding_2008 zheng_mining_2009 zheng_geolife:_2010"></span>. It collects GPS trajectories of 182 users in a period of over three years (from April 2007 to August 2012) for an overall total of 17,621 trajectories. The timestamp field was ignored and duplicate locations were removed to simulate an unique and large time interval. In total, the point dataset contains <span class="math inline">‚âà</span>18 million points.</p>
<p>An initial set of experiments takes relatively small samples of the data and runs the algorithms under different values of <span class="math inline"><em>Œµ</em></span>. Experiments were deployed in a single-node machine with a 4-core Intel(R) Core(TM) i5-2400S CPU @ 2.50GHz processor, 8 GB of RAM running Ubuntu 16.04 LTS, Python 3.5 and Simba/Spark 1.6.0. Figure [fig:beijing] show the results of these experiments.</p>
<figure>
<img src="figures/beijing" alt="Execution time for Beijing dataset." style="width:90.0%" /><figcaption>Execution time for Beijing dataset.<span data-label="fig:beijing"></span></figcaption>
</figure>
<h2 id="porto-dataset">Porto dataset</h2>
<p>This dataset was extracted from the ECML/PKDD‚Äô15 Taxi Trajectory Prediction Challenge<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> <span class="citation" data-cites="lam_blue_2015 moreira-matias_predicting_2013"></span>. It collects a complete year (from 01/07/2013 to 30/06/2014) of trajectories for all the 442 taxis running in the city of Porto, in Portugal. After pre-processing and duplicate removal the collection had <span class="math inline">‚âà</span>17.7 million points.</p>
<p>This set of experiments takes data samples of 1, 2, 4, 8 and 16 million of points. Similarly, it runs the algorithms under different values of <span class="math inline"><em>Œµ</em></span>. This time, experiments were deployed in a 4-node academic cluster with the following setup: an 8-core Intel(R) Xeon(R) CPU E3-1230 V2 @ 3.30GHz processor and 15.5 GB of RAM per node. The systems run Centos 6.8, Python 3.5 and Simba/Spark 1.6.0. Figure [fig:porto] show the results of these experiments.</p>
<figure>
<img src="figures/porto" alt="Execution time for Porto dataset." style="width:90.0%" /><figcaption>Execution time for Porto dataset.<span data-label="fig:porto"></span></figcaption>
</figure>
<h1 id="sec:conclusions">Conclusions and future work</h1>
<p>An implementation of a parallel method to detect disks for the BFE algorithm has been presented. The proposed method proves to be scalable and reliable. Experiments shows that execution time improves up to 3 orders of magnitude compared to the sequential implementation of the BFE algorithm for the same step.</p>
<p>Parallel implementation for the remaining steps of the BFE algorithm are part of the future work. It is expected to work on parallel strategies to prune redundant and incomplete disks together with a parallel strategy to join the sets of valid disks between time intervals. In addition, data pre-processing and result visualization are still open issues.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://www.cs.utah.edu/~dongx/simba/" class="uri">http://www.cs.utah.edu/~dongx/simba/</a><a href="#fnref1">‚Ü©</a></p></li>
<li id="fn2"><p><a href="https://github.com/aocalderon/PhD/tree/master/Y2Q1/SDB/Project/Code/Scripts/pbfe2" class="uri">https://github.com/aocalderon/PhD/tree/master/Y2Q1/SDB/Project/Code/Scripts/pbfe2</a><a href="#fnref2">‚Ü©</a></p></li>
<li id="fn3"><p><a href="https://github.com/poldrosky/FPFlock" class="uri">https://github.com/poldrosky/FPFlock</a><a href="#fnref3">‚Ü©</a></p></li>
<li id="fn4"><p><a href="https://www.microsoft.com/en-us/download/details.aspx?id=52367" class="uri">https://www.microsoft.com/en-us/download/details.aspx?id=52367</a><a href="#fnref4">‚Ü©</a></p></li>
<li id="fn5"><p><a href="https://www.kaggle.com/c/pkdd-15-predict-taxi-service-trajectory-i/data" class="uri">https://www.kaggle.com/c/pkdd-15-predict-taxi-service-trajectory-i/data</a><a href="#fnref5">‚Ü©</a></p></li>
</ol>
</section>
