\documentclass[10pt]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{hyperref}
\hypersetup{
colorlinks=false,
hidelinks
}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{lineno}
\usepackage{tikz}
\usetikzlibrary{tikzmark}


\begin{document}

\section*{Improving disk filtering by maximal pattern detection.}
After the candidate disks detection, additional filtering should be carried.  BFE algorithm states two filtering process: Firstly, remove any disk which do not group a minimum number of moving object (defined by $\mu$ parameter). Secondly, remove any disk whose element set is a subset of another disk's element set. It means that If from two disks one of them contains all the other's elements, just the former should be kept.  If two disks share the same elements, just one of them should remain.  Figure \ref{fig:steps}  illustrate the steps.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.475\textwidth}
    \centering
    \includegraphics[width=\textwidth]{../Viz/plot0}
    \caption[]{{\small Set of points}}    
    \label{fig:steps_a}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.475\textwidth}  
    \centering 
    \includegraphics[width=\textwidth]{../Viz/plot1}
    \caption[]{{\small Candidate disks}}    
    \label{fig:steps_b}
  \end{subfigure}
  \vskip\baselineskip
  \begin{subfigure}[b]{0.475\textwidth}   
    \centering 
    \includegraphics[width=\textwidth]{../Viz/plot2}
    \caption[] {{\small Removing less than $\mu$ disks}}    
    \label{fig:steps_c}
  \end{subfigure}
  \quad
  \begin{subfigure}[b]{0.475\textwidth}   
    \centering 
    \includegraphics[width=\textwidth]{../Viz/plot3}
    \caption[]{{\small Removing redundant disks}}    
    \label{fig:steps_d}
  \end{subfigure}
  \caption{\small Steps during disk filtering ($\mu = 3$).} 
  \label{fig:steps}
\end{figure}

At this point, it is assumed that a valid set of candidates disk has been generated.  It is a simple list with a generated key for each disk and a list with the ID's of the moving objects which the disk encloses. The coordinates of the disk are not needed for filtering purposes but they should be useful if further visualizations are planned.

The task to obtain a valid set of disks from the candidate set is not trivial.  A brute force algorithm takes $O(n^2)$ complexity to prune redundant disks which is not scalable for big spatial datasets.  One approach is see the elements inside each disk as a set or transaction.  Once a transactional version of the candidate disks is obtained, it can be analyzed with well-know algorithms for supersets detection.

\subsection*{Maximal and closed frequent patterns}

The detection of supersets in frequent pattern mining has been a widely discussed topic.  Previous works has shown the advantage of maximal and closed frequent patterns as valid representations of the full set of frequent patterns in transactional databases. The main idea is to find the most general pattern from which the remain set of pattern can be generated.

Although the first generation of algorithms was designed to find the complete group of frequent itemsets, in large databases using low values for minimum support threshold this number can be huge. This is because if an itemset is frequent, each of its subsets is frequent as well. Long itemsets will contain large number of shorter frequent subsets. For instance, let a long itemset $I=\{a_1, a_2, ..., a_{100}\}$ with 100 items (It is usually called type 100 or 100-itemset for its number of members). 

It will contain $\binom{100}{1}$ 1-itemsets, $\binom{100}{1}$ 2-itemsets, and so on. The total number of frequent itemsets that it would contain would be:

$$\binom{100}{1} + \binom{100}{1} + ... + \binom{100}{100} = 2^{100} - 1 \approx 1.27 \times 10^{30}$$

To overcome this drawback the concepts of \textit{closed frequent pattern} and \textit{maximum frequent pattern} are used. A pattern $\alpha$ is a \textit{closed frequent pattern} if $\alpha$ is frequent and there exists no other pattern, with the same support, whose contains $\alpha$. On the other hand, a pattern $\alpha$ is a \textit{maximal frequent pattern} if $\alpha$ is frequent and there exists no other pattern, with any support, whose contains $\alpha$. For example:

\vspace{2mm}
\begin{tabular}{l l}
$\alpha = \{ a_1, a_2, a_3, a_4 : 2\}$ & $\alpha$ is \textit{maximal} \\
$\beta = \{ a_1, a_2, a_3 : 4\}$ & $\beta$ is \textit{closed} but not \textit{maximal} \\
\end{tabular}
\vspace{2mm}

The set of maximal frequent patterns is important because it contains the set of longest patterns such that any kind of frequent pattern which exceeds the minimum support can be generated.For clarification, these two concepts can be illustrated with an additional example.  Suppose a database $D$ contains 4 transactions:

$$ D = \{ \langle a_1, a_2, ..., a_{100} \rangle; \langle a_1, a_2, ..., a_{100} \rangle; \langle a_{20}, a_{21}, ..., a_{80} \rangle; \langle a_{40}, a_{41}, ..., a_{60} \rangle \} $$

Note that the first transaction is repeated twice. The minimum support $min\_sup = 2$. A complete search for all itemsets will generate a vast number of combinations. However,
the closed frequent itemset approach will find only 3 frequent itemsets:

$$ C = \{ \{ a_1, a_2, ..., a_{100} : 2 \};\{ a_{20},a_{21}, ..., a_{80} : 3 \};\{ a_{40},a_{41}, ..., a_{60} : 4 \} \} $$

The set of closed frequent itemsets contains complete information to generate the rest frequent itemsets with their corresponding support. It is possible to derive, for example,
$\{a_{50}, a_{51} : 4\}$ from $\{a_{40}, a_{41} , ..., a_{60} : 4\}$ or $\{a_{90}, a_{91}, a_{92} : 2\}$ from $\{a_1, a_2, ..., a_{100} : 2\}$.
On the other hand, we just obtain one maximal frequent pattern, in this case:

$$ M = \{ \{ a_1, a_2, ..., a_{100} : 2 \} \} $$

This only pattern will serve as a valid representation of all the frequent patterns as it contains all the possible subsets.

\subsection*{A transactional version of the candidate disks}

\begin{figure}   
  \centering 
  \includegraphics[width=0.5\textwidth]{../Viz/zoom}
  \caption[]{{\small Towards a transactional version of the candidate disks}}    
  \label{fig:candidates}
\end{figure}

The main idea to deal with the candidates disks as a set of transactions is the possibility to apply well-known algorithms for maximal pattern detection in order to filter all the possible subsets.  In figure \ref{fig:candidates} we can see that we can extract the points enclosed by each disks in the form of transaction.  For example:

\vspace{2mm}
\begin{tabular}{r l r}
$D =$ 	& $\{ \langle 1, 2, 3 \rangle; $ 	& {\small \textit{From disk 1}}\\
	& $   \langle 2, 3, 4 \rangle; $ 	& {\small \textit{From disk 2}}\\
	& $   \langle 1, 2 \rangle; $	 	& {\small \textit{From disk 3}}\\
	& \multicolumn{1}{c}{\vdots}		& \multicolumn{1}{c}{\vdots} \\
	& $   \langle 1, 2, 3, 4 \rangle; $ 	& {\small \textit{From disk 10}}\\
	& $   \langle 2, 3, 4 \rangle; $ 	& {\small \textit{From disk 11}}\\
	& $   \langle 3, 4 \rangle; $ 		& {\small \textit{From disk 12}}\\
	& $   \langle 4, 5 \rangle \} $		& {\small \textit{From disk 13}}\\
\end{tabular}
\vspace{2mm}

In this way, it is possible to apply any algorithm for maximal pattern detection to discard redundant disks by using $min\_sup=1$.  The result should be:

\vspace{2mm}
\begin{tabular}{r l}
$M =$ 	& $\{ \langle 1, 2, 3, 4 \rangle; $\\
	& $   \langle 4, 5 \rangle \} $	\\
\end{tabular}
\vspace{2mm}

From this shorter list we should prune $\langle 4, 5 \rangle$ because it does not fulfill the $\mu = 3$ parameter. As an advantage on the use of maximal pattern algorithms we could expect a significant improvement in performance since many of this techniques are able to find the set of maximal disk in linear time according with the number of maximal patterns. 
    
\subsection*{Proof by contradiction}
\begin{proof}
Given two disks in the initial set of candidate disks we have to consider two option:  Firstly, let's have a disk $A$ whose elements are $A = \{p_1, p_2, p_3, ..., p_n\}$ and a disk $B$ which have the same elements $B = \{p_1, p_2, p_3, ..., p_n\}$ so $A = B$.  If they are the input of a maximal pattern algorithm it will choose any of them, let say $B$ and $A$ will be consider a redundant disk and it can be safely discarded.  Secondly, let's a disk $A$ whose elements are $A = \{p_1, p_2, p_3, ..., p_n\}$ and a disk $B$ whose elements are $B = \{p_1, p_2, p_3, ..., p_n, p_{n+1}, ..., p_m\}$ so $B \supset A$.  If they are the input of a maximal pattern algorithm it will choose disk $B$ and $A$ will be consider a redundant disk and it can be safely discarded. 
\end{proof}

\end{document}
