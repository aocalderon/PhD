For the second part of lab2, we made some changes in syscall.c file. Specifically, we added an if clause in function argptr to check if we point at 0. If this is true, then we have an exception. The reason that we make these changes is that now that we changed xv6 so that each process doesn't start from the zero address, we, also, need to ensure that we pass to kernel a correct pointer via system calls. Without the changes, xv6 checks only if the pointer lies between the process address space. However, we should add a check that returns an exception if the pointer points to 0.  

We tested our implementation by executing a system call that passes a pointer to 0 and we got an exception. But when we pass pointer to somewhere else (inside the process address space) the system call is executed normally. 
