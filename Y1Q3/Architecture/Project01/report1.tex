\documentclass[a4paper,12pt]{article}
\begin{document}

\section*{Part 2: Discussion}
In the first part of the assignment we chose to present the results from the following metrics: PCI and LSQ\_latency. We observe from the graphs that the PCI metric has the same behavior for all the four benchmarks. This happens because PCI measures the number of cycles per instruction,which is the inverse of IPC (number of instructions per cycle). As a result, if we the number of instructions, CPI is decreased. That is the behavior that we observe in all the graphs of PCI vs IPC. 
\par For the LSQ\_latency metric we have similar behavior for fetched and decoded instructions and for committed and issued but different among those two groups. When we increase the number of fetched and decoded instructions, it is reasonable that the latency in load/store queue will be increased as we increase the data stored in it. In contrast, when we increase the number of issued and committed instructions it is not certain that all of them will use the aforementioned queue. 
\par In part 2 of the assignment, we chose to report the results of CPI and number of addresses predicted. We change the status of the branch predictions between taken (go to the branch), not taken (do not go to the branch), bimodal (go to the branch according to what happened in the past in this branch)and 2-level(go to the branch according to what happened in the past in the other branches). When the program is completed, if the prediction that we made was not correct, we have to go back and execute or not the branch according to what we did during the prediction phase. 
\par As a result, when the status is not taken, it means that we do not execute the branch but if we were wrong we have to go back so we have to execute more instructions. As a result, the cycles are increased. The same happens with the taken status. In contrast, when the status is 2-level and specifically bimodal the number of instructions are less because we depend on what happened on the history. So, the system is learning from a pattern and it goes back less times. 
\par The second metric as we mentioned above was the number of addresses predicted. As we explained in the previous paragraph, we have more chances to predict a correct outcome in the bimodal and 2-level status than in taken and not taken ones. So, the number of addresses predicted correctly is larger for bimodal and 2-level status. 
\par Finally, in the third part of the assignment we chose to present the results for CPI and miss\_rate. We notice that as the block size increases both of those metrics are decreased. This happens because as the block size is increased, the number of missed may be also increased but the rate with which it is increased is decreased. Since, the miss rate is decreased, the average cycles that an instructions uses is also, decreased. 
\par We can see that the same behavior described above is also observed for cache associativity. The justification is the same. 
\par Finally, for the replacement policy we observe that the behavior for each metric is different for each benchmark. As a result, we believe that the optimal replacement policy depends on the application that we use.  

\end{document}