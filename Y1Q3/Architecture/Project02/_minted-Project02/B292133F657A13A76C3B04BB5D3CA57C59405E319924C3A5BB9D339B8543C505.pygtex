\begin{Verbatim}[commandchars=\\\{\}]
\PYGdefault{c+cm}{/* sim\PYGdefaultZhy{}outorder.c \PYGdefaultZhy{} sample out\PYGdefaultZhy{}of\PYGdefaultZhy{}order issue perf simulator implementation */}

\PYGdefault{c+cm}{/* SimpleScalar(TM) Tool Suite}
\PYGdefault{c+cm}{ * Copyright (C) 1994\PYGdefaultZhy{}2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.}
\PYGdefault{c+cm}{ * All Rights Reserved. }
\PYGdefault{c+cm}{ * }
\PYGdefault{c+cm}{ * THIS IS A LEGAL DOCUMENT, BY USING SIMPLESCALAR,}
\PYGdefault{c+cm}{ * YOU ARE AGREEING TO THESE TERMS AND CONDITIONS.}
\PYGdefault{c+cm}{ * }
\PYGdefault{c+cm}{ * No portion of this work may be used by any commercial entity, or for any}
\PYGdefault{c+cm}{ * commercial purpose, without the prior, written permission of SimpleScalar,}
\PYGdefault{c+cm}{ * LLC (info@simplescalar.com). Nonprofit and noncommercial use is permitted}
\PYGdefault{c+cm}{ * as described below.}
\PYGdefault{c+cm}{ * }
\PYGdefault{c+cm}{ * 1. SimpleScalar is provided AS IS, with no warranty of any kind, express}
\PYGdefault{c+cm}{ * or implied. The user of the program accepts full responsibility for the}
\PYGdefault{c+cm}{ * application of the program and the use of any results.}
\PYGdefault{c+cm}{ * }
\PYGdefault{c+cm}{ * 2. Nonprofit and noncommercial use is encouraged. SimpleScalar may be}
\PYGdefault{c+cm}{ * downloaded, compiled, executed, copied, and modified solely for nonprofit,}
\PYGdefault{c+cm}{ * educational, noncommercial research, and noncommercial scholarship}
\PYGdefault{c+cm}{ * purposes provided that this notice in its entirety accompanies all copies.}
\PYGdefault{c+cm}{ * Copies of the modified software can be delivered to persons who use it}
\PYGdefault{c+cm}{ * solely for nonprofit, educational, noncommercial research, and}
\PYGdefault{c+cm}{ * noncommercial scholarship purposes provided that this notice in its}
\PYGdefault{c+cm}{ * entirety accompanies all copies.}
\PYGdefault{c+cm}{ * }
\PYGdefault{c+cm}{ * 3. ALL COMMERCIAL USE, AND ALL USE BY FOR PROFIT ENTITIES, IS EXPRESSLY}
\PYGdefault{c+cm}{ * PROHIBITED WITHOUT A LICENSE FROM SIMPLESCALAR, LLC (info@simplescalar.com).}
\PYGdefault{c+cm}{ * }
\PYGdefault{c+cm}{ * 4. No nonprofit user may place any restrictions on the use of this software,}
\PYGdefault{c+cm}{ * including as modified by the user, by any other authorized user.}
\PYGdefault{c+cm}{ * }
\PYGdefault{c+cm}{ * 5. Noncommercial and nonprofit users may distribute copies of SimpleScalar}
\PYGdefault{c+cm}{ * in compiled or executable form as set forth in Section 2, provided that}
\PYGdefault{c+cm}{ * either: (A) it is accompanied by the corresponding machine\PYGdefaultZhy{}readable source}
\PYGdefault{c+cm}{ * code, or (B) it is accompanied by a written offer, with no time limit, to}
\PYGdefault{c+cm}{ * give anyone a machine\PYGdefaultZhy{}readable copy of the corresponding source code in}
\PYGdefault{c+cm}{ * return for reimbursement of the cost of distribution. This written offer}
\PYGdefault{c+cm}{ * must permit verbatim duplication by anyone, or (C) it is distributed by}
\PYGdefault{c+cm}{ * someone who received only the executable form, and is accompanied by a}
\PYGdefault{c+cm}{ * copy of the written offer of source code.}
\PYGdefault{c+cm}{ * }
\PYGdefault{c+cm}{ * 6. SimpleScalar was developed by Todd M. Austin, Ph.D. The tool suite is}
\PYGdefault{c+cm}{ * currently maintained by SimpleScalar LLC (info@simplescalar.com). US Mail:}
\PYGdefault{c+cm}{ * 2395 Timbercrest Court, Ann Arbor, MI 48105.}
\PYGdefault{c+cm}{ * }
\PYGdefault{c+cm}{ * Copyright (C) 1994\PYGdefaultZhy{}2003 by Todd M. Austin, Ph.D. and SimpleScalar, LLC.}
\PYGdefault{c+cm}{ */}


\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZlt{}stdio.h\PYGdefaultZgt{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZlt{}stdlib.h\PYGdefaultZgt{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZlt{}math.h\PYGdefaultZgt{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZlt{}assert.h\PYGdefaultZgt{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZlt{}signal.h\PYGdefaultZgt{}}

\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}host.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}misc.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}machine.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}regs.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}memory.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}cache.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}loader.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}syscall.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}bpred.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}resource.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}bitmap.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}options.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}eval.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}stats.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}ptrace.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}dlite.h\PYGdefaultZdq{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}sim.h\PYGdefaultZdq{}}

\PYGdefault{c+cm}{/* added for Wattch */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}power.h\PYGdefaultZdq{}}

\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * This file implements a very detailed out\PYGdefaultZhy{}of\PYGdefaultZhy{}order issue superscalar}
\PYGdefault{c+cm}{ * processor with a two\PYGdefaultZhy{}level memory system and speculative execution support.}
\PYGdefault{c+cm}{ * This simulator is a performance simulator, tracking the latency of all}
\PYGdefault{c+cm}{ * pipeline operations.}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* simulated registers */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{k+kt}{regs\PYGdefaultZus{}t} \PYGdefault{n}{regs}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* simulated memory */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{k+kt}{mem\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{mem} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * simulator options}
\PYGdefault{c+cm}{ */}



\PYGdefault{c+cm}{/******************************************/}	       
\PYGdefault{c+cm}{/* CS 203A Declaring VSF and FSF          */}	       
\PYGdefault{c+cm}{/******************************************/}	
\PYGdefault{k+kt}{float} \PYGdefault{n}{VSF} \PYGdefault{o}{=} \PYGdefault{l+m+mf}{1.0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{float} \PYGdefault{n}{FSF} \PYGdefault{o}{=} \PYGdefault{l+m+mf}{1.0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/******************************************/}	       
\PYGdefault{c+cm}{/* CS 203A Declaring arguments            */}	       
\PYGdefault{c+cm}{/******************************************/}	
\PYGdefault{k+kt}{int} \PYGdefault{n}{DVFSInterval}\PYGdefault{p}{;}
\PYGdefault{k+kt}{float} \PYGdefault{n}{DVFSTargetPower}\PYGdefault{p}{;}
\PYGdefault{k+kt}{float} \PYGdefault{n}{DVFSIncrement}\PYGdefault{p}{;}
\PYGdefault{k+kt}{int} \PYGdefault{n}{DVFSTurnOff}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/******************************************/}	       
\PYGdefault{c+cm}{/* CS 203A Declaring auxiliar varibles    */}	       
\PYGdefault{c+cm}{/******************************************/}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define Mhz 600e6}
\PYGdefault{k+kt}{float} \PYGdefault{n}{power\PYGdefaultZus{}this\PYGdefaultZus{}interval}\PYGdefault{p}{;}
\PYGdefault{k+kt}{float} \PYGdefault{n}{total}\PYGdefault{p}{;}
\PYGdefault{k+kt}{float} \PYGdefault{n}{previous\PYGdefaultZus{}total} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{float} \PYGdefault{n}{avg\PYGdefaultZus{}power}\PYGdefault{p}{;}
\PYGdefault{k+kt}{float} \PYGdefault{n}{power\PYGdefaultZus{}factor}\PYGdefault{p}{;}
\PYGdefault{k}{extern} \PYGdefault{k+kt}{FILE} \PYGdefault{o}{*} \PYGdefault{n}{output}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/******************************************/}	       
\PYGdefault{c+cm}{/*                                        */}	       
\PYGdefault{c+cm}{/******************************************/}	



\PYGdefault{c+cm}{/* maximum number of inst\PYGdefaultZsq{}s to execute */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{max\PYGdefaultZus{}insts}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* number of insts skipped before timing starts */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{fastfwd\PYGdefaultZus{}count}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* pipeline trace range and output filename */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{ptrace\PYGdefaultZus{}nelt} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{ptrace\PYGdefaultZus{}opts}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{];}

\PYGdefault{c+cm}{/* instruction fetch queue size (in insts) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* extra branch mis\PYGdefaultZhy{}prediction latency */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{ruu\PYGdefaultZus{}branch\PYGdefaultZus{}penalty}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* speed of front\PYGdefaultZhy{}end of machine relative to execution core */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{fetch\PYGdefaultZus{}speed}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* branch predictor type \PYGdefaultZob{}nottaken|taken|perfect|bimod|2lev\PYGdefaultZcb{} */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{pred\PYGdefaultZus{}type}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* bimodal predictor config (\PYGdefaultZlt{}table\PYGdefaultZus{}size\PYGdefaultZgt{}) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{bimod\PYGdefaultZus{}nelt} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{;}
\PYGdefault{k+kt}{int} \PYGdefault{n}{bimod\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{]} \PYGdefault{o}{=}
  \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{c+cm}{/* bimod tbl size */}\PYGdefault{l+m+mi}{2048} \PYGdefault{p}{\PYGdefaultZcb{};}

\PYGdefault{c+cm}{/* 2\PYGdefaultZhy{}level predictor config (\PYGdefaultZlt{}l1size\PYGdefaultZgt{} \PYGdefaultZlt{}l2size\PYGdefaultZgt{} \PYGdefaultZlt{}hist\PYGdefaultZus{}size\PYGdefaultZgt{} \PYGdefaultZlt{}xor\PYGdefaultZgt{}) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{twolev\PYGdefaultZus{}nelt} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{4}\PYGdefault{p}{;}
\PYGdefault{k+kt}{int} \PYGdefault{n}{twolev\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{4}\PYGdefault{p}{]} \PYGdefault{o}{=}
  \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{c+cm}{/* l1size */}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* l2size */}\PYGdefault{l+m+mi}{1024}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* hist */}\PYGdefault{l+m+mi}{8}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* xor */}\PYGdefault{n}{FALSE}\PYGdefault{p}{\PYGdefaultZcb{};}

\PYGdefault{c+cm}{/* combining predictor config (\PYGdefaultZlt{}meta\PYGdefaultZus{}table\PYGdefaultZus{}size\PYGdefaultZgt{} */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{comb\PYGdefaultZus{}nelt} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{;}
\PYGdefault{k+kt}{int} \PYGdefault{n}{comb\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{]} \PYGdefault{o}{=}
  \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{c+cm}{/* meta\PYGdefaultZus{}table\PYGdefaultZus{}size */}\PYGdefault{l+m+mi}{1024} \PYGdefault{p}{\PYGdefaultZcb{};}

\PYGdefault{c+cm}{/* return address stack (RAS) size */}
\PYGdefault{k+kt}{int} \PYGdefault{n}{ras\PYGdefaultZus{}size} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{8}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* BTB predictor config (\PYGdefaultZlt{}num\PYGdefaultZus{}sets\PYGdefaultZgt{} \PYGdefaultZlt{}associativity\PYGdefaultZgt{}) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{btb\PYGdefaultZus{}nelt} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{2}\PYGdefault{p}{;}
\PYGdefault{k+kt}{int} \PYGdefault{n}{btb\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{]} \PYGdefault{o}{=}
  \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{c+cm}{/* nsets */}\PYGdefault{l+m+mi}{512}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* assoc */}\PYGdefault{l+m+mi}{4} \PYGdefault{p}{\PYGdefaultZcb{};}

\PYGdefault{c+cm}{/* instruction decode B/W (insts/cycle) */}
\PYGdefault{k+kt}{int} \PYGdefault{n}{ruu\PYGdefaultZus{}decode\PYGdefaultZus{}width}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* instruction issue B/W (insts/cycle) */}
\PYGdefault{k+kt}{int} \PYGdefault{n}{ruu\PYGdefaultZus{}issue\PYGdefaultZus{}width}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* run pipeline with in\PYGdefaultZhy{}order issue */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{ruu\PYGdefaultZus{}inorder\PYGdefaultZus{}issue}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* issue instructions down wrong execution paths */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{ruu\PYGdefaultZus{}include\PYGdefaultZus{}spec} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* instruction commit B/W (insts/cycle) */}
\PYGdefault{k+kt}{int} \PYGdefault{n}{ruu\PYGdefaultZus{}commit\PYGdefaultZus{}width}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* register update unit (RUU) size */}
\PYGdefault{k+kt}{int} \PYGdefault{n}{RUU\PYGdefaultZus{}size} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{8}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* load/store queue (LSQ) size */}
\PYGdefault{k+kt}{int} \PYGdefault{n}{LSQ\PYGdefaultZus{}size} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{4}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* l1 data cache config, i.e., \PYGdefaultZob{}\PYGdefaultZlt{}config\PYGdefaultZgt{}|none\PYGdefaultZcb{} */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{cache\PYGdefaultZus{}dl1\PYGdefaultZus{}opt}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* l1 data cache hit latency (in cycles) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{cache\PYGdefaultZus{}dl1\PYGdefaultZus{}lat}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* l2 data cache config, i.e., \PYGdefaultZob{}\PYGdefaultZlt{}config\PYGdefaultZgt{}|none\PYGdefaultZcb{} */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{cache\PYGdefaultZus{}dl2\PYGdefaultZus{}opt}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* l2 data cache hit latency (in cycles) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{cache\PYGdefaultZus{}dl2\PYGdefaultZus{}lat}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* l1 instruction cache config, i.e., \PYGdefaultZob{}\PYGdefaultZlt{}config\PYGdefaultZgt{}|dl1|dl2|none\PYGdefaultZcb{} */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}opt}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* l1 instruction cache hit latency (in cycles) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}lat}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* l2 instruction cache config, i.e., \PYGdefaultZob{}\PYGdefaultZlt{}config\PYGdefaultZgt{}|dl1|dl2|none\PYGdefaultZcb{} */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{cache\PYGdefaultZus{}il2\PYGdefaultZus{}opt}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* l2 instruction cache hit latency (in cycles) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{cache\PYGdefaultZus{}il2\PYGdefaultZus{}lat}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* flush caches on system calls */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{flush\PYGdefaultZus{}on\PYGdefaultZus{}syscalls}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* convert 64\PYGdefaultZhy{}bit inst addresses to 32\PYGdefaultZhy{}bit inst equivalents */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{compress\PYGdefaultZus{}icache\PYGdefaultZus{}addrs}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* memory access latency (\PYGdefaultZlt{}first\PYGdefaultZus{}chunk\PYGdefaultZgt{} \PYGdefaultZlt{}inter\PYGdefaultZus{}chunk\PYGdefaultZgt{}) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{mem\PYGdefaultZus{}nelt} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{2}\PYGdefault{p}{;}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{mem\PYGdefaultZus{}lat}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{]} \PYGdefault{o}{=}
  \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{c+cm}{/* lat to first chunk */}\PYGdefault{l+m+mi}{18}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* lat between remaining chunks */}\PYGdefault{l+m+mi}{2} \PYGdefault{p}{\PYGdefaultZcb{};}

\PYGdefault{c+cm}{/* memory access bus width (in bytes) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{mem\PYGdefaultZus{}bus\PYGdefaultZus{}width}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* instruction TLB config, i.e., \PYGdefaultZob{}\PYGdefaultZlt{}config\PYGdefaultZgt{}|none\PYGdefaultZcb{} */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{itlb\PYGdefaultZus{}opt}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* data TLB config, i.e., \PYGdefaultZob{}\PYGdefaultZlt{}config\PYGdefaultZgt{}|none\PYGdefaultZcb{} */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{dtlb\PYGdefaultZus{}opt}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* inst/data TLB miss latency (in cycles) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{tlb\PYGdefaultZus{}miss\PYGdefaultZus{}lat}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* total number of integer ALU\PYGdefaultZsq{}s available */}
\PYGdefault{k+kt}{int} \PYGdefault{n}{res\PYGdefaultZus{}ialu}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* total number of integer multiplier/dividers available */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{res\PYGdefaultZus{}imult}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* total number of memory system ports available (to CPU) */}
\PYGdefault{k+kt}{int} \PYGdefault{n}{res\PYGdefaultZus{}memport}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* total number of floating point ALU\PYGdefaultZsq{}s available */}
\PYGdefault{k+kt}{int} \PYGdefault{n}{res\PYGdefaultZus{}fpalu}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* total number of floating point multiplier/dividers available */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{res\PYGdefaultZus{}fpmult}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* options for Wattch */}
\PYGdefault{k+kt}{int} \PYGdefault{n}{data\PYGdefaultZus{}width} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{64}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* static power model results */}
\PYGdefault{k}{extern} \PYGdefault{n}{power\PYGdefaultZus{}result\PYGdefaultZus{}type} \PYGdefault{n}{power}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* counters added for Wattch */}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{rename\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{bpred\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{window\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{lsq\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{regfile\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{icache\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{dcache\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{dcache2\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{alu\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{ialu\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{falu\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{resultbus\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{window\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{window\PYGdefaultZus{}selection\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{window\PYGdefaultZus{}wakeup\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{lsq\PYGdefaultZus{}store\PYGdefaultZus{}data\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{lsq\PYGdefaultZus{}load\PYGdefaultZus{}data\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{lsq\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{lsq\PYGdefaultZus{}wakeup\PYGdefaultZus{}access}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{window\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{window\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{lsq\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{lsq\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{regfile\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{regfile\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{resultbus\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{resultbus\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* text\PYGdefaultZhy{}based stat profiles */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define MAX\PYGdefaultZus{}PCSTAT\PYGdefaultZus{}VARS 8}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{pcstat\PYGdefaultZus{}nelt} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{pcstat\PYGdefaultZus{}vars}\PYGdefault{p}{[}\PYGdefault{n}{MAX\PYGdefaultZus{}PCSTAT\PYGdefaultZus{}VARS}\PYGdefault{p}{];}

\PYGdefault{c+cm}{/* convert 64\PYGdefaultZhy{}bit inst text addresses to 32\PYGdefaultZhy{}bit inst equivalents */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef TARGET\PYGdefaultZus{}PISA}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define IACOMPRESS(A)							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  (compress\PYGdefaultZus{}icache\PYGdefaultZus{}addrs ? ((((A) \PYGdefaultZhy{} ld\PYGdefaultZus{}text\PYGdefaultZus{}base) \PYGdefaultZgt{}\PYGdefaultZgt{} 1) + ld\PYGdefaultZus{}text\PYGdefaultZus{}base) : (A))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define ISCOMPRESS(SZ)							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  (compress\PYGdefaultZus{}icache\PYGdefaultZus{}addrs ? ((SZ) \PYGdefaultZgt{}\PYGdefaultZgt{} 1) : (SZ))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}else }\PYGdefault{c+cm}{/* !TARGET\PYGdefaultZus{}PISA */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define IACOMPRESS(A)		(A)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define ISCOMPRESS(SZ)		(SZ)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif }\PYGdefault{c+cm}{/* TARGET\PYGdefaultZus{}PISA */}

\PYGdefault{c+cm}{/* operate in backward\PYGdefaultZhy{}compatible bugs mode (for testing only) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{bugcompat\PYGdefaultZus{}mode}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * functional unit resource configuration}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* resource pool indices, NOTE: update these if you change FU\PYGdefaultZus{}CONFIG */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FU\PYGdefaultZus{}IALU\PYGdefaultZus{}INDEX			0}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FU\PYGdefaultZus{}IMULT\PYGdefaultZus{}INDEX			1}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FU\PYGdefaultZus{}MEMPORT\PYGdefaultZus{}INDEX		2}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FU\PYGdefaultZus{}FPALU\PYGdefaultZus{}INDEX			3}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FU\PYGdefaultZus{}FPMULT\PYGdefaultZus{}INDEX			4}

\PYGdefault{c+cm}{/* resource pool definition, NOTE: update FU\PYGdefaultZus{}*\PYGdefaultZus{}INDEX defs if you change this */}
\PYGdefault{k}{struct} \PYGdefault{n}{res\PYGdefaultZus{}desc} \PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{[]} \PYGdefault{o}{=} \PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{p}{\PYGdefaultZob{}}
    \PYGdefault{l+s}{\PYGdefaultZdq{}integer\PYGdefaultZhy{}ALU\PYGdefaultZdq{}}\PYGdefault{p}{,}
    \PYGdefault{l+m+mi}{4}\PYGdefault{p}{,}
    \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n}{IntALU}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{1} \PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{p}{\PYGdefaultZcb{},}
  \PYGdefault{p}{\PYGdefaultZob{}}
    \PYGdefault{l+s}{\PYGdefaultZdq{}integer\PYGdefaultZhy{}MULT/DIV\PYGdefaultZdq{}}\PYGdefault{p}{,}
    \PYGdefault{l+m+mi}{1}\PYGdefault{p}{,}
    \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n}{IntMULT}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{3}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{1} \PYGdefault{p}{\PYGdefaultZcb{},}
      \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n}{IntDIV}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{20}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{19} \PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{p}{\PYGdefaultZcb{},}
  \PYGdefault{p}{\PYGdefaultZob{}}
    \PYGdefault{l+s}{\PYGdefaultZdq{}memory\PYGdefaultZhy{}port\PYGdefaultZdq{}}\PYGdefault{p}{,}
    \PYGdefault{l+m+mi}{2}\PYGdefault{p}{,}
    \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n}{RdPort}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{1} \PYGdefault{p}{\PYGdefaultZcb{},}
      \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n}{WrPort}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{1} \PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{p}{\PYGdefaultZcb{},}
  \PYGdefault{p}{\PYGdefaultZob{}}
    \PYGdefault{l+s}{\PYGdefaultZdq{}FP\PYGdefaultZhy{}adder\PYGdefaultZdq{}}\PYGdefault{p}{,}
    \PYGdefault{l+m+mi}{4}\PYGdefault{p}{,}
    \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n}{FloatADD}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{2}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{1} \PYGdefault{p}{\PYGdefaultZcb{},}
      \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n}{FloatCMP}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{2}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{1} \PYGdefault{p}{\PYGdefaultZcb{},}
      \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n}{FloatCVT}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{2}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{1} \PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{p}{\PYGdefaultZcb{},}
  \PYGdefault{p}{\PYGdefaultZob{}}
    \PYGdefault{l+s}{\PYGdefaultZdq{}FP\PYGdefaultZhy{}MULT/DIV\PYGdefaultZdq{}}\PYGdefault{p}{,}
    \PYGdefault{l+m+mi}{1}\PYGdefault{p}{,}
    \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n}{FloatMULT}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{4}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{1} \PYGdefault{p}{\PYGdefaultZcb{},}
      \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n}{FloatDIV}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{12}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{12} \PYGdefault{p}{\PYGdefaultZcb{},}
      \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n}{FloatSQRT}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{24}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{24} \PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{p}{\PYGdefaultZcb{},}
\PYGdefault{p}{\PYGdefaultZcb{};}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * simulator stats}
\PYGdefault{c+cm}{ */}
\PYGdefault{c+cm}{/* SLIP variable */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{sim\PYGdefaultZus{}slip} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* total number of instructions executed */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{sim\PYGdefaultZus{}total\PYGdefaultZus{}insn} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* total number of memory references committed */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}refs} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* total number of memory references executed */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{sim\PYGdefaultZus{}total\PYGdefaultZus{}refs} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* total number of loads committed */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}loads} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* total number of loads executed */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{sim\PYGdefaultZus{}total\PYGdefaultZus{}loads} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* total number of branches committed */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}branches} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* total number of branches executed */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{sim\PYGdefaultZus{}total\PYGdefaultZus{}branches} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* cycle counter */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{tick\PYGdefaultZus{}t} \PYGdefault{n}{sim\PYGdefaultZus{}cycle} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}




\PYGdefault{c+cm}{/* occupancy counters */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{IFQ\PYGdefaultZus{}count}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* cumulative IFQ occupancy */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{IFQ\PYGdefaultZus{}fcount}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* cumulative IFQ full count */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{RUU\PYGdefaultZus{}count}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* cumulative RUU occupancy */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{RUU\PYGdefaultZus{}fcount}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* cumulative RUU full count */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{LSQ\PYGdefaultZus{}count}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* cumulative LSQ occupancy */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{LSQ\PYGdefaultZus{}fcount}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* cumulative LSQ full count */}

\PYGdefault{c+cm}{/* total non\PYGdefaultZhy{}speculative bogus addresses seen (debug var) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{sim\PYGdefaultZus{}invalid\PYGdefaultZus{}addrs}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * simulator state variables}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* instruction sequence counter, used to assign unique id\PYGdefaultZsq{}s to insts */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{inst\PYGdefaultZus{}seq} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* pipetrace instruction sequence counter */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{ptrace\PYGdefaultZus{}seq} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* speculation mode, non\PYGdefaultZhy{}zero when mis\PYGdefaultZhy{}speculating, i.e., executing}
\PYGdefault{c+cm}{   instructions down the wrong path, thus state recovery will eventually have}
\PYGdefault{c+cm}{   to occur that resets processor register and memory state back to the last}
\PYGdefault{c+cm}{   precise state */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{spec\PYGdefaultZus{}mode} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* cycles until fetch issue resumes */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{unsigned} \PYGdefault{n}{ruu\PYGdefaultZus{}fetch\PYGdefaultZus{}issue\PYGdefaultZus{}delay} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* perfect prediction enabled */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{pred\PYGdefaultZus{}perfect} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* speculative bpred\PYGdefaultZhy{}update enabled */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{bpred\PYGdefaultZus{}spec\PYGdefaultZus{}opt}\PYGdefault{p}{;}
\PYGdefault{k}{static} \PYGdefault{k}{enum} \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n}{spec\PYGdefaultZus{}ID}\PYGdefault{p}{,} \PYGdefault{n}{spec\PYGdefaultZus{}WB}\PYGdefault{p}{,} \PYGdefault{n}{spec\PYGdefaultZus{}CT} \PYGdefault{p}{\PYGdefaultZcb{}} \PYGdefault{n}{bpred\PYGdefaultZus{}spec\PYGdefaultZus{}update}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* level 1 instruction cache, entry level instruction cache */}
\PYGdefault{k}{struct} \PYGdefault{k+kt}{cache\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{cache\PYGdefaultZus{}il1}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* level 1 instruction cache */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{k+kt}{cache\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{cache\PYGdefaultZus{}il2}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* level 1 data cache, entry level data cache */}
\PYGdefault{k}{struct} \PYGdefault{k+kt}{cache\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{cache\PYGdefaultZus{}dl1}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* level 2 data cache */}
\PYGdefault{k}{struct} \PYGdefault{k+kt}{cache\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{cache\PYGdefaultZus{}dl2}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* instruction TLB */}
\PYGdefault{k}{struct} \PYGdefault{k+kt}{cache\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{itlb}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* data TLB */}
\PYGdefault{k}{struct} \PYGdefault{k+kt}{cache\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{dtlb}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* branch predictor */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{k+kt}{bpred\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{pred}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* functional unit resource pool */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{res\PYGdefaultZus{}pool} \PYGdefault{o}{*}\PYGdefault{n}{fu\PYGdefaultZus{}pool} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* text\PYGdefaultZhy{}based stat profiles */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{k+kt}{stat\PYGdefaultZus{}stat\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{pcstat\PYGdefaultZus{}stats}\PYGdefault{p}{[}\PYGdefault{n}{MAX\PYGdefaultZus{}PCSTAT\PYGdefaultZus{}VARS}\PYGdefault{p}{];}
\PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{pcstat\PYGdefaultZus{}lastvals}\PYGdefault{p}{[}\PYGdefault{n}{MAX\PYGdefaultZus{}PCSTAT\PYGdefaultZus{}VARS}\PYGdefault{p}{];}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{k+kt}{stat\PYGdefaultZus{}stat\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{pcstat\PYGdefaultZus{}sdists}\PYGdefault{p}{[}\PYGdefault{n}{MAX\PYGdefaultZus{}PCSTAT\PYGdefaultZus{}VARS}\PYGdefault{p}{];}

\PYGdefault{c+cm}{/* wedge all stat values into a counter\PYGdefaultZus{}t */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define STATVAL(STAT)							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  ((STAT)\PYGdefaultZhy{}\PYGdefaultZgt{}sc == sc\PYGdefaultZus{}int							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{   ? (counter\PYGdefaultZus{}t)*((STAT)\PYGdefaultZhy{}\PYGdefaultZgt{}variant.for\PYGdefaultZus{}int.var)			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{   : ((STAT)\PYGdefaultZhy{}\PYGdefaultZgt{}sc == sc\PYGdefaultZus{}uint						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{      ? (counter\PYGdefaultZus{}t)*((STAT)\PYGdefaultZhy{}\PYGdefaultZgt{}variant.for\PYGdefaultZus{}uint.var)		\PYGdefaultZbs{}}
\PYGdefault{c+cp}{      : ((STAT)\PYGdefaultZhy{}\PYGdefaultZgt{}sc == sc\PYGdefaultZus{}counter					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	 ? *((STAT)\PYGdefaultZhy{}\PYGdefaultZgt{}variant.for\PYGdefaultZus{}counter.var)				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	 : (panic(\PYGdefaultZdq{}bad stat class\PYGdefaultZdq{}), 0))))}


\PYGdefault{c+cm}{/* memory access latency, assumed to not cross a page boundary */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int}			\PYGdefault{c+cm}{/* total latency of access */}
\PYGdefault{n}{mem\PYGdefaultZus{}access\PYGdefaultZus{}latency}\PYGdefault{p}{(}\PYGdefault{k+kt}{int} \PYGdefault{n}{blk\PYGdefaultZus{}sz}\PYGdefault{p}{)}		\PYGdefault{c+cm}{/* block size accessed */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{chunks} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{blk\PYGdefaultZus{}sz} \PYGdefault{o}{+} \PYGdefault{p}{(}\PYGdefault{n}{mem\PYGdefaultZus{}bus\PYGdefaultZus{}width} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{/} \PYGdefault{n}{mem\PYGdefaultZus{}bus\PYGdefaultZus{}width}\PYGdefault{p}{;}

  \PYGdefault{n}{assert}\PYGdefault{p}{(}\PYGdefault{n}{chunks} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}

  \PYGdefault{k}{return} \PYGdefault{p}{(}\PYGdefault{c+cm}{/* first chunk latency */}\PYGdefault{n}{mem\PYGdefaultZus{}lat}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]} \PYGdefault{o}{+}
	  \PYGdefault{p}{(}\PYGdefault{c+cm}{/* remainder chunk latency */}\PYGdefault{n}{mem\PYGdefaultZus{}lat}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{]} \PYGdefault{o}{*} \PYGdefault{p}{(}\PYGdefault{n}{chunks} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)));}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * cache miss handlers}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* l1 data cache l1 block miss handler function */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int}			\PYGdefault{c+cm}{/* latency of block access */}
\PYGdefault{n}{dl1\PYGdefaultZus{}access\PYGdefaultZus{}fn}\PYGdefault{p}{(}\PYGdefault{k}{enum} \PYGdefault{n}{mem\PYGdefaultZus{}cmd} \PYGdefault{n}{cmd}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* access cmd, Read or Write */}
	      \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{baddr}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* block address to access */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{bsize}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* size of block to access */}
	      \PYGdefault{k}{struct} \PYGdefault{k+kt}{cache\PYGdefaultZus{}blk\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{blk}\PYGdefault{p}{,}	\PYGdefault{c+cm}{/* ptr to block in upper level */}
	      \PYGdefault{k+kt}{tick\PYGdefaultZus{}t} \PYGdefault{n}{now}\PYGdefault{p}{)}		\PYGdefault{c+cm}{/* time of access */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{lat}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl2}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* access next level of data cache hierarchy */}
      \PYGdefault{n}{lat} \PYGdefault{o}{=} \PYGdefault{n}{cache\PYGdefaultZus{}access}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl2}\PYGdefault{p}{,} \PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{n}{baddr}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{n}{bsize}\PYGdefault{p}{,}
			 \PYGdefault{c+cm}{/* now */}\PYGdefault{n}{now}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* pudata */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* repl addr */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} Dcache2 access */}
      \PYGdefault{n}{dcache2\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}

      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cmd} \PYGdefault{o}{==} \PYGdefault{n}{Read}\PYGdefault{p}{)}
	\PYGdefault{k}{return} \PYGdefault{n}{lat}\PYGdefault{p}{;}
      \PYGdefault{k}{else}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* FIXME: unlimited write buffers */}
	  \PYGdefault{k}{return} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* access main memory */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cmd} \PYGdefault{o}{==} \PYGdefault{n}{Read}\PYGdefault{p}{)}
	\PYGdefault{k}{return} \PYGdefault{n}{mem\PYGdefaultZus{}access\PYGdefaultZus{}latency}\PYGdefault{p}{(}\PYGdefault{n}{bsize}\PYGdefault{p}{);}
      \PYGdefault{k}{else}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* FIXME: unlimited write buffers */}
	  \PYGdefault{k}{return} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* l2 data cache block miss handler function */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int}			\PYGdefault{c+cm}{/* latency of block access */}
\PYGdefault{n}{dl2\PYGdefaultZus{}access\PYGdefaultZus{}fn}\PYGdefault{p}{(}\PYGdefault{k}{enum} \PYGdefault{n}{mem\PYGdefaultZus{}cmd} \PYGdefault{n}{cmd}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* access cmd, Read or Write */}
	      \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{baddr}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* block address to access */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{bsize}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* size of block to access */}
	      \PYGdefault{k}{struct} \PYGdefault{k+kt}{cache\PYGdefaultZus{}blk\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{blk}\PYGdefault{p}{,}	\PYGdefault{c+cm}{/* ptr to block in upper level */}
	      \PYGdefault{k+kt}{tick\PYGdefaultZus{}t} \PYGdefault{n}{now}\PYGdefault{p}{)}		\PYGdefault{c+cm}{/* time of access */}
\PYGdefault{p}{\PYGdefaultZob{}}

  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} main memory access \PYGdefaultZhy{}\PYGdefaultZhy{} Wattch\PYGdefaultZhy{}FIXME (offchip) */}

  \PYGdefault{c+cm}{/* this is a miss to the lowest level, so access main memory */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cmd} \PYGdefault{o}{==} \PYGdefault{n}{Read}\PYGdefault{p}{)}
    \PYGdefault{k}{return} \PYGdefault{n}{mem\PYGdefaultZus{}access\PYGdefaultZus{}latency}\PYGdefault{p}{(}\PYGdefault{n}{bsize}\PYGdefault{p}{);}
  \PYGdefault{k}{else}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* FIXME: unlimited write buffers */}
      \PYGdefault{k}{return} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* l1 inst cache l1 block miss handler function */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int}			\PYGdefault{c+cm}{/* latency of block access */}
\PYGdefault{n}{il1\PYGdefaultZus{}access\PYGdefaultZus{}fn}\PYGdefault{p}{(}\PYGdefault{k}{enum} \PYGdefault{n}{mem\PYGdefaultZus{}cmd} \PYGdefault{n}{cmd}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* access cmd, Read or Write */}
	      \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{baddr}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* block address to access */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{bsize}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* size of block to access */}
	      \PYGdefault{k}{struct} \PYGdefault{k+kt}{cache\PYGdefaultZus{}blk\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{blk}\PYGdefault{p}{,}	\PYGdefault{c+cm}{/* ptr to block in upper level */}
	      \PYGdefault{k+kt}{tick\PYGdefaultZus{}t} \PYGdefault{n}{now}\PYGdefault{p}{)}		\PYGdefault{c+cm}{/* time of access */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{lat}\PYGdefault{p}{;}

\PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il2}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* access next level of inst cache hierarchy */}
      \PYGdefault{n}{lat} \PYGdefault{o}{=} \PYGdefault{n}{cache\PYGdefaultZus{}access}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il2}\PYGdefault{p}{,} \PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{n}{baddr}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{n}{bsize}\PYGdefault{p}{,}
			 \PYGdefault{c+cm}{/* now */}\PYGdefault{n}{now}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* pudata */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* repl addr */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} Dcache2 access */}
      \PYGdefault{n}{dcache2\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}

      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cmd} \PYGdefault{o}{==} \PYGdefault{n}{Read}\PYGdefault{p}{)}
	\PYGdefault{k}{return} \PYGdefault{n}{lat}\PYGdefault{p}{;}
      \PYGdefault{k}{else}
	\PYGdefault{n+nf}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}writes to instruction memory not supported\PYGdefaultZdq{}}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* access main memory */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cmd} \PYGdefault{o}{==} \PYGdefault{n}{Read}\PYGdefault{p}{)}
	\PYGdefault{k}{return} \PYGdefault{n}{mem\PYGdefaultZus{}access\PYGdefaultZus{}latency}\PYGdefault{p}{(}\PYGdefault{n}{bsize}\PYGdefault{p}{);}
      \PYGdefault{k}{else}
	\PYGdefault{n+nf}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}writes to instruction memory not supported\PYGdefaultZdq{}}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* l2 inst cache block miss handler function */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int}			\PYGdefault{c+cm}{/* latency of block access */}
\PYGdefault{n}{il2\PYGdefaultZus{}access\PYGdefaultZus{}fn}\PYGdefault{p}{(}\PYGdefault{k}{enum} \PYGdefault{n}{mem\PYGdefaultZus{}cmd} \PYGdefault{n}{cmd}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* access cmd, Read or Write */}
	      \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{baddr}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* block address to access */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{bsize}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* size of block to access */}
	      \PYGdefault{k}{struct} \PYGdefault{k+kt}{cache\PYGdefaultZus{}blk\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{blk}\PYGdefault{p}{,}	\PYGdefault{c+cm}{/* ptr to block in upper level */}
	      \PYGdefault{k+kt}{tick\PYGdefaultZus{}t} \PYGdefault{n}{now}\PYGdefault{p}{)}		\PYGdefault{c+cm}{/* time of access */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} main memory access \PYGdefaultZhy{}\PYGdefaultZhy{} Wattch\PYGdefaultZhy{}FIXME (offchip) */}

  \PYGdefault{c+cm}{/* this is a miss to the lowest level, so access main memory */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cmd} \PYGdefault{o}{==} \PYGdefault{n}{Read}\PYGdefault{p}{)}
    \PYGdefault{k}{return} \PYGdefault{n}{mem\PYGdefaultZus{}access\PYGdefaultZus{}latency}\PYGdefault{p}{(}\PYGdefault{n}{bsize}\PYGdefault{p}{);}
  \PYGdefault{k}{else}
    \PYGdefault{n+nf}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}writes to instruction memory not supported\PYGdefaultZdq{}}\PYGdefault{p}{);}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * TLB miss handlers}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* inst cache block miss handler function */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int}			\PYGdefault{c+cm}{/* latency of block access */}
\PYGdefault{n}{itlb\PYGdefaultZus{}access\PYGdefaultZus{}fn}\PYGdefault{p}{(}\PYGdefault{k}{enum} \PYGdefault{n}{mem\PYGdefaultZus{}cmd} \PYGdefault{n}{cmd}\PYGdefault{p}{,}	\PYGdefault{c+cm}{/* access cmd, Read or Write */}
	       \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{baddr}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* block address to access */}
	       \PYGdefault{k+kt}{int} \PYGdefault{n}{bsize}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* size of block to access */}
	       \PYGdefault{k}{struct} \PYGdefault{k+kt}{cache\PYGdefaultZus{}blk\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{blk}\PYGdefault{p}{,}	\PYGdefault{c+cm}{/* ptr to block in upper level */}
	       \PYGdefault{k+kt}{tick\PYGdefaultZus{}t} \PYGdefault{n}{now}\PYGdefault{p}{)}		\PYGdefault{c+cm}{/* time of access */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{phy\PYGdefaultZus{}page\PYGdefaultZus{}ptr} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{blk}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{user\PYGdefaultZus{}data}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* no real memory access, however, should have user data space attached */}
  \PYGdefault{n}{assert}\PYGdefault{p}{(}\PYGdefault{n}{phy\PYGdefaultZus{}page\PYGdefaultZus{}ptr}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* fake translation, for now... */}
  \PYGdefault{o}{*}\PYGdefault{n}{phy\PYGdefaultZus{}page\PYGdefaultZus{}ptr} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* return tlb miss latency */}
  \PYGdefault{k}{return} \PYGdefault{n}{tlb\PYGdefaultZus{}miss\PYGdefaultZus{}lat}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* data cache block miss handler function */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int}			\PYGdefault{c+cm}{/* latency of block access */}
\PYGdefault{n}{dtlb\PYGdefaultZus{}access\PYGdefaultZus{}fn}\PYGdefault{p}{(}\PYGdefault{k}{enum} \PYGdefault{n}{mem\PYGdefaultZus{}cmd} \PYGdefault{n}{cmd}\PYGdefault{p}{,}	\PYGdefault{c+cm}{/* access cmd, Read or Write */}
	       \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{baddr}\PYGdefault{p}{,}	\PYGdefault{c+cm}{/* block address to access */}
	       \PYGdefault{k+kt}{int} \PYGdefault{n}{bsize}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* size of block to access */}
	       \PYGdefault{k}{struct} \PYGdefault{k+kt}{cache\PYGdefaultZus{}blk\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{blk}\PYGdefault{p}{,}	\PYGdefault{c+cm}{/* ptr to block in upper level */}
	       \PYGdefault{k+kt}{tick\PYGdefaultZus{}t} \PYGdefault{n}{now}\PYGdefault{p}{)}		\PYGdefault{c+cm}{/* time of access */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{phy\PYGdefaultZus{}page\PYGdefaultZus{}ptr} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{blk}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{user\PYGdefaultZus{}data}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* no real memory access, however, should have user data space attached */}
  \PYGdefault{n}{assert}\PYGdefault{p}{(}\PYGdefault{n}{phy\PYGdefaultZus{}page\PYGdefaultZus{}ptr}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* fake translation, for now... */}
  \PYGdefault{o}{*}\PYGdefault{n}{phy\PYGdefaultZus{}page\PYGdefaultZus{}ptr} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* return tlb miss latency */}
  \PYGdefault{k}{return} \PYGdefault{n}{tlb\PYGdefaultZus{}miss\PYGdefaultZus{}lat}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/* register simulator\PYGdefaultZhy{}specific options */}
\PYGdefault{k+kt}{void}
\PYGdefault{n}{sim\PYGdefaultZus{}reg\PYGdefaultZus{}options}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{k+kt}{opt\PYGdefaultZus{}odb\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{odb}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}header}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} 
\PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZhy{}outorder: This simulator implements a very detailed out\PYGdefaultZhy{}of\PYGdefaultZhy{}order issue}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}superscalar processor with a two\PYGdefaultZhy{}level memory system and speculative}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}execution support.  This simulator is a performance simulator, tracking the}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}latency of all pipeline operations.}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
		 \PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* instruction limit */}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}uint}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}max:inst\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}maximum number of inst\PYGdefaultZsq{}s to execute\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{max\PYGdefaultZus{}insts}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
	       \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
	       
\PYGdefault{c+cm}{/******************************************/}	       
\PYGdefault{c+cm}{/* CS 203A Catching VSF and FSF from user */}	       
\PYGdefault{c+cm}{/******************************************/}	       
  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}DVFSInterval\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}Number of cycles for power monitoring interval\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{DVFSInterval}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{100000}\PYGdefault{p}{,}
	       \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
	       
  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}float}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}DVFSTargetPower\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}Target power budget controlled at each interval\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{DVFSTargetPower}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mf}{6000000.00}\PYGdefault{p}{,}
	       \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZpc{}12.2f\PYGdefaultZdq{}}\PYGdefault{p}{);}	 

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}float}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}DVFSIncrement\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}Increment for scaling of Voltage and Frequency\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{DVFSIncrement}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mf}{0.1}\PYGdefault{p}{,}
	       \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZpc{}12.1f\PYGdefaultZdq{}}\PYGdefault{p}{);}	 
	       
  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}flag}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}DVFSTurnOff\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}Do not execute the DVFS controller\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{DVFSTurnOff}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,}
	       \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}	       

\PYGdefault{c+cm}{/******************************************/}	       
\PYGdefault{c+cm}{/*                                        */}	       
\PYGdefault{c+cm}{/******************************************/}	

  \PYGdefault{c+cm}{/* trace options */}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}fastfwd\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}number of insts skipped before timing starts\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{fastfwd\PYGdefaultZus{}count}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}string\PYGdefaultZus{}list}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}ptrace\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}generate pipetrace, i.e., \PYGdefaultZlt{}fname|stdout|stderr\PYGdefaultZgt{} \PYGdefaultZlt{}range\PYGdefaultZgt{}\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{n}{ptrace\PYGdefaultZus{}opts}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* arr\PYGdefaultZus{}sz */}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ptrace\PYGdefaultZus{}nelt}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* !print */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* !accrue */}\PYGdefault{n}{FALSE}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}note}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,}
\PYGdefault{l+s}{\PYGdefaultZdq{}  Pipetrace range arguments are formatted as follows:}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    \PYGdefaultZob{}\PYGdefaultZob{}@|\PYGdefaultZsh{}\PYGdefaultZcb{}\PYGdefaultZlt{}start\PYGdefaultZgt{}\PYGdefaultZcb{}:\PYGdefaultZob{}\PYGdefaultZob{}@|\PYGdefaultZsh{}|+\PYGdefaultZcb{}\PYGdefaultZlt{}end\PYGdefaultZgt{}\PYGdefaultZcb{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}  Both ends of the range are optional, if neither are specified, the entire}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}  execution is traced.  Ranges that start with a `@\PYGdefaultZsq{} designate an address}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}  range to be traced, those that start with an `\PYGdefaultZsh{}\PYGdefaultZsq{} designate a cycle count}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}  range.  All other range values represent an instruction count range.  The}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}  second argument, if specified with a `+\PYGdefaultZsq{}, indicates a value relative}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}  to the first argument, e.g., 1000:+100 == 1000:1100.  Program symbols may}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}  be used in all contexts.}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    Examples:   \PYGdefaultZhy{}ptrace FOO.trc \PYGdefaultZsh{}0:\PYGdefaultZsh{}1000}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}                \PYGdefaultZhy{}ptrace BAR.trc @2000:}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}                \PYGdefaultZhy{}ptrace BLAH.trc :1500}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}                \PYGdefaultZhy{}ptrace UXXE.trc :}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}                \PYGdefaultZhy{}ptrace FOOBAR.trc @main:+278}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
	       \PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* ifetch options */}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}fetch:ifqsize\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}instruction fetch queue size (in insts)\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{4}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}fetch:mplat\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}extra branch mis\PYGdefaultZhy{}prediction latency\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ruu\PYGdefaultZus{}branch\PYGdefaultZus{}penalty}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{3}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}fetch:speed\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}speed of front\PYGdefaultZhy{}end of machine relative to execution core\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{fetch\PYGdefaultZus{}speed}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* branch predictor options */}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}note}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,}
\PYGdefault{l+s}{\PYGdefaultZdq{}  Branch predictor configuration examples for 2\PYGdefaultZhy{}level predictor:}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    Configurations:   N, M, W, X}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      N   \PYGdefaultZsh{} entries in first level (\PYGdefaultZsh{} of shift register(s))}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      W   width of shift register(s)}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      M   \PYGdefaultZsh{} entries in 2nd level (\PYGdefaultZsh{} of counters, or other FSM)}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      X   (yes\PYGdefaultZhy{}1/no\PYGdefaultZhy{}0) xor history and address for 2nd level index}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    Sample predictors:}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      GAg     : 1, W, 2\PYGdefaultZca{}W, 0}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      GAp     : 1, W, M (M \PYGdefaultZgt{} 2\PYGdefaultZca{}W), 0}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      PAg     : N, W, 2\PYGdefaultZca{}W, 0}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      PAp     : N, W, M (M == 2\PYGdefaultZca{}(N+W)), 0}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      gshare  : 1, W, 2\PYGdefaultZca{}W, 1}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}  Predictor `comb\PYGdefaultZsq{} combines a bimodal and a 2\PYGdefaultZhy{}level predictor.}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
               \PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}string}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}bpred\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{l+s}{\PYGdefaultZdq{}branch predictor type \PYGdefaultZob{}nottaken|taken|perfect|bimod|2lev|comb\PYGdefaultZcb{}\PYGdefaultZdq{}}\PYGdefault{p}{,}
                 \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{pred\PYGdefaultZus{}type}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+s}{\PYGdefaultZdq{}bimod\PYGdefaultZdq{}}\PYGdefault{p}{,}
                 \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int\PYGdefaultZus{}list}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}bpred:bimod\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}bimodal predictor config (\PYGdefaultZlt{}table size\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{n}{bimod\PYGdefaultZus{}config}\PYGdefault{p}{,} \PYGdefault{n}{bimod\PYGdefaultZus{}nelt}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{bimod\PYGdefaultZus{}nelt}\PYGdefault{p}{,}
		   \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{bimod\PYGdefaultZus{}config}\PYGdefault{p}{,}
		   \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* !accrue */}\PYGdefault{n}{FALSE}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int\PYGdefaultZus{}list}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}bpred:2lev\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}2\PYGdefaultZhy{}level predictor config \PYGdefaultZdq{}}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}(\PYGdefaultZlt{}l1size\PYGdefaultZgt{} \PYGdefaultZlt{}l2size\PYGdefaultZgt{} \PYGdefaultZlt{}hist\PYGdefaultZus{}size\PYGdefaultZgt{} \PYGdefaultZlt{}xor\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{n}{twolev\PYGdefaultZus{}config}\PYGdefault{p}{,} \PYGdefault{n}{twolev\PYGdefaultZus{}nelt}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{twolev\PYGdefaultZus{}nelt}\PYGdefault{p}{,}
		   \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{twolev\PYGdefaultZus{}config}\PYGdefault{p}{,}
                   \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* !accrue */}\PYGdefault{n}{FALSE}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int\PYGdefaultZus{}list}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}bpred:comb\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}combining predictor config (\PYGdefaultZlt{}meta\PYGdefaultZus{}table\PYGdefaultZus{}size\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{n}{comb\PYGdefaultZus{}config}\PYGdefault{p}{,} \PYGdefault{n}{comb\PYGdefaultZus{}nelt}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{comb\PYGdefaultZus{}nelt}\PYGdefault{p}{,}
		   \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{comb\PYGdefaultZus{}config}\PYGdefault{p}{,}
		   \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* !accrue */}\PYGdefault{n}{FALSE}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}bpred:ras\PYGdefaultZdq{}}\PYGdefault{p}{,}
              \PYGdefault{l+s}{\PYGdefaultZdq{}return address stack size (0 for no return stack)\PYGdefaultZdq{}}\PYGdefault{p}{,}
              \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ras\PYGdefaultZus{}size}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{ras\PYGdefaultZus{}size}\PYGdefault{p}{,}
              \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int\PYGdefaultZus{}list}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}bpred:btb\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}BTB config (\PYGdefaultZlt{}num\PYGdefaultZus{}sets\PYGdefaultZgt{} \PYGdefaultZlt{}associativity\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{n}{btb\PYGdefaultZus{}config}\PYGdefault{p}{,} \PYGdefault{n}{btb\PYGdefaultZus{}nelt}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{btb\PYGdefaultZus{}nelt}\PYGdefault{p}{,}
		   \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{btb\PYGdefaultZus{}config}\PYGdefault{p}{,}
		   \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* !accrue */}\PYGdefault{n}{FALSE}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}string}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}bpred:spec\PYGdefaultZus{}update\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{l+s}{\PYGdefaultZdq{}speculative predictors update in \PYGdefaultZob{}ID|WB\PYGdefaultZcb{} (default non\PYGdefaultZhy{}spec)\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{bpred\PYGdefaultZus{}spec\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,}
		 \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* decode options */}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}decode:width\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}instruction decode B/W (insts/cycle)\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ruu\PYGdefaultZus{}decode\PYGdefaultZus{}width}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{4}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* issue options */}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}issue:width\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}instruction issue B/W (insts/cycle)\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ruu\PYGdefaultZus{}issue\PYGdefaultZus{}width}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{4}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}flag}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}issue:inorder\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}run pipeline with in\PYGdefaultZhy{}order issue\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ruu\PYGdefaultZus{}inorder\PYGdefaultZus{}issue}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,}
	       \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}flag}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}issue:wrongpath\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{l+s}{\PYGdefaultZdq{}issue instructions down wrong execution paths\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ruu\PYGdefaultZus{}include\PYGdefaultZus{}spec}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,}
	       \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* commit options */}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}commit:width\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}instruction commit B/W (insts/cycle)\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ruu\PYGdefaultZus{}commit\PYGdefaultZus{}width}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{4}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* register scheduler options */}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}ruu:size\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}register update unit (RUU) size\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{16}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* memory scheduler options  */}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}lsq:size\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}load/store queue (LSQ) size\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{8}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* cache options */}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}string}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}cache:dl1\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{l+s}{\PYGdefaultZdq{}l1 data cache config, i.e., \PYGdefaultZob{}\PYGdefaultZlt{}config\PYGdefaultZgt{}|none\PYGdefaultZcb{}\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cache\PYGdefaultZus{}dl1\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}dl1:128:32:4:l\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}note}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,}
\PYGdefault{l+s}{\PYGdefaultZdq{}  The cache config parameter \PYGdefaultZlt{}config\PYGdefaultZgt{} has the following format:}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    \PYGdefaultZlt{}name\PYGdefaultZgt{}:\PYGdefaultZlt{}nsets\PYGdefaultZgt{}:\PYGdefaultZlt{}bsize\PYGdefaultZgt{}:\PYGdefaultZlt{}assoc\PYGdefaultZgt{}:\PYGdefaultZlt{}repl\PYGdefaultZgt{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    \PYGdefaultZlt{}name\PYGdefaultZgt{}   \PYGdefaultZhy{} name of the cache being defined}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    \PYGdefaultZlt{}nsets\PYGdefaultZgt{}  \PYGdefaultZhy{} number of sets in the cache}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    \PYGdefaultZlt{}bsize\PYGdefaultZgt{}  \PYGdefaultZhy{} block size of the cache}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    \PYGdefaultZlt{}assoc\PYGdefaultZgt{}  \PYGdefaultZhy{} associativity of the cache}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    \PYGdefaultZlt{}repl\PYGdefaultZgt{}   \PYGdefaultZhy{} block replacement strategy, \PYGdefaultZsq{}l\PYGdefaultZsq{}\PYGdefaultZhy{}LRU, \PYGdefaultZsq{}f\PYGdefaultZsq{}\PYGdefaultZhy{}FIFO, \PYGdefaultZsq{}r\PYGdefaultZsq{}\PYGdefaultZhy{}random}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    Examples:   \PYGdefaultZhy{}cache:dl1 dl1:4096:32:1:l}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}                \PYGdefaultZhy{}dtlb dtlb:128:4096:32:r}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
	       \PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}cache:dl1lat\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}l1 data cache hit latency (in cycles)\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cache\PYGdefaultZus{}dl1\PYGdefaultZus{}lat}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}string}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}cache:dl2\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{l+s}{\PYGdefaultZdq{}l2 data cache config, i.e., \PYGdefaultZob{}\PYGdefaultZlt{}config\PYGdefaultZgt{}|none\PYGdefaultZcb{}\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cache\PYGdefaultZus{}dl2\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}ul2:1024:64:4:l\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}cache:dl2lat\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}l2 data cache hit latency (in cycles)\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cache\PYGdefaultZus{}dl2\PYGdefaultZus{}lat}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{6}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}string}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}cache:il1\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{l+s}{\PYGdefaultZdq{}l1 inst cache config, i.e., \PYGdefaultZob{}\PYGdefaultZlt{}config\PYGdefaultZgt{}|dl1|dl2|none\PYGdefaultZcb{}\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}il1:512:32:1:l\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}note}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,}
\PYGdefault{l+s}{\PYGdefaultZdq{}  Cache levels can be unified by pointing a level of the instruction cache}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}  hierarchy at the data cache hiearchy using the }\PYGdefault{l+s+se}{\PYGdefaultZbs{}\PYGdefaultZdq{}}\PYGdefault{l+s}{dl1}\PYGdefault{l+s+se}{\PYGdefaultZbs{}\PYGdefaultZdq{}}\PYGdefault{l+s}{ and }\PYGdefault{l+s+se}{\PYGdefaultZbs{}\PYGdefaultZdq{}}\PYGdefault{l+s}{dl2}\PYGdefault{l+s+se}{\PYGdefaultZbs{}\PYGdefaultZdq{}}\PYGdefault{l+s}{ cache}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}  configuration arguments.  Most sensible combinations are supported, e.g.,}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    A unified l2 cache (il2 is pointed at dl2):}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      \PYGdefaultZhy{}cache:il1 il1:128:64:1:l \PYGdefaultZhy{}cache:il2 dl2}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      \PYGdefaultZhy{}cache:dl1 dl1:256:32:1:l \PYGdefaultZhy{}cache:dl2 ul2:1024:64:2:l}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    Or, a fully unified cache hierarchy (il1 pointed at dl1):}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      \PYGdefaultZhy{}cache:il1 dl1}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}      \PYGdefaultZhy{}cache:dl1 ul1:256:32:1:l \PYGdefaultZhy{}cache:dl2 ul2:1024:64:2:l}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
	       \PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}cache:il1lat\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}l1 instruction cache hit latency (in cycles)\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}lat}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}string}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}cache:il2\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{l+s}{\PYGdefaultZdq{}l2 instruction cache config, i.e., \PYGdefaultZob{}\PYGdefaultZlt{}config\PYGdefaultZgt{}|dl2|none\PYGdefaultZcb{}\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cache\PYGdefaultZus{}il2\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}dl2\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}cache:il2lat\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}l2 instruction cache hit latency (in cycles)\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{cache\PYGdefaultZus{}il2\PYGdefaultZus{}lat}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{6}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}flag}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}cache:flush\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}flush caches on system calls\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{flush\PYGdefaultZus{}on\PYGdefaultZus{}syscalls}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}flag}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}cache:icompress\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{l+s}{\PYGdefaultZdq{}convert 64\PYGdefaultZhy{}bit inst addresses to 32\PYGdefaultZhy{}bit inst equivalents\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{compress\PYGdefaultZus{}icache\PYGdefaultZus{}addrs}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,}
	       \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* mem options */}
  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int\PYGdefaultZus{}list}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}mem:lat\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}memory access latency (\PYGdefaultZlt{}first\PYGdefaultZus{}chunk\PYGdefaultZgt{} \PYGdefaultZlt{}inter\PYGdefaultZus{}chunk\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{n}{mem\PYGdefaultZus{}lat}\PYGdefault{p}{,} \PYGdefault{n}{mem\PYGdefaultZus{}nelt}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{mem\PYGdefaultZus{}nelt}\PYGdefault{p}{,} \PYGdefault{n}{mem\PYGdefaultZus{}lat}\PYGdefault{p}{,}
		   \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* !accrue */}\PYGdefault{n}{FALSE}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}mem:width\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}memory access bus width (in bytes)\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{mem\PYGdefaultZus{}bus\PYGdefaultZus{}width}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{8}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* TLB options */}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}string}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}tlb:itlb\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{l+s}{\PYGdefaultZdq{}instruction TLB config, i.e., \PYGdefaultZob{}\PYGdefaultZlt{}config\PYGdefaultZgt{}|none\PYGdefaultZcb{}\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{itlb\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}itlb:16:4096:4:l\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}string}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}tlb:dtlb\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{l+s}{\PYGdefaultZdq{}data TLB config, i.e., \PYGdefaultZob{}\PYGdefaultZlt{}config\PYGdefaultZgt{}|none\PYGdefaultZcb{}\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{dtlb\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}dtlb:32:4096:4:l\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}tlb:lat\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}inst/data TLB miss latency (in cycles)\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{tlb\PYGdefaultZus{}miss\PYGdefaultZus{}lat}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{l+m+mi}{30}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* resource configuration */}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}res:ialu\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}total number of integer ALU\PYGdefaultZsq{}s available\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{res\PYGdefaultZus{}ialu}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{n}{FU\PYGdefaultZus{}IALU\PYGdefaultZus{}INDEX}\PYGdefault{p}{].}\PYGdefault{n}{quantity}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}res:imult\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}total number of integer multiplier/dividers available\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{res\PYGdefaultZus{}imult}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{n}{FU\PYGdefaultZus{}IMULT\PYGdefaultZus{}INDEX}\PYGdefault{p}{].}\PYGdefault{n}{quantity}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}res:memport\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}total number of memory system ports available (to CPU)\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{res\PYGdefaultZus{}memport}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{n}{FU\PYGdefaultZus{}MEMPORT\PYGdefaultZus{}INDEX}\PYGdefault{p}{].}\PYGdefault{n}{quantity}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}res:fpalu\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}total number of floating point ALU\PYGdefaultZsq{}s available\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{res\PYGdefaultZus{}fpalu}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{n}{FU\PYGdefaultZus{}FPALU\PYGdefaultZus{}INDEX}\PYGdefault{p}{].}\PYGdefault{n}{quantity}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}res:fpmult\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{l+s}{\PYGdefaultZdq{}total number of floating point multiplier/dividers available\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{res\PYGdefaultZus{}fpmult}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{n}{FU\PYGdefaultZus{}FPMULT\PYGdefaultZus{}INDEX}\PYGdefault{p}{].}\PYGdefault{n}{quantity}\PYGdefault{p}{,}
	      \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}string\PYGdefaultZus{}list}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}pcstat\PYGdefaultZdq{}}\PYGdefault{p}{,}
		      \PYGdefault{l+s}{\PYGdefaultZdq{}profile stat(s) against text addr\PYGdefaultZsq{}s (mult uses ok)\PYGdefaultZdq{}}\PYGdefault{p}{,}
		      \PYGdefault{n}{pcstat\PYGdefaultZus{}vars}\PYGdefault{p}{,} \PYGdefault{n}{MAX\PYGdefaultZus{}PCSTAT\PYGdefaultZus{}VARS}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{pcstat\PYGdefaultZus{}nelt}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,}
		      \PYGdefault{c+cm}{/* !print */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* accrue */}\PYGdefault{n}{TRUE}\PYGdefault{p}{);}

  \PYGdefault{n}{opt\PYGdefaultZus{}reg\PYGdefaultZus{}flag}\PYGdefault{p}{(}\PYGdefault{n}{odb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZhy{}bugcompat\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{l+s}{\PYGdefaultZdq{}operate in backward\PYGdefaultZhy{}compatible bugs mode (for testing only)\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{bugcompat\PYGdefaultZus{}mode}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* default */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* print */}\PYGdefault{n}{TRUE}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* check simulator\PYGdefaultZhy{}specific option values */}
\PYGdefault{k+kt}{void}
\PYGdefault{n}{sim\PYGdefaultZus{}check\PYGdefaultZus{}options}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{k+kt}{opt\PYGdefaultZus{}odb\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{odb}\PYGdefault{p}{,}        \PYGdefault{c+cm}{/* options database */}
		  \PYGdefault{k+kt}{int} \PYGdefault{n}{argc}\PYGdefault{p}{,} \PYGdefault{k+kt}{char} \PYGdefault{o}{**}\PYGdefault{n}{argv}\PYGdefault{p}{)}        \PYGdefault{c+cm}{/* command line arguments */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{char} \PYGdefault{n}{name}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{128}\PYGdefault{p}{],} \PYGdefault{n}{c}\PYGdefault{p}{;}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{n}{assoc}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{fastfwd\PYGdefaultZus{}count} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{0} \PYGdefault{o}{||} \PYGdefault{n}{fastfwd\PYGdefaultZus{}count} \PYGdefault{o}{\PYGdefaultZgt{}=} \PYGdefault{l+m+mi}{2147483647}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad fast forward count: \PYGdefaultZpc{}d\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{fastfwd\PYGdefaultZus{}count}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1} \PYGdefault{o}{||} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}inst fetch queue size must be positive \PYGdefaultZgt{} 0 and a power of two\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}branch\PYGdefaultZus{}penalty} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}mis\PYGdefaultZhy{}prediction penalty must be at least 1 cycle\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}speed} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}front\PYGdefaultZhy{}end speed must be positive and non\PYGdefaultZhy{}zero\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{pred\PYGdefaultZus{}type}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}perfect\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* perfect predictor */}
      \PYGdefault{n}{pred} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
      \PYGdefault{n}{pred\PYGdefaultZus{}perfect} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{pred\PYGdefaultZus{}type}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}taken\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* static predictor, not taken */}
      \PYGdefault{n}{pred} \PYGdefault{o}{=} \PYGdefault{n}{bpred\PYGdefaultZus{}create}\PYGdefault{p}{(}\PYGdefault{n}{BPredTaken}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{pred\PYGdefaultZus{}type}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}nottaken\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* static predictor, taken */}
      \PYGdefault{n}{pred} \PYGdefault{o}{=} \PYGdefault{n}{bpred\PYGdefaultZus{}create}\PYGdefault{p}{(}\PYGdefault{n}{BPredNotTaken}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{pred\PYGdefaultZus{}type}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}bimod\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* bimodal predictor, bpred\PYGdefaultZus{}create() checks BTB\PYGdefaultZus{}SIZE */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{bimod\PYGdefaultZus{}nelt} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad bimod predictor config (\PYGdefaultZlt{}table\PYGdefaultZus{}size\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{btb\PYGdefaultZus{}nelt} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{2}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad btb config (\PYGdefaultZlt{}num\PYGdefaultZus{}sets\PYGdefaultZgt{} \PYGdefaultZlt{}associativity\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* bimodal predictor, bpred\PYGdefaultZus{}create() checks BTB\PYGdefaultZus{}SIZE */}
      \PYGdefault{n}{pred} \PYGdefault{o}{=} \PYGdefault{n}{bpred\PYGdefaultZus{}create}\PYGdefault{p}{(}\PYGdefault{n}{BPred2bit}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* bimod table size */}\PYGdefault{n}{bimod\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* 2lev l1 size */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* 2lev l2 size */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* meta table size */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* history reg size */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* history xor address */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* btb sets */}\PYGdefault{n}{btb\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* btb assoc */}\PYGdefault{n}{btb\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* ret\PYGdefaultZhy{}addr stack size */}\PYGdefault{n}{ras\PYGdefaultZus{}size}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{pred\PYGdefaultZus{}type}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}2lev\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* 2\PYGdefaultZhy{}level adaptive predictor, bpred\PYGdefaultZus{}create() checks args */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{twolev\PYGdefaultZus{}nelt} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{4}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad 2\PYGdefaultZhy{}level pred config (\PYGdefaultZlt{}l1size\PYGdefaultZgt{} \PYGdefaultZlt{}l2size\PYGdefaultZgt{} \PYGdefaultZlt{}hist\PYGdefaultZus{}size\PYGdefaultZgt{} \PYGdefaultZlt{}xor\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{btb\PYGdefaultZus{}nelt} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{2}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad btb config (\PYGdefaultZlt{}num\PYGdefaultZus{}sets\PYGdefaultZgt{} \PYGdefaultZlt{}associativity\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{);}

      \PYGdefault{n}{pred} \PYGdefault{o}{=} \PYGdefault{n}{bpred\PYGdefaultZus{}create}\PYGdefault{p}{(}\PYGdefault{n}{BPred2Level}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* bimod table size */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* 2lev l1 size */}\PYGdefault{n}{twolev\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* 2lev l2 size */}\PYGdefault{n}{twolev\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* meta table size */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* history reg size */}\PYGdefault{n}{twolev\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* history xor address */}\PYGdefault{n}{twolev\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{3}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* btb sets */}\PYGdefault{n}{btb\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* btb assoc */}\PYGdefault{n}{btb\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* ret\PYGdefaultZhy{}addr stack size */}\PYGdefault{n}{ras\PYGdefaultZus{}size}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{pred\PYGdefaultZus{}type}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}comb\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* combining predictor, bpred\PYGdefaultZus{}create() checks args */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{twolev\PYGdefaultZus{}nelt} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{4}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad 2\PYGdefaultZhy{}level pred config (\PYGdefaultZlt{}l1size\PYGdefaultZgt{} \PYGdefaultZlt{}l2size\PYGdefaultZgt{} \PYGdefaultZlt{}hist\PYGdefaultZus{}size\PYGdefaultZgt{} \PYGdefaultZlt{}xor\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{bimod\PYGdefaultZus{}nelt} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad bimod predictor config (\PYGdefaultZlt{}table\PYGdefaultZus{}size\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{comb\PYGdefaultZus{}nelt} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad combining predictor config (\PYGdefaultZlt{}meta\PYGdefaultZus{}table\PYGdefaultZus{}size\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{btb\PYGdefaultZus{}nelt} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{2}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad btb config (\PYGdefaultZlt{}num\PYGdefaultZus{}sets\PYGdefaultZgt{} \PYGdefaultZlt{}associativity\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{);}

      \PYGdefault{n}{pred} \PYGdefault{o}{=} \PYGdefault{n}{bpred\PYGdefaultZus{}create}\PYGdefault{p}{(}\PYGdefault{n}{BPredComb}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* bimod table size */}\PYGdefault{n}{bimod\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* l1 size */}\PYGdefault{n}{twolev\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* l2 size */}\PYGdefault{n}{twolev\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* meta table size */}\PYGdefault{n}{comb\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* history reg size */}\PYGdefault{n}{twolev\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* history xor address */}\PYGdefault{n}{twolev\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{3}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* btb sets */}\PYGdefault{n}{btb\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* btb assoc */}\PYGdefault{n}{btb\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{],}
			  \PYGdefault{c+cm}{/* ret\PYGdefaultZhy{}addr stack size */}\PYGdefault{n}{ras\PYGdefaultZus{}size}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}cannot parse predictor type `\PYGdefaultZpc{}s\PYGdefaultZsq{}\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{pred\PYGdefaultZus{}type}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{bpred\PYGdefaultZus{}spec\PYGdefaultZus{}opt}\PYGdefault{p}{)}
    \PYGdefault{n}{bpred\PYGdefaultZus{}spec\PYGdefaultZus{}update} \PYGdefault{o}{=} \PYGdefault{n}{spec\PYGdefaultZus{}CT}\PYGdefault{p}{;}
  \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{bpred\PYGdefaultZus{}spec\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}ID\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{n}{bpred\PYGdefaultZus{}spec\PYGdefaultZus{}update} \PYGdefault{o}{=} \PYGdefault{n}{spec\PYGdefaultZus{}ID}\PYGdefault{p}{;}
  \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{bpred\PYGdefaultZus{}spec\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}WB\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{n}{bpred\PYGdefaultZus{}spec\PYGdefaultZus{}update} \PYGdefault{o}{=} \PYGdefault{n}{spec\PYGdefaultZus{}WB}\PYGdefault{p}{;}
  \PYGdefault{k}{else}
    \PYGdefault{n+nf}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad speculative update stage specifier, use \PYGdefaultZob{}ID|WB\PYGdefaultZcb{}\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}decode\PYGdefaultZus{}width} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1} \PYGdefault{o}{||} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}decode\PYGdefaultZus{}width} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}decode\PYGdefaultZus{}width}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}issue width must be positive non\PYGdefaultZhy{}zero and a power of two\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}issue\PYGdefaultZus{}width} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1} \PYGdefault{o}{||} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}issue\PYGdefaultZus{}width} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}issue\PYGdefaultZus{}width}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}issue width must be positive non\PYGdefaultZhy{}zero and a power of two\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}commit\PYGdefaultZus{}width} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}commit width must be positive non\PYGdefaultZhy{}zero\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{2} \PYGdefault{o}{||} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}RUU size must be a positive number \PYGdefaultZgt{} 1 and a power of two\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{LSQ\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{2} \PYGdefault{o}{||} \PYGdefault{p}{(}\PYGdefault{n}{LSQ\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}LSQ size must be a positive number \PYGdefaultZgt{} 1 and a power of two\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* use a level 1 D\PYGdefaultZhy{}cache? */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl1\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}none\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{n}{cache\PYGdefaultZus{}dl1} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* the level 2 D\PYGdefaultZhy{}cache cannot be defined */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl2\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}none\PYGdefaultZdq{}}\PYGdefault{p}{))}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}the l1 data cache must defined if the l2 cache is defined\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{n}{cache\PYGdefaultZus{}dl2} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{c+cm}{/* dl1 is defined */}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{sscanf}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl1\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZpc{}[\PYGdefaultZca{}:]:\PYGdefaultZpc{}d:\PYGdefaultZpc{}d:\PYGdefaultZpc{}d:\PYGdefaultZpc{}c\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{n}{name}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{assoc}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{c}\PYGdefault{p}{)} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{5}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad l1 D\PYGdefaultZhy{}cache parms: \PYGdefaultZlt{}name\PYGdefaultZgt{}:\PYGdefaultZlt{}nsets\PYGdefaultZgt{}:\PYGdefaultZlt{}bsize\PYGdefaultZgt{}:\PYGdefaultZlt{}assoc\PYGdefaultZgt{}:\PYGdefaultZlt{}repl\PYGdefaultZgt{}\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{n}{cache\PYGdefaultZus{}dl1} \PYGdefault{o}{=} \PYGdefault{n}{cache\PYGdefaultZus{}create}\PYGdefault{p}{(}\PYGdefault{n}{name}\PYGdefault{p}{,} \PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* balloc */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,}
			       \PYGdefault{c+cm}{/* usize */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n}{assoc}\PYGdefault{p}{,} \PYGdefault{n}{cache\PYGdefaultZus{}char2policy}\PYGdefault{p}{(}\PYGdefault{n}{c}\PYGdefault{p}{),}
			       \PYGdefault{n}{dl1\PYGdefaultZus{}access\PYGdefaultZus{}fn}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* hit lat */}\PYGdefault{n}{cache\PYGdefaultZus{}dl1\PYGdefaultZus{}lat}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* is the level 2 D\PYGdefaultZhy{}cache defined? */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl2\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}none\PYGdefaultZdq{}}\PYGdefault{p}{))}
	\PYGdefault{n}{cache\PYGdefaultZus{}dl2} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
      \PYGdefault{k}{else}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{sscanf}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl2\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZpc{}[\PYGdefaultZca{}:]:\PYGdefaultZpc{}d:\PYGdefaultZpc{}d:\PYGdefaultZpc{}d:\PYGdefaultZpc{}c\PYGdefaultZdq{}}\PYGdefault{p}{,}
		     \PYGdefault{n}{name}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{assoc}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{c}\PYGdefault{p}{)} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{5}\PYGdefault{p}{)}
	    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad l2 D\PYGdefaultZhy{}cache parms: \PYGdefaultZdq{}}
		  \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZlt{}name\PYGdefaultZgt{}:\PYGdefaultZlt{}nsets\PYGdefaultZgt{}:\PYGdefaultZlt{}bsize\PYGdefaultZgt{}:\PYGdefaultZlt{}assoc\PYGdefaultZgt{}:\PYGdefaultZlt{}repl\PYGdefaultZgt{}\PYGdefaultZdq{}}\PYGdefault{p}{);}
	  \PYGdefault{n}{cache\PYGdefaultZus{}dl2} \PYGdefault{o}{=} \PYGdefault{n}{cache\PYGdefaultZus{}create}\PYGdefault{p}{(}\PYGdefault{n}{name}\PYGdefault{p}{,} \PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* balloc */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,}
				   \PYGdefault{c+cm}{/* usize */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n}{assoc}\PYGdefault{p}{,} \PYGdefault{n}{cache\PYGdefaultZus{}char2policy}\PYGdefault{p}{(}\PYGdefault{n}{c}\PYGdefault{p}{),}
				   \PYGdefault{n}{dl2\PYGdefaultZus{}access\PYGdefaultZus{}fn}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* hit lat */}\PYGdefault{n}{cache\PYGdefaultZus{}dl2\PYGdefaultZus{}lat}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* use a level 1 I\PYGdefaultZhy{}cache? */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}none\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{n}{cache\PYGdefaultZus{}il1} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* the level 2 I\PYGdefaultZhy{}cache cannot be defined */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il2\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}none\PYGdefaultZdq{}}\PYGdefault{p}{))}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}the l1 inst cache must defined if the l2 cache is defined\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{n}{cache\PYGdefaultZus{}il2} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}dl1\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{cache\PYGdefaultZus{}dl1}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}I\PYGdefaultZhy{}cache l1 cannot access D\PYGdefaultZhy{}cache l1 as it\PYGdefaultZsq{}s undefined\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{n}{cache\PYGdefaultZus{}il1} \PYGdefault{o}{=} \PYGdefault{n}{cache\PYGdefaultZus{}dl1}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* the level 2 I\PYGdefaultZhy{}cache cannot be defined */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il2\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}none\PYGdefaultZdq{}}\PYGdefault{p}{))}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}the l1 inst cache must defined if the l2 cache is defined\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{n}{cache\PYGdefaultZus{}il2} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}dl2\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{cache\PYGdefaultZus{}dl2}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}I\PYGdefaultZhy{}cache l1 cannot access D\PYGdefaultZhy{}cache l2 as it\PYGdefaultZsq{}s undefined\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{n}{cache\PYGdefaultZus{}il1} \PYGdefault{o}{=} \PYGdefault{n}{cache\PYGdefaultZus{}dl2}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* the level 2 I\PYGdefaultZhy{}cache cannot be defined */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il2\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}none\PYGdefaultZdq{}}\PYGdefault{p}{))}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}the l1 inst cache must defined if the l2 cache is defined\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{n}{cache\PYGdefaultZus{}il2} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{c+cm}{/* il1 is defined */}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{sscanf}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZpc{}[\PYGdefaultZca{}:]:\PYGdefaultZpc{}d:\PYGdefaultZpc{}d:\PYGdefaultZpc{}d:\PYGdefaultZpc{}c\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{n}{name}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{assoc}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{c}\PYGdefault{p}{)} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{5}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad l1 I\PYGdefaultZhy{}cache parms: \PYGdefaultZlt{}name\PYGdefaultZgt{}:\PYGdefaultZlt{}nsets\PYGdefaultZgt{}:\PYGdefaultZlt{}bsize\PYGdefaultZgt{}:\PYGdefaultZlt{}assoc\PYGdefaultZgt{}:\PYGdefaultZlt{}repl\PYGdefaultZgt{}\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{n}{cache\PYGdefaultZus{}il1} \PYGdefault{o}{=} \PYGdefault{n}{cache\PYGdefaultZus{}create}\PYGdefault{p}{(}\PYGdefault{n}{name}\PYGdefault{p}{,} \PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* balloc */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,}
			       \PYGdefault{c+cm}{/* usize */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n}{assoc}\PYGdefault{p}{,} \PYGdefault{n}{cache\PYGdefaultZus{}char2policy}\PYGdefault{p}{(}\PYGdefault{n}{c}\PYGdefault{p}{),}
			       \PYGdefault{n}{il1\PYGdefaultZus{}access\PYGdefaultZus{}fn}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* hit lat */}\PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}lat}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* is the level 2 D\PYGdefaultZhy{}cache defined? */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il2\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}none\PYGdefaultZdq{}}\PYGdefault{p}{))}
	\PYGdefault{n}{cache\PYGdefaultZus{}il2} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
      \PYGdefault{k}{else} \PYGdefault{n+nf}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il2\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}dl2\PYGdefaultZdq{}}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{cache\PYGdefaultZus{}dl2}\PYGdefault{p}{)}
	    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}I\PYGdefaultZhy{}cache l2 cannot access D\PYGdefaultZhy{}cache l2 as it\PYGdefaultZsq{}s undefined\PYGdefaultZdq{}}\PYGdefault{p}{);}
	  \PYGdefault{n}{cache\PYGdefaultZus{}il2} \PYGdefault{o}{=} \PYGdefault{n}{cache\PYGdefaultZus{}dl2}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{else}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{sscanf}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il2\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZpc{}[\PYGdefaultZca{}:]:\PYGdefaultZpc{}d:\PYGdefaultZpc{}d:\PYGdefaultZpc{}d:\PYGdefaultZpc{}c\PYGdefaultZdq{}}\PYGdefault{p}{,}
		     \PYGdefault{n}{name}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{assoc}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{c}\PYGdefault{p}{)} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{5}\PYGdefault{p}{)}
	    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad l2 I\PYGdefaultZhy{}cache parms: \PYGdefaultZdq{}}
		  \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZlt{}name\PYGdefaultZgt{}:\PYGdefaultZlt{}nsets\PYGdefaultZgt{}:\PYGdefaultZlt{}bsize\PYGdefaultZgt{}:\PYGdefaultZlt{}assoc\PYGdefaultZgt{}:\PYGdefaultZlt{}repl\PYGdefaultZgt{}\PYGdefaultZdq{}}\PYGdefault{p}{);}
	  \PYGdefault{n}{cache\PYGdefaultZus{}il2} \PYGdefault{o}{=} \PYGdefault{n}{cache\PYGdefaultZus{}create}\PYGdefault{p}{(}\PYGdefault{n}{name}\PYGdefault{p}{,} \PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* balloc */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,}
				   \PYGdefault{c+cm}{/* usize */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n}{assoc}\PYGdefault{p}{,} \PYGdefault{n}{cache\PYGdefaultZus{}char2policy}\PYGdefault{p}{(}\PYGdefault{n}{c}\PYGdefault{p}{),}
				   \PYGdefault{n}{il2\PYGdefaultZus{}access\PYGdefaultZus{}fn}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* hit lat */}\PYGdefault{n}{cache\PYGdefaultZus{}il2\PYGdefaultZus{}lat}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* use an I\PYGdefaultZhy{}TLB? */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{itlb\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}none\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{n}{itlb} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
  \PYGdefault{k}{else}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{sscanf}\PYGdefault{p}{(}\PYGdefault{n}{itlb\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZpc{}[\PYGdefaultZca{}:]:\PYGdefaultZpc{}d:\PYGdefaultZpc{}d:\PYGdefaultZpc{}d:\PYGdefaultZpc{}c\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{n}{name}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{assoc}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{c}\PYGdefault{p}{)} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{5}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad TLB parms: \PYGdefaultZlt{}name\PYGdefaultZgt{}:\PYGdefaultZlt{}nsets\PYGdefaultZgt{}:\PYGdefaultZlt{}page\PYGdefaultZus{}size\PYGdefaultZgt{}:\PYGdefaultZlt{}assoc\PYGdefaultZgt{}:\PYGdefaultZlt{}repl\PYGdefaultZgt{}\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{n}{itlb} \PYGdefault{o}{=} \PYGdefault{n}{cache\PYGdefaultZus{}create}\PYGdefault{p}{(}\PYGdefault{n}{name}\PYGdefault{p}{,} \PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* balloc */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* usize */}\PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t}\PYGdefault{p}{),} \PYGdefault{n}{assoc}\PYGdefault{p}{,}
			  \PYGdefault{n}{cache\PYGdefaultZus{}char2policy}\PYGdefault{p}{(}\PYGdefault{n}{c}\PYGdefault{p}{),} \PYGdefault{n}{itlb\PYGdefaultZus{}access\PYGdefaultZus{}fn}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* hit latency */}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* use a D\PYGdefaultZhy{}TLB? */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{mystricmp}\PYGdefault{p}{(}\PYGdefault{n}{dtlb\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}none\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{n}{dtlb} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
  \PYGdefault{k}{else}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{sscanf}\PYGdefault{p}{(}\PYGdefault{n}{dtlb\PYGdefaultZus{}opt}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZpc{}[\PYGdefaultZca{}:]:\PYGdefaultZpc{}d:\PYGdefaultZpc{}d:\PYGdefaultZpc{}d:\PYGdefaultZpc{}c\PYGdefaultZdq{}}\PYGdefault{p}{,}
		 \PYGdefault{n}{name}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{assoc}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{c}\PYGdefault{p}{)} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{5}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad TLB parms: \PYGdefaultZlt{}name\PYGdefaultZgt{}:\PYGdefaultZlt{}nsets\PYGdefaultZgt{}:\PYGdefaultZlt{}page\PYGdefaultZus{}size\PYGdefaultZgt{}:\PYGdefaultZlt{}assoc\PYGdefaultZgt{}:\PYGdefaultZlt{}repl\PYGdefaultZgt{}\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{n}{dtlb} \PYGdefault{o}{=} \PYGdefault{n}{cache\PYGdefaultZus{}create}\PYGdefault{p}{(}\PYGdefault{n}{name}\PYGdefault{p}{,} \PYGdefault{n}{nsets}\PYGdefault{p}{,} \PYGdefault{n}{bsize}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* balloc */}\PYGdefault{n}{FALSE}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* usize */}\PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t}\PYGdefault{p}{),} \PYGdefault{n}{assoc}\PYGdefault{p}{,}
			  \PYGdefault{n}{cache\PYGdefaultZus{}char2policy}\PYGdefault{p}{(}\PYGdefault{n}{c}\PYGdefault{p}{),} \PYGdefault{n}{dtlb\PYGdefaultZus{}access\PYGdefaultZus{}fn}\PYGdefault{p}{,}
			  \PYGdefault{c+cm}{/* hit latency */}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl1\PYGdefaultZus{}lat} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}l1 data cache latency must be greater than zero\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl2\PYGdefaultZus{}lat} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}l2 data cache latency must be greater than zero\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}lat} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}l1 instruction cache latency must be greater than zero\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il2\PYGdefaultZus{}lat} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}l2 instruction cache latency must be greater than zero\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{mem\PYGdefaultZus{}nelt} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{2}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad memory access latency (\PYGdefaultZlt{}first\PYGdefaultZus{}chunk\PYGdefaultZgt{} \PYGdefaultZlt{}inter\PYGdefaultZus{}chunk\PYGdefaultZgt{})\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{mem\PYGdefaultZus{}lat}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1} \PYGdefault{o}{||} \PYGdefault{n}{mem\PYGdefaultZus{}lat}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{]} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}all memory access latencies must be greater than zero\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{mem\PYGdefaultZus{}bus\PYGdefaultZus{}width} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1} \PYGdefault{o}{||} \PYGdefault{p}{(}\PYGdefault{n}{mem\PYGdefaultZus{}bus\PYGdefaultZus{}width} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{mem\PYGdefaultZus{}bus\PYGdefaultZus{}width}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}memory bus width must be positive non\PYGdefaultZhy{}zero and a power of two\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{tlb\PYGdefaultZus{}miss\PYGdefaultZus{}lat} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}TLB miss latency must be greater than zero\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{res\PYGdefaultZus{}ialu} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}number of integer ALU\PYGdefaultZsq{}s must be greater than zero\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{res\PYGdefaultZus{}ialu} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{n}{MAX\PYGdefaultZus{}INSTS\PYGdefaultZus{}PER\PYGdefaultZus{}CLASS}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}number of integer ALU\PYGdefaultZsq{}s must be \PYGdefaultZlt{}= MAX\PYGdefaultZus{}INSTS\PYGdefaultZus{}PER\PYGdefaultZus{}CLASS\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{n}{FU\PYGdefaultZus{}IALU\PYGdefaultZus{}INDEX}\PYGdefault{p}{].}\PYGdefault{n}{quantity} \PYGdefault{o}{=} \PYGdefault{n}{res\PYGdefaultZus{}ialu}\PYGdefault{p}{;}
  
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{res\PYGdefaultZus{}imult} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}number of integer multiplier/dividers must be greater than zero\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{res\PYGdefaultZus{}imult} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{n}{MAX\PYGdefaultZus{}INSTS\PYGdefaultZus{}PER\PYGdefaultZus{}CLASS}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}number of integer mult/div\PYGdefaultZsq{}s must be \PYGdefaultZlt{}= MAX\PYGdefaultZus{}INSTS\PYGdefaultZus{}PER\PYGdefaultZus{}CLASS\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{n}{FU\PYGdefaultZus{}IMULT\PYGdefaultZus{}INDEX}\PYGdefault{p}{].}\PYGdefault{n}{quantity} \PYGdefault{o}{=} \PYGdefault{n}{res\PYGdefaultZus{}imult}\PYGdefault{p}{;}
  
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{res\PYGdefaultZus{}memport} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}number of memory system ports must be greater than zero\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{res\PYGdefaultZus{}memport} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{n}{MAX\PYGdefaultZus{}INSTS\PYGdefaultZus{}PER\PYGdefaultZus{}CLASS}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}number of memory system ports must be \PYGdefaultZlt{}= MAX\PYGdefaultZus{}INSTS\PYGdefaultZus{}PER\PYGdefaultZus{}CLASS\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{n}{FU\PYGdefaultZus{}MEMPORT\PYGdefaultZus{}INDEX}\PYGdefault{p}{].}\PYGdefault{n}{quantity} \PYGdefault{o}{=} \PYGdefault{n}{res\PYGdefaultZus{}memport}\PYGdefault{p}{;}
  
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{res\PYGdefaultZus{}fpalu} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}number of floating point ALU\PYGdefaultZsq{}s must be greater than zero\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{res\PYGdefaultZus{}fpalu} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{n}{MAX\PYGdefaultZus{}INSTS\PYGdefaultZus{}PER\PYGdefaultZus{}CLASS}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}number of floating point ALU\PYGdefaultZsq{}s must be \PYGdefaultZlt{}= MAX\PYGdefaultZus{}INSTS\PYGdefaultZus{}PER\PYGdefaultZus{}CLASS\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{n}{FU\PYGdefaultZus{}FPALU\PYGdefaultZus{}INDEX}\PYGdefault{p}{].}\PYGdefault{n}{quantity} \PYGdefault{o}{=} \PYGdefault{n}{res\PYGdefaultZus{}fpalu}\PYGdefault{p}{;}
  
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{res\PYGdefaultZus{}fpmult} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}number of floating point multiplier/dividers must be \PYGdefaultZgt{} zero\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{res\PYGdefaultZus{}fpmult} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{n}{MAX\PYGdefaultZus{}INSTS\PYGdefaultZus{}PER\PYGdefaultZus{}CLASS}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}number of FP mult/div\PYGdefaultZsq{}s must be \PYGdefaultZlt{}= MAX\PYGdefaultZus{}INSTS\PYGdefaultZus{}PER\PYGdefaultZus{}CLASS\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{[}\PYGdefault{n}{FU\PYGdefaultZus{}FPMULT\PYGdefaultZus{}INDEX}\PYGdefault{p}{].}\PYGdefault{n}{quantity} \PYGdefault{o}{=} \PYGdefault{n}{res\PYGdefaultZus{}fpmult}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* print simulator\PYGdefaultZhy{}specific configuration information */}
\PYGdefault{k+kt}{void}
\PYGdefault{n}{sim\PYGdefaultZus{}aux\PYGdefaultZus{}config}\PYGdefault{p}{(}\PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{)}            \PYGdefault{c+cm}{/* output stream */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{c+cm}{/* nada */}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* register simulator\PYGdefaultZhy{}specific statistics */}
\PYGdefault{k+kt}{void}
\PYGdefault{n}{sim\PYGdefaultZus{}reg\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{k+kt}{stat\PYGdefaultZus{}sdb\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{sdb}\PYGdefault{p}{)}   \PYGdefault{c+cm}{/* stats database */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{;}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}num\PYGdefaultZus{}insn\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total number of instructions committed\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}insn}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}insn}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}num\PYGdefaultZus{}refs\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total number of loads and stores committed\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}refs}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}num\PYGdefaultZus{}loads\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total number of loads committed\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}loads}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}num\PYGdefaultZus{}stores\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total number of stores committed\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}num\PYGdefaultZus{}refs \PYGdefaultZhy{} sim\PYGdefaultZus{}num\PYGdefaultZus{}loads\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}num\PYGdefaultZus{}branches\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total number of branches committed\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}branches}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* initial value */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}int}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}elapsed\PYGdefaultZus{}time\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{l+s}{\PYGdefaultZdq{}total simulation time in seconds\PYGdefaultZdq{}}\PYGdefault{p}{,}
	       \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{sim\PYGdefaultZus{}elapsed\PYGdefaultZus{}time}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}inst\PYGdefaultZus{}rate\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}simulation speed (in insts/sec)\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}num\PYGdefaultZus{}insn / sim\PYGdefaultZus{}elapsed\PYGdefaultZus{}time\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}total\PYGdefaultZus{}insn\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total number of instructions executed\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{sim\PYGdefaultZus{}total\PYGdefaultZus{}insn}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}total\PYGdefaultZus{}refs\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total number of loads and stores executed\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{sim\PYGdefaultZus{}total\PYGdefaultZus{}refs}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}total\PYGdefaultZus{}loads\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total number of loads executed\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{sim\PYGdefaultZus{}total\PYGdefaultZus{}loads}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}total\PYGdefaultZus{}stores\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total number of stores executed\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}total\PYGdefaultZus{}refs \PYGdefaultZhy{} sim\PYGdefaultZus{}total\PYGdefaultZus{}loads\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}total\PYGdefaultZus{}branches\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total number of branches executed\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{sim\PYGdefaultZus{}total\PYGdefaultZus{}branches}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* initial value */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* register performance stats */}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}cycle\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total simulation time in cycles\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* initial value */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}IPC\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}instructions per cycle\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}num\PYGdefaultZus{}insn / sim\PYGdefaultZus{}cycle\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}CPI\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}cycles per instruction\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}cycle / sim\PYGdefaultZus{}num\PYGdefaultZus{}insn\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}exec\PYGdefaultZus{}BW\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total instructions (mis\PYGdefaultZhy{}spec + committed) per cycle\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}total\PYGdefaultZus{}insn / sim\PYGdefaultZus{}cycle\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}IPB\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}instruction per branch\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}num\PYGdefaultZus{}insn / sim\PYGdefaultZus{}num\PYGdefaultZus{}branches\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* occupancy stats */}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}IFQ\PYGdefaultZus{}count\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}cumulative IFQ occupancy\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{IFQ\PYGdefaultZus{}count}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* initial value */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}IFQ\PYGdefaultZus{}fcount\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}cumulative IFQ full count\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{IFQ\PYGdefaultZus{}fcount}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* initial value */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}ifq\PYGdefaultZus{}occupancy\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}avg IFQ occupancy (insn\PYGdefaultZsq{}s)\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}IFQ\PYGdefaultZus{}count / sim\PYGdefaultZus{}cycle\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}ifq\PYGdefaultZus{}rate\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}avg IFQ dispatch rate (insn/cycle)\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}total\PYGdefaultZus{}insn / sim\PYGdefaultZus{}cycle\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}ifq\PYGdefaultZus{}latency\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}avg IFQ occupant latency (cycle\PYGdefaultZsq{}s)\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}ifq\PYGdefaultZus{}occupancy / ifq\PYGdefaultZus{}rate\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}ifq\PYGdefaultZus{}full\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}fraction of time (cycle\PYGdefaultZsq{}s) IFQ was full\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}IFQ\PYGdefaultZus{}fcount / sim\PYGdefaultZus{}cycle\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}RUU\PYGdefaultZus{}count\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}cumulative RUU occupancy\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{RUU\PYGdefaultZus{}count}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* initial value */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}RUU\PYGdefaultZus{}fcount\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}cumulative RUU full count\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{RUU\PYGdefaultZus{}fcount}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* initial value */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}ruu\PYGdefaultZus{}occupancy\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}avg RUU occupancy (insn\PYGdefaultZsq{}s)\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}RUU\PYGdefaultZus{}count / sim\PYGdefaultZus{}cycle\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}ruu\PYGdefaultZus{}rate\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}avg RUU dispatch rate (insn/cycle)\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}total\PYGdefaultZus{}insn / sim\PYGdefaultZus{}cycle\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}ruu\PYGdefaultZus{}latency\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}avg RUU occupant latency (cycle\PYGdefaultZsq{}s)\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}ruu\PYGdefaultZus{}occupancy / ruu\PYGdefaultZus{}rate\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}ruu\PYGdefaultZus{}full\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}fraction of time (cycle\PYGdefaultZsq{}s) RUU was full\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}RUU\PYGdefaultZus{}fcount / sim\PYGdefaultZus{}cycle\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}LSQ\PYGdefaultZus{}count\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}cumulative LSQ occupancy\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{LSQ\PYGdefaultZus{}count}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* initial value */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}LSQ\PYGdefaultZus{}fcount\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}cumulative LSQ full count\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{LSQ\PYGdefaultZus{}fcount}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* initial value */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}lsq\PYGdefaultZus{}occupancy\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}avg LSQ occupancy (insn\PYGdefaultZsq{}s)\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}LSQ\PYGdefaultZus{}count / sim\PYGdefaultZus{}cycle\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}lsq\PYGdefaultZus{}rate\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}avg LSQ dispatch rate (insn/cycle)\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}total\PYGdefaultZus{}insn / sim\PYGdefaultZus{}cycle\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}lsq\PYGdefaultZus{}latency\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}avg LSQ occupant latency (cycle\PYGdefaultZsq{}s)\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}lsq\PYGdefaultZus{}occupancy / lsq\PYGdefaultZus{}rate\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}lsq\PYGdefaultZus{}full\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}fraction of time (cycle\PYGdefaultZsq{}s) LSQ was full\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}LSQ\PYGdefaultZus{}fcount / sim\PYGdefaultZus{}cycle\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}slip\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}total number of slip cycles\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{sim\PYGdefaultZus{}slip}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
  \PYGdefault{c+cm}{/* register baseline stats */}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}formula}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}avg\PYGdefaultZus{}sim\PYGdefaultZus{}slip\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}the average slip between issue and retirement\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}slip / sim\PYGdefaultZus{}num\PYGdefaultZus{}insn\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* register predictor stats */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{pred}\PYGdefault{p}{)}
    \PYGdefault{n}{bpred\PYGdefaultZus{}reg\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{n}{pred}\PYGdefault{p}{,} \PYGdefault{n}{sdb}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* register cache stats */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il1}
      \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il1} \PYGdefault{o}{!=} \PYGdefault{n}{cache\PYGdefaultZus{}dl1} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{cache\PYGdefaultZus{}il1} \PYGdefault{o}{!=} \PYGdefault{n}{cache\PYGdefaultZus{}dl2}\PYGdefault{p}{))}
    \PYGdefault{n}{cache\PYGdefaultZus{}reg\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il1}\PYGdefault{p}{,} \PYGdefault{n}{sdb}\PYGdefault{p}{);}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il2}
      \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il2} \PYGdefault{o}{!=} \PYGdefault{n}{cache\PYGdefaultZus{}dl1} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{cache\PYGdefaultZus{}il2} \PYGdefault{o}{!=} \PYGdefault{n}{cache\PYGdefaultZus{}dl2}\PYGdefault{p}{))}
    \PYGdefault{n}{cache\PYGdefaultZus{}reg\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il2}\PYGdefault{p}{,} \PYGdefault{n}{sdb}\PYGdefault{p}{);}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl1}\PYGdefault{p}{)}
    \PYGdefault{n}{cache\PYGdefaultZus{}reg\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl1}\PYGdefault{p}{,} \PYGdefault{n}{sdb}\PYGdefault{p}{);}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl2}\PYGdefault{p}{)}
    \PYGdefault{n}{cache\PYGdefaultZus{}reg\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl2}\PYGdefault{p}{,} \PYGdefault{n}{sdb}\PYGdefault{p}{);}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{itlb}\PYGdefault{p}{)}
    \PYGdefault{n}{cache\PYGdefaultZus{}reg\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{n}{itlb}\PYGdefault{p}{,} \PYGdefault{n}{sdb}\PYGdefault{p}{);}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{dtlb}\PYGdefault{p}{)}
    \PYGdefault{n}{cache\PYGdefaultZus{}reg\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{n}{dtlb}\PYGdefault{p}{,} \PYGdefault{n}{sdb}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* register power stats */}
  \PYGdefault{n}{power\PYGdefaultZus{}reg\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* debug variable(s) */}
  \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}counter}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim\PYGdefaultZus{}invalid\PYGdefaultZus{}addrs\PYGdefaultZdq{}}\PYGdefault{p}{,}
		   \PYGdefault{l+s}{\PYGdefaultZdq{}total non\PYGdefaultZhy{}speculative bogus addresses seen (debug var)\PYGdefaultZdq{}}\PYGdefault{p}{,}
                   \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{sim\PYGdefaultZus{}invalid\PYGdefaultZus{}addrs}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* initial value */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* format */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}

  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{pcstat\PYGdefaultZus{}nelt}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k+kt}{char} \PYGdefault{n}{buf}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{512}\PYGdefault{p}{],} \PYGdefault{n}{buf1}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{512}\PYGdefault{p}{];}
      \PYGdefault{k}{struct} \PYGdefault{k+kt}{stat\PYGdefaultZus{}stat\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{stat}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* track the named statistical variable by text address */}

      \PYGdefault{c+cm}{/* find it... */}
      \PYGdefault{n}{stat} \PYGdefault{o}{=} \PYGdefault{n}{stat\PYGdefaultZus{}find\PYGdefaultZus{}stat}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{n}{pcstat\PYGdefaultZus{}vars}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]);}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{stat}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}cannot locate any statistic named `\PYGdefaultZpc{}s\PYGdefaultZsq{}\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{pcstat\PYGdefaultZus{}vars}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]);}

      \PYGdefault{c+cm}{/* stat must be an integral type */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{stat}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{sc} \PYGdefault{o}{!=} \PYGdefault{n}{sc\PYGdefaultZus{}int} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{stat}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{sc} \PYGdefault{o}{!=} \PYGdefault{n}{sc\PYGdefaultZus{}uint} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{stat}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{sc} \PYGdefault{o}{!=} \PYGdefault{n}{sc\PYGdefaultZus{}counter}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}`\PYGdefaultZhy{}pcstat\PYGdefaultZsq{} statistical variable `\PYGdefaultZpc{}s\PYGdefaultZsq{} is not an integral type\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{n}{stat}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{name}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* register this stat */}
      \PYGdefault{n}{pcstat\PYGdefaultZus{}stats}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{stat}\PYGdefault{p}{;}
      \PYGdefault{n}{pcstat\PYGdefaultZus{}lastvals}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{STATVAL}\PYGdefault{p}{(}\PYGdefault{n}{stat}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* declare the sparce text distribution */}
      \PYGdefault{n}{sprintf}\PYGdefault{p}{(}\PYGdefault{n}{buf}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZpc{}s\PYGdefaultZus{}by\PYGdefaultZus{}pc\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{stat}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{name}\PYGdefault{p}{);}
      \PYGdefault{n}{sprintf}\PYGdefault{p}{(}\PYGdefault{n}{buf1}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZpc{}s (by text address)\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{stat}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{desc}\PYGdefault{p}{);}
      \PYGdefault{n}{pcstat\PYGdefaultZus{}sdists}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{stat\PYGdefaultZus{}reg\PYGdefaultZus{}sdist}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{,} \PYGdefault{n}{buf}\PYGdefault{p}{,} \PYGdefault{n}{buf1}\PYGdefault{p}{,}
					\PYGdefault{c+cm}{/* initial value */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
					\PYGdefault{c+cm}{/* print format */}\PYGdefault{p}{(}\PYGdefault{n}{PF\PYGdefaultZus{}COUNT}\PYGdefault{o}{|}\PYGdefault{n}{PF\PYGdefaultZus{}PDF}\PYGdefault{p}{),}
					\PYGdefault{c+cm}{/* format */}\PYGdefault{l+s}{\PYGdefaultZdq{}0x\PYGdefaultZpc{}lx \PYGdefaultZpc{}lu \PYGdefaultZpc{}.2f\PYGdefaultZdq{}}\PYGdefault{p}{,}
					\PYGdefault{c+cm}{/* print fn */}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{n}{ld\PYGdefaultZus{}reg\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{n}{sdb}\PYGdefault{p}{);}
  \PYGdefault{n}{mem\PYGdefaultZus{}reg\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{n}{mem}\PYGdefault{p}{,} \PYGdefault{n}{sdb}\PYGdefault{p}{);}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* forward declarations */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void} \PYGdefault{n}{ruu\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{);}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void} \PYGdefault{n+nf}{lsq\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{);}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void} \PYGdefault{n+nf}{rslink\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{int} \PYGdefault{n}{nlinks}\PYGdefault{p}{);}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void} \PYGdefault{n+nf}{eventq\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{);}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void} \PYGdefault{n+nf}{readyq\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{);}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void} \PYGdefault{n+nf}{cv\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{);}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void} \PYGdefault{n+nf}{tracer\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{);}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void} \PYGdefault{n+nf}{fetch\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{);}

\PYGdefault{c+cm}{/* initialize the simulator */}
\PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{sim\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}refs} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* allocate and initialize register file */}
  \PYGdefault{n}{regs\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{regs}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* allocate and initialize memory space */}
  \PYGdefault{n}{mem} \PYGdefault{o}{=} \PYGdefault{n}{mem\PYGdefaultZus{}create}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}mem\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{mem\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{n}{mem}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* compute static power estimates */}
  \PYGdefault{n}{calculate\PYGdefaultZus{}power}\PYGdefault{p}{(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{power}\PYGdefault{p}{);}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* default register state accessor, used by DLite */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}					\PYGdefault{c+cm}{/* err str, NULL for no err */}
\PYGdefault{n}{simoo\PYGdefaultZus{}reg\PYGdefaultZus{}obj}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{k+kt}{regs\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{regs}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* registers to access */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{is\PYGdefaultZus{}write}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* access type */}
	      \PYGdefault{k}{enum} \PYGdefault{n}{md\PYGdefaultZus{}reg\PYGdefaultZus{}type} \PYGdefault{n}{rt}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* reg bank to probe */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{reg}\PYGdefault{p}{,}				\PYGdefault{c+cm}{/* register number */}
	      \PYGdefault{k}{struct} \PYGdefault{k+kt}{eval\PYGdefaultZus{}value\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{val}\PYGdefault{p}{);}	\PYGdefault{c+cm}{/* input, output */}

\PYGdefault{c+cm}{/* default memory state accessor, used by DLite */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}					\PYGdefault{c+cm}{/* err str, NULL for no err */}
\PYGdefault{n}{simoo\PYGdefaultZus{}mem\PYGdefaultZus{}obj}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{k+kt}{mem\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{mem}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* memory space to access */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{is\PYGdefaultZus{}write}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* access type */}
	      \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{addr}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* address to access */}
	      \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{p}\PYGdefault{p}{,}				\PYGdefault{c+cm}{/* input/output buffer */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{nbytes}\PYGdefault{p}{);}			\PYGdefault{c+cm}{/* size of access */}

\PYGdefault{c+cm}{/* default machine state accessor, used by DLite */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}					\PYGdefault{c+cm}{/* err str, NULL for no err */}
\PYGdefault{n}{simoo\PYGdefaultZus{}mstate\PYGdefaultZus{}obj}\PYGdefault{p}{(}\PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* output stream */}
		 \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{cmd}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* optional command string */}
		 \PYGdefault{k}{struct} \PYGdefault{k+kt}{regs\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{regs}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* registers to access */}
		 \PYGdefault{k}{struct} \PYGdefault{k+kt}{mem\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{mem}\PYGdefault{p}{);}		\PYGdefault{c+cm}{/* memory space to access */}

\PYGdefault{c+cm}{/* total RS links allocated at program start */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define MAX\PYGdefaultZus{}RS\PYGdefaultZus{}LINKS                    4096}

\PYGdefault{c+cm}{/* load program into simulated state */}
\PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{sim\PYGdefaultZus{}load\PYGdefaultZus{}prog}\PYGdefault{p}{(}\PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{fname}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* program to load */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{argc}\PYGdefault{p}{,} \PYGdefault{k+kt}{char} \PYGdefault{o}{**}\PYGdefault{n}{argv}\PYGdefault{p}{,}	\PYGdefault{c+cm}{/* program arguments */}
	      \PYGdefault{k+kt}{char} \PYGdefault{o}{**}\PYGdefault{n}{envp}\PYGdefault{p}{)}		\PYGdefault{c+cm}{/* program environment */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{c+cm}{/* load program text and data, set up environment, memory, and regs */}
  \PYGdefault{n}{ld\PYGdefaultZus{}load\PYGdefaultZus{}prog}\PYGdefault{p}{(}\PYGdefault{n}{fname}\PYGdefault{p}{,} \PYGdefault{n}{argc}\PYGdefault{p}{,} \PYGdefault{n}{argv}\PYGdefault{p}{,} \PYGdefault{n}{envp}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{regs}\PYGdefault{p}{,} \PYGdefault{n}{mem}\PYGdefault{p}{,} \PYGdefault{n}{TRUE}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* initialize here, so symbols can be loaded */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ptrace\PYGdefaultZus{}nelt} \PYGdefault{o}{==} \PYGdefault{l+m+mi}{2}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* generate a pipeline trace */}
      \PYGdefault{n}{ptrace\PYGdefaultZus{}open}\PYGdefault{p}{(}\PYGdefault{c+cm}{/* fname */}\PYGdefault{n}{ptrace\PYGdefaultZus{}opts}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{],} \PYGdefault{c+cm}{/* range */}\PYGdefault{n}{ptrace\PYGdefaultZus{}opts}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{]);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ptrace\PYGdefaultZus{}nelt} \PYGdefault{o}{==} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* no pipetracing */}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bad pipetrace args, use: \PYGdefaultZlt{}fname|stdout|stderr\PYGdefaultZgt{} \PYGdefaultZlt{}range\PYGdefaultZgt{}\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* finish initialization of the simulation engine */}
  \PYGdefault{n}{fu\PYGdefaultZus{}pool} \PYGdefault{o}{=} \PYGdefault{n}{res\PYGdefaultZus{}create\PYGdefaultZus{}pool}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}fu\PYGdefaultZhy{}pool\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{,} \PYGdefault{n}{N\PYGdefaultZus{}ELT}\PYGdefault{p}{(}\PYGdefault{n}{fu\PYGdefaultZus{}config}\PYGdefault{p}{));}
  \PYGdefault{n}{rslink\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{n}{MAX\PYGdefaultZus{}RS\PYGdefaultZus{}LINKS}\PYGdefault{p}{);}
  \PYGdefault{n}{tracer\PYGdefaultZus{}init}\PYGdefault{p}{();}
  \PYGdefault{n}{fetch\PYGdefaultZus{}init}\PYGdefault{p}{();}
  \PYGdefault{n}{cv\PYGdefaultZus{}init}\PYGdefault{p}{();}
  \PYGdefault{n}{eventq\PYGdefaultZus{}init}\PYGdefault{p}{();}
  \PYGdefault{n}{readyq\PYGdefaultZus{}init}\PYGdefault{p}{();}
  \PYGdefault{n}{ruu\PYGdefaultZus{}init}\PYGdefault{p}{();}
  \PYGdefault{n}{lsq\PYGdefaultZus{}init}\PYGdefault{p}{();}

  \PYGdefault{c+cm}{/* initialize the DLite debugger */}
  \PYGdefault{n}{dlite\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{n}{simoo\PYGdefaultZus{}reg\PYGdefaultZus{}obj}\PYGdefault{p}{,} \PYGdefault{n}{simoo\PYGdefaultZus{}mem\PYGdefaultZus{}obj}\PYGdefault{p}{,} \PYGdefault{n}{simoo\PYGdefaultZus{}mstate\PYGdefaultZus{}obj}\PYGdefault{p}{);}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* dump simulator\PYGdefaultZhy{}specific auxiliary simulator statistics */}
\PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{sim\PYGdefaultZus{}aux\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{)}             \PYGdefault{c+cm}{/* output stream */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{c+cm}{/* nada */}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* un\PYGdefaultZhy{}initialize the simulator */}
\PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{sim\PYGdefaultZus{}uninit}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ptrace\PYGdefaultZus{}nelt} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
    \PYGdefault{n}{ptrace\PYGdefaultZus{}close}\PYGdefault{p}{();}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * processor core definitions and declarations}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* inst tag type, used to tag an operation instance in the RUU */}
\PYGdefault{k}{typedef} \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{INST\PYGdefaultZus{}TAG\PYGdefaultZus{}TYPE}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* inst sequence type, used to order instructions in the ready list, if}
\PYGdefault{c+cm}{   this rolls over the ready list order temporarily will get messed up,}
\PYGdefault{c+cm}{   but execution will continue and complete correctly */}
\PYGdefault{k}{typedef} \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{INST\PYGdefaultZus{}SEQ\PYGdefaultZus{}TYPE}\PYGdefault{p}{;}


\PYGdefault{c+cm}{/* total input dependencies possible */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define MAX\PYGdefaultZus{}IDEPS               3}

\PYGdefault{c+cm}{/* total output dependencies possible */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define MAX\PYGdefaultZus{}ODEPS               2}

\PYGdefault{c+cm}{/* a register update unit (RUU) station, this record is contained in the}
\PYGdefault{c+cm}{   processors RUU, which serves as a collection of ordered reservations}
\PYGdefault{c+cm}{   stations.  The reservation stations capture register results and await}
\PYGdefault{c+cm}{   the time when all operands are ready, at which time the instruction is}
\PYGdefault{c+cm}{   issued to the functional units; the RUU is an order circular queue, in which}
\PYGdefault{c+cm}{   instructions are inserted in fetch (program) order, results are stored in}
\PYGdefault{c+cm}{   the RUU buffers, and later when an RUU entry is the oldest entry in the}
\PYGdefault{c+cm}{   machines, it and its instruction\PYGdefaultZsq{}s value is retired to the architectural}
\PYGdefault{c+cm}{   register file in program order, NOTE: the RUU and LSQ share the same}
\PYGdefault{c+cm}{   structure, this is useful because loads and stores are split into two}
\PYGdefault{c+cm}{   operations: an effective address add and a load/store, the add is inserted}
\PYGdefault{c+cm}{   into the RUU and the load/store inserted into the LSQ, allowing the add}
\PYGdefault{c+cm}{   to wake up the load/store when effective address computation has finished */}
\PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{c+cm}{/* inst info */}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t} \PYGdefault{n}{IR}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* instruction bits */}
  \PYGdefault{k}{enum} \PYGdefault{n}{md\PYGdefaultZus{}opcode} \PYGdefault{n}{op}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* decoded instruction opcode */}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{PC}\PYGdefault{p}{,} \PYGdefault{n}{next\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{pred\PYGdefaultZus{}PC}\PYGdefault{p}{;}	\PYGdefault{c+cm}{/* inst PC, next PC, predicted PC */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{in\PYGdefaultZus{}LSQ}\PYGdefault{p}{;}				\PYGdefault{c+cm}{/* non\PYGdefaultZhy{}zero if op is in LSQ */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{ea\PYGdefaultZus{}comp}\PYGdefault{p}{;}				\PYGdefault{c+cm}{/* non\PYGdefaultZhy{}zero if op is an addr comp */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{recover\PYGdefaultZus{}inst}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* start of mis\PYGdefaultZhy{}speculation? */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* non\PYGdefaultZhy{}speculative TOS for RSB pred */}
  \PYGdefault{k}{struct} \PYGdefault{k+kt}{bpred\PYGdefaultZus{}update\PYGdefaultZus{}t} \PYGdefault{n}{dir\PYGdefaultZus{}update}\PYGdefault{p}{;}	\PYGdefault{c+cm}{/* bpred direction update info */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{spec\PYGdefaultZus{}mode}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* non\PYGdefaultZhy{}zero if issued in spec\PYGdefaultZus{}mode */}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{addr}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* effective address for ld/st\PYGdefaultZsq{}s */}
  \PYGdefault{n}{INST\PYGdefaultZus{}TAG\PYGdefaultZus{}TYPE} \PYGdefault{n}{tag}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* RUU slot tag, increment to}
\PYGdefault{c+cm}{					   squash operation */}
  \PYGdefault{n}{INST\PYGdefaultZus{}SEQ\PYGdefaultZus{}TYPE} \PYGdefault{n}{seq}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* instruction sequence, used to}
\PYGdefault{c+cm}{					   sort the ready list and tag inst */}
  \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* pipetrace sequence number */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{slip}\PYGdefault{p}{;}
  \PYGdefault{c+cm}{/* instruction status */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{queued}\PYGdefault{p}{;}				\PYGdefault{c+cm}{/* operands ready and queued */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{issued}\PYGdefault{p}{;}				\PYGdefault{c+cm}{/* operation is/was executing */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{completed}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* operation has completed execution */}

  \PYGdefault{c+cm}{/* Wattch: values of source operands and result operand used for AF generation */}
  \PYGdefault{k+kt}{quad\PYGdefaultZus{}t} \PYGdefault{n}{val\PYGdefaultZus{}ra}\PYGdefault{p}{,} \PYGdefault{n}{val\PYGdefaultZus{}rb}\PYGdefault{p}{,} \PYGdefault{n}{val\PYGdefaultZus{}rc}\PYGdefault{p}{,} \PYGdefault{n}{val\PYGdefaultZus{}ra\PYGdefaultZus{}result}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* output operand dependency list, these lists are used to}
\PYGdefault{c+cm}{     limit the number of associative searches into the RUU when}
\PYGdefault{c+cm}{     instructions complete and need to wake up dependent insts */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{onames}\PYGdefault{p}{[}\PYGdefault{n}{MAX\PYGdefaultZus{}ODEPS}\PYGdefault{p}{];}		\PYGdefault{c+cm}{/* output logical names (NA=unused) */}
  \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{odep\PYGdefaultZus{}list}\PYGdefault{p}{[}\PYGdefault{n}{MAX\PYGdefaultZus{}ODEPS}\PYGdefault{p}{];}	\PYGdefault{c+cm}{/* chains to consuming operations */}

  \PYGdefault{c+cm}{/* input dependent links, the output chains rooted above use these}
\PYGdefault{c+cm}{     fields to mark input operands as ready, when all these fields have}
\PYGdefault{c+cm}{     been set non\PYGdefaultZhy{}zero, the RUU operation has all of its register}
\PYGdefault{c+cm}{     operands, it may commence execution as soon as all of its memory}
\PYGdefault{c+cm}{     operands are known to be read (see lsq\PYGdefaultZus{}refresh() for details on}
\PYGdefault{c+cm}{     enforcing memory dependencies) */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{idep\PYGdefaultZus{}ready}\PYGdefault{p}{[}\PYGdefault{n}{MAX\PYGdefaultZus{}IDEPS}\PYGdefault{p}{];}		\PYGdefault{c+cm}{/* input operand ready? */}
\PYGdefault{p}{\PYGdefaultZcb{};}

\PYGdefault{c+cm}{/* non\PYGdefaultZhy{}zero if all register operands are ready, update with MAX\PYGdefaultZus{}IDEPS */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define OPERANDS\PYGdefaultZus{}READY(RS)                                              \PYGdefaultZbs{}}
\PYGdefault{c+cp}{  ((RS)\PYGdefaultZhy{}\PYGdefaultZgt{}idep\PYGdefaultZus{}ready[0] \PYGdefaultZam{}\PYGdefaultZam{} (RS)\PYGdefaultZhy{}\PYGdefaultZgt{}idep\PYGdefaultZus{}ready[1] \PYGdefaultZam{}\PYGdefaultZam{} (RS)\PYGdefaultZhy{}\PYGdefaultZgt{}idep\PYGdefaultZus{}ready[2])}

\PYGdefault{c+cm}{/* non\PYGdefaultZhy{}zero if one register operands is ready, update with MAX\PYGdefaultZus{}IDEPS */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define ONE\PYGdefaultZus{}OPERANDS\PYGdefaultZus{}READY(RS)                                              \PYGdefaultZbs{}}
\PYGdefault{c+cp}{  ((RS)\PYGdefaultZhy{}\PYGdefaultZgt{}idep\PYGdefaultZus{}ready[0] || (RS)\PYGdefaultZhy{}\PYGdefaultZgt{}idep\PYGdefaultZus{}ready[1])}

\PYGdefault{c+cm}{/* register update unit, combination of reservation stations and reorder}
\PYGdefault{c+cm}{   buffer device, organized as a circular queue */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{RUU}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* register update unit */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{,} \PYGdefault{n}{RUU\PYGdefaultZus{}tail}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* RUU head and tail pointers */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{RUU\PYGdefaultZus{}num}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* num entries currently in RUU */}

\PYGdefault{c+cm}{/* allocate and initialize register update unit (RUU) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{ruu\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{n}{RUU} \PYGdefault{o}{=} \PYGdefault{n}{calloc}\PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{p}{,} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station}\PYGdefault{p}{));}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{RUU}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}out of virtual memory\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{n}{RUU\PYGdefaultZus{}num} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{n}{RUU\PYGdefaultZus{}head} \PYGdefault{o}{=} \PYGdefault{n}{RUU\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{n}{RUU\PYGdefaultZus{}count} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{n}{RUU\PYGdefaultZus{}fcount} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* dump the contents of the RUU */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{ruu\PYGdefaultZus{}dumpent}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* ptr to RUU station */}
	    \PYGdefault{k+kt}{int} \PYGdefault{n}{index}\PYGdefault{p}{,}				\PYGdefault{c+cm}{/* entry index */}
	    \PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* output stream */}
	    \PYGdefault{k+kt}{int} \PYGdefault{n}{header}\PYGdefault{p}{)}				\PYGdefault{c+cm}{/* print header? */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{stream}\PYGdefault{p}{)}
    \PYGdefault{n}{stream} \PYGdefault{o}{=} \PYGdefault{n}{stderr}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{header}\PYGdefault{p}{)}
    \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}idx: \PYGdefaultZpc{}2d: opcode: \PYGdefaultZpc{}s, inst: `\PYGdefaultZdq{}}\PYGdefault{p}{,}
	    \PYGdefault{n}{index}\PYGdefault{p}{,} \PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}NAME}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{));}
  \PYGdefault{k}{else}
    \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}       opcode: \PYGdefaultZpc{}s, inst: `\PYGdefaultZdq{}}\PYGdefault{p}{,}
	    \PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}NAME}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{));}
  \PYGdefault{n}{md\PYGdefaultZus{}print\PYGdefaultZus{}insn}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{IR}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{PC}\PYGdefault{p}{,} \PYGdefault{n}{stream}\PYGdefault{p}{);}
  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZsq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{myfprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}         PC: 0x\PYGdefaultZpc{}08p, NPC: 0x\PYGdefaultZpc{}08p (pred\PYGdefaultZus{}PC: 0x\PYGdefaultZpc{}08p)}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
	    \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{PC}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{pred\PYGdefaultZus{}PC}\PYGdefault{p}{);}
  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}         in\PYGdefaultZus{}LSQ: \PYGdefaultZpc{}s, ea\PYGdefaultZus{}comp: \PYGdefaultZpc{}s, recover\PYGdefaultZus{}inst: \PYGdefaultZpc{}s}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ} \PYGdefault{o}{?} \PYGdefault{l+s}{\PYGdefaultZdq{}t\PYGdefaultZdq{}} \PYGdefault{o}{:} \PYGdefault{l+s}{\PYGdefaultZdq{}f\PYGdefaultZdq{}}\PYGdefault{p}{,}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ea\PYGdefaultZus{}comp} \PYGdefault{o}{?} \PYGdefault{l+s}{\PYGdefaultZdq{}t\PYGdefaultZdq{}} \PYGdefault{o}{:} \PYGdefault{l+s}{\PYGdefaultZdq{}f\PYGdefaultZdq{}}\PYGdefault{p}{,}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{recover\PYGdefaultZus{}inst} \PYGdefault{o}{?} \PYGdefault{l+s}{\PYGdefaultZdq{}t\PYGdefaultZdq{}} \PYGdefault{o}{:} \PYGdefault{l+s}{\PYGdefaultZdq{}f\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{myfprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}         spec\PYGdefaultZus{}mode: \PYGdefaultZpc{}s, addr: 0x\PYGdefaultZpc{}08p, tag: 0x\PYGdefaultZpc{}08x}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
	    \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{spec\PYGdefaultZus{}mode} \PYGdefault{o}{?} \PYGdefault{l+s}{\PYGdefaultZdq{}t\PYGdefaultZdq{}} \PYGdefault{o}{:} \PYGdefault{l+s}{\PYGdefaultZdq{}f\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{addr}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{tag}\PYGdefault{p}{);}
  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}         seq: 0x\PYGdefaultZpc{}08x, ptrace\PYGdefaultZus{}seq: 0x\PYGdefaultZpc{}08x}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{seq}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{);}
  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}         queued: \PYGdefaultZpc{}s, issued: \PYGdefaultZpc{}s, completed: \PYGdefaultZpc{}s}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{queued} \PYGdefault{o}{?} \PYGdefault{l+s}{\PYGdefaultZdq{}t\PYGdefaultZdq{}} \PYGdefault{o}{:} \PYGdefault{l+s}{\PYGdefaultZdq{}f\PYGdefaultZdq{}}\PYGdefault{p}{,}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{issued} \PYGdefault{o}{?} \PYGdefault{l+s}{\PYGdefaultZdq{}t\PYGdefaultZdq{}} \PYGdefault{o}{:} \PYGdefault{l+s}{\PYGdefaultZdq{}f\PYGdefaultZdq{}}\PYGdefault{p}{,}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{completed} \PYGdefault{o}{?} \PYGdefault{l+s}{\PYGdefaultZdq{}t\PYGdefaultZdq{}} \PYGdefault{o}{:} \PYGdefault{l+s}{\PYGdefaultZdq{}f\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}         operands ready: \PYGdefaultZpc{}s}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
	  \PYGdefault{n}{OPERANDS\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{)} \PYGdefault{o}{?} \PYGdefault{l+s}{\PYGdefaultZdq{}t\PYGdefaultZdq{}} \PYGdefault{o}{:} \PYGdefault{l+s}{\PYGdefaultZdq{}f\PYGdefaultZdq{}}\PYGdefault{p}{);}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* dump the contents of the RUU */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{ruu\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{)}				\PYGdefault{c+cm}{/* output stream */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{num}\PYGdefault{p}{,} \PYGdefault{n}{head}\PYGdefault{p}{;}
  \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{stream}\PYGdefault{p}{)}
    \PYGdefault{n}{stream} \PYGdefault{o}{=} \PYGdefault{n}{stderr}\PYGdefault{p}{;}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}** RUU state **}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}RUU\PYGdefaultZus{}head: \PYGdefaultZpc{}d, RUU\PYGdefaultZus{}tail: \PYGdefaultZpc{}d}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{,} \PYGdefault{n}{RUU\PYGdefaultZus{}tail}\PYGdefault{p}{);}
  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}RUU\PYGdefaultZus{}num: \PYGdefaultZpc{}d}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{RUU\PYGdefaultZus{}num}\PYGdefault{p}{);}

  \PYGdefault{n}{num} \PYGdefault{o}{=} \PYGdefault{n}{RUU\PYGdefaultZus{}num}\PYGdefault{p}{;}
  \PYGdefault{n}{head} \PYGdefault{o}{=} \PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{;}
  \PYGdefault{k}{while} \PYGdefault{p}{(}\PYGdefault{n}{num}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{n}{rs} \PYGdefault{o}{=} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{head}\PYGdefault{p}{];}
      \PYGdefault{n}{ruu\PYGdefaultZus{}dumpent}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{n}{rs} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{RUU}\PYGdefault{p}{,} \PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* header */}\PYGdefault{n}{TRUE}\PYGdefault{p}{);}
      \PYGdefault{n}{head} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{head} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{p}{;}
      \PYGdefault{n}{num}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZhy{}}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * load/store queue (LSQ): holds loads and stores in program order, indicating}
\PYGdefault{c+cm}{ * status of load/store access:}
\PYGdefault{c+cm}{ *}
\PYGdefault{c+cm}{ *   \PYGdefaultZhy{} issued: address computation complete, memory access in progress}
\PYGdefault{c+cm}{ *   \PYGdefaultZhy{} completed: memory access has completed, stored value available}
\PYGdefault{c+cm}{ *   \PYGdefaultZhy{} squashed: memory access was squashed, ignore this entry}
\PYGdefault{c+cm}{ *}
\PYGdefault{c+cm}{ * loads may execute when:}
\PYGdefault{c+cm}{ *   1) register operands are ready, and}
\PYGdefault{c+cm}{ *   2) memory operands are ready (no earlier unresolved store)}
\PYGdefault{c+cm}{ *}
\PYGdefault{c+cm}{ * loads are serviced by:}
\PYGdefault{c+cm}{ *   1) previous store at same address in LSQ (hit latency), or}
\PYGdefault{c+cm}{ *   2) data cache (hit latency + miss latency)}
\PYGdefault{c+cm}{ *}
\PYGdefault{c+cm}{ * stores may execute when:}
\PYGdefault{c+cm}{ *   1) register operands are ready}
\PYGdefault{c+cm}{ *}
\PYGdefault{c+cm}{ * stores are serviced by:}
\PYGdefault{c+cm}{ *   1) depositing store value into the load/store queue}
\PYGdefault{c+cm}{ *   2) writing store value to the store buffer (plus tag check) at commit}
\PYGdefault{c+cm}{ *   3) writing store buffer entry to data cache when cache is free}
\PYGdefault{c+cm}{ *}
\PYGdefault{c+cm}{ * NOTE: the load/store queue can bypass a store value to a load in the same}
\PYGdefault{c+cm}{ *   cycle the store executes (using a bypass network), thus stores complete}
\PYGdefault{c+cm}{ *   in effective zero time after their effective address is known}
\PYGdefault{c+cm}{ */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{LSQ}\PYGdefault{p}{;}         \PYGdefault{c+cm}{/* load/store queue */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{,} \PYGdefault{n}{LSQ\PYGdefaultZus{}tail}\PYGdefault{p}{;}          \PYGdefault{c+cm}{/* LSQ head and tail pointers */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{LSQ\PYGdefaultZus{}num}\PYGdefault{p}{;}                     \PYGdefault{c+cm}{/* num entries currently in LSQ */}

\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * input dependencies for stores in the LSQ:}
\PYGdefault{c+cm}{ *   idep \PYGdefaultZsh{}0 \PYGdefaultZhy{} operand input (value that is store\PYGdefaultZsq{}d)}
\PYGdefault{c+cm}{ *   idep \PYGdefaultZsh{}1 \PYGdefaultZhy{} effective address input (address of store operation)}
\PYGdefault{c+cm}{ */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define STORE\PYGdefaultZus{}OP\PYGdefaultZus{}INDEX                  0}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define STORE\PYGdefaultZus{}ADDR\PYGdefaultZus{}INDEX                1}

\PYGdefault{c+cp}{\PYGdefaultZsh{}define STORE\PYGdefaultZus{}OP\PYGdefaultZus{}READY(RS)              ((RS)\PYGdefaultZhy{}\PYGdefaultZgt{}idep\PYGdefaultZus{}ready[STORE\PYGdefaultZus{}OP\PYGdefaultZus{}INDEX])}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define STORE\PYGdefaultZus{}ADDR\PYGdefaultZus{}READY(RS)            ((RS)\PYGdefaultZhy{}\PYGdefaultZgt{}idep\PYGdefaultZus{}ready[STORE\PYGdefaultZus{}ADDR\PYGdefaultZus{}INDEX])}

\PYGdefault{c+cm}{/* allocate and initialize the load/store queue (LSQ) */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{lsq\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{n}{LSQ} \PYGdefault{o}{=} \PYGdefault{n}{calloc}\PYGdefault{p}{(}\PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{p}{,} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station}\PYGdefault{p}{));}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{LSQ}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}out of virtual memory\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{n}{LSQ\PYGdefaultZus{}num} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{n}{LSQ\PYGdefaultZus{}head} \PYGdefault{o}{=} \PYGdefault{n}{LSQ\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{n}{LSQ\PYGdefaultZus{}count} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{n}{LSQ\PYGdefaultZus{}fcount} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* dump the contents of the RUU */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{lsq\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{)}				\PYGdefault{c+cm}{/* output stream */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{num}\PYGdefault{p}{,} \PYGdefault{n}{head}\PYGdefault{p}{;}
  \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{stream}\PYGdefault{p}{)}
    \PYGdefault{n}{stream} \PYGdefault{o}{=} \PYGdefault{n}{stderr}\PYGdefault{p}{;}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}** LSQ state **}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}LSQ\PYGdefaultZus{}head: \PYGdefaultZpc{}d, LSQ\PYGdefaultZus{}tail: \PYGdefaultZpc{}d}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{,} \PYGdefault{n}{LSQ\PYGdefaultZus{}tail}\PYGdefault{p}{);}
  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}LSQ\PYGdefaultZus{}num: \PYGdefaultZpc{}d}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{LSQ\PYGdefaultZus{}num}\PYGdefault{p}{);}

  \PYGdefault{n}{num} \PYGdefault{o}{=} \PYGdefault{n}{LSQ\PYGdefaultZus{}num}\PYGdefault{p}{;}
  \PYGdefault{n}{head} \PYGdefault{o}{=} \PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{;}
  \PYGdefault{k}{while} \PYGdefault{p}{(}\PYGdefault{n}{num}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{n}{rs} \PYGdefault{o}{=} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{head}\PYGdefault{p}{];}
      \PYGdefault{n}{ruu\PYGdefaultZus{}dumpent}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{n}{rs} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{LSQ}\PYGdefault{p}{,} \PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* header */}\PYGdefault{n}{TRUE}\PYGdefault{p}{);}
      \PYGdefault{n}{head} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{head} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{p}{;}
      \PYGdefault{n}{num}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZhy{}}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * RS\PYGdefaultZus{}LINK defs and decls}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* a reservation station link: this structure links elements of a RUU}
\PYGdefault{c+cm}{   reservation station list; used for ready instruction queue, event queue, and}
\PYGdefault{c+cm}{   output dependency lists; each RS\PYGdefaultZus{}LINK node contains a pointer to the RUU}
\PYGdefault{c+cm}{   entry it references along with an instance tag, the RS\PYGdefaultZus{}LINK is only valid if}
\PYGdefault{c+cm}{   the instruction instance tag matches the instruction RUU entry instance tag;}
\PYGdefault{c+cm}{   this strategy allows entries in the RUU can be squashed and reused without}
\PYGdefault{c+cm}{   updating the lists that point to it, which significantly improves the}
\PYGdefault{c+cm}{   performance of (all to frequent) squash events */}
\PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{next}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* next entry in list */}
  \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* referenced RUU resv station */}
  \PYGdefault{n}{INST\PYGdefaultZus{}TAG\PYGdefaultZus{}TYPE} \PYGdefault{n}{tag}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* inst instance sequence number */}
  \PYGdefault{k}{union} \PYGdefault{p}{\PYGdefaultZob{}}
    \PYGdefault{k+kt}{tick\PYGdefaultZus{}t} \PYGdefault{n}{when}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* time stamp of entry (for eventq) */}
    \PYGdefault{n}{INST\PYGdefaultZus{}SEQ\PYGdefaultZus{}TYPE} \PYGdefault{n}{seq}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* inst sequence */}
    \PYGdefault{k+kt}{int} \PYGdefault{n}{opnum}\PYGdefault{p}{;}				\PYGdefault{c+cm}{/* input/output operand number */}
  \PYGdefault{p}{\PYGdefaultZcb{}} \PYGdefault{n}{x}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{};}

\PYGdefault{c+cm}{/* RS link free list, grab RS\PYGdefaultZus{}LINKs from here, when needed */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{rslink\PYGdefaultZus{}free\PYGdefaultZus{}list}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* NULL value for an RS link */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define RSLINK\PYGdefaultZus{}NULL\PYGdefaultZus{}DATA		\PYGdefaultZob{} NULL, NULL, 0 \PYGdefaultZcb{}}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{n}{RSLINK\PYGdefaultZus{}NULL} \PYGdefault{o}{=} \PYGdefault{n}{RSLINK\PYGdefaultZus{}NULL\PYGdefaultZus{}DATA}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* create and initialize an RS link */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define RSLINK\PYGdefaultZus{}INIT(RSL, RS)						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  ((RSL).next = NULL, (RSL).rs = (RS), (RSL).tag = (RS)\PYGdefaultZhy{}\PYGdefaultZgt{}tag)}

\PYGdefault{c+cm}{/* non\PYGdefaultZhy{}zero if RS link is NULL */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define RSLINK\PYGdefaultZus{}IS\PYGdefaultZus{}NULL(LINK)            ((LINK)\PYGdefaultZhy{}\PYGdefaultZgt{}rs == NULL)}

\PYGdefault{c+cm}{/* non\PYGdefaultZhy{}zero if RS link is to a valid (non\PYGdefaultZhy{}squashed) entry */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define RSLINK\PYGdefaultZus{}VALID(LINK)              ((LINK)\PYGdefaultZhy{}\PYGdefaultZgt{}tag == (LINK)\PYGdefaultZhy{}\PYGdefaultZgt{}rs\PYGdefaultZhy{}\PYGdefaultZgt{}tag)}

\PYGdefault{c+cm}{/* extra RUU reservation station pointer */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define RSLINK\PYGdefaultZus{}RS(LINK)                 ((LINK)\PYGdefaultZhy{}\PYGdefaultZgt{}rs)}

\PYGdefault{c+cm}{/* get a new RS link record */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define RSLINK\PYGdefaultZus{}NEW(DST, RS)						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  \PYGdefaultZob{} struct RS\PYGdefaultZus{}link *n\PYGdefaultZus{}link;						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{    if (!rslink\PYGdefaultZus{}free\PYGdefaultZus{}list)						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{      panic(\PYGdefaultZdq{}out of rs links\PYGdefaultZdq{});						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{    n\PYGdefaultZus{}link = rslink\PYGdefaultZus{}free\PYGdefaultZus{}list;						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{    rslink\PYGdefaultZus{}free\PYGdefaultZus{}list = rslink\PYGdefaultZus{}free\PYGdefaultZus{}list\PYGdefaultZhy{}\PYGdefaultZgt{}next;				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{    n\PYGdefaultZus{}link\PYGdefaultZhy{}\PYGdefaultZgt{}next = NULL;						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{    n\PYGdefaultZus{}link\PYGdefaultZhy{}\PYGdefaultZgt{}rs = (RS); n\PYGdefaultZus{}link\PYGdefaultZhy{}\PYGdefaultZgt{}tag = n\PYGdefaultZus{}link\PYGdefaultZhy{}\PYGdefaultZgt{}rs\PYGdefaultZhy{}\PYGdefaultZgt{}tag;			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{    (DST) = n\PYGdefaultZus{}link;							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  \PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* free an RS link record */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define RSLINK\PYGdefaultZus{}FREE(LINK)						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  \PYGdefaultZob{}  struct RS\PYGdefaultZus{}link *f\PYGdefaultZus{}link = (LINK);					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{     f\PYGdefaultZus{}link\PYGdefaultZhy{}\PYGdefaultZgt{}rs = NULL; f\PYGdefaultZus{}link\PYGdefaultZhy{}\PYGdefaultZgt{}tag = 0;				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{     f\PYGdefaultZus{}link\PYGdefaultZhy{}\PYGdefaultZgt{}next = rslink\PYGdefaultZus{}free\PYGdefaultZus{}list;					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{     rslink\PYGdefaultZus{}free\PYGdefaultZus{}list = f\PYGdefaultZus{}link;						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  \PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* FIXME: could this be faster!!! */}
\PYGdefault{c+cm}{/* free an RS link list */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define RSLINK\PYGdefaultZus{}FREE\PYGdefaultZus{}LIST(LINK)						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  \PYGdefaultZob{}  struct RS\PYGdefaultZus{}link *fl\PYGdefaultZus{}link, *fl\PYGdefaultZus{}link\PYGdefaultZus{}next;				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{     for (fl\PYGdefaultZus{}link=(LINK); fl\PYGdefaultZus{}link; fl\PYGdefaultZus{}link=fl\PYGdefaultZus{}link\PYGdefaultZus{}next)		\PYGdefaultZbs{}}
\PYGdefault{c+cp}{       \PYGdefaultZob{}								\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	 fl\PYGdefaultZus{}link\PYGdefaultZus{}next = fl\PYGdefaultZus{}link\PYGdefaultZhy{}\PYGdefaultZgt{}next;					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	 RSLINK\PYGdefaultZus{}FREE(fl\PYGdefaultZus{}link);						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{       \PYGdefaultZcb{}								\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  \PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* initialize the free RS\PYGdefaultZus{}LINK pool */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{rslink\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{int} \PYGdefault{n}{nlinks}\PYGdefault{p}{)}			\PYGdefault{c+cm}{/* total number of RS\PYGdefaultZus{}LINK available */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{;}
  \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{link}\PYGdefault{p}{;}

  \PYGdefault{n}{rslink\PYGdefaultZus{}free\PYGdefaultZus{}list} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{nlinks}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{n}{link} \PYGdefault{o}{=} \PYGdefault{n}{calloc}\PYGdefault{p}{(}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link}\PYGdefault{p}{));}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{link}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}out of virtual memory\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{n}{link}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next} \PYGdefault{o}{=} \PYGdefault{n}{rslink\PYGdefaultZus{}free\PYGdefaultZus{}list}\PYGdefault{p}{;}
      \PYGdefault{n}{rslink\PYGdefaultZus{}free\PYGdefaultZus{}list} \PYGdefault{o}{=} \PYGdefault{n}{link}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* service all functional unit release events, this function is called}
\PYGdefault{c+cm}{   once per cycle, and it used to step the BUSY timers attached to each}
\PYGdefault{c+cm}{   functional unit in the function unit resource pool, as long as a functional}
\PYGdefault{c+cm}{   unit\PYGdefaultZsq{}s BUSY count is \PYGdefaultZgt{} 0, it cannot be issued an operation */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{ruu\PYGdefaultZus{}release\PYGdefaultZus{}fu}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* walk all resource units, decrement busy counts by one */}
  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{fu\PYGdefaultZus{}pool}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{num\PYGdefaultZus{}resources}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* resource is released when BUSY hits zero */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{fu\PYGdefaultZus{}pool}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{resources}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{].}\PYGdefault{n}{busy} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
	\PYGdefault{n}{fu\PYGdefaultZus{}pool}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{resources}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{].}\PYGdefault{n}{busy}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZhy{}}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * the execution unit event queue implementation follows, the event queue}
\PYGdefault{c+cm}{ * indicates which instruction will complete next, the writeback handler}
\PYGdefault{c+cm}{ * drains this queue}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* pending event queue, sorted from soonest to latest event (in time), NOTE:}
\PYGdefault{c+cm}{   RS\PYGdefaultZus{}LINK nodes are used for the event queue list so that it need not be}
\PYGdefault{c+cm}{   updated during squash events */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{event\PYGdefaultZus{}queue}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* initialize the event queue structures */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{eventq\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{n}{event\PYGdefaultZus{}queue} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* dump the contents of the event queue */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{eventq\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{)}			\PYGdefault{c+cm}{/* output stream */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{ev}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{stream}\PYGdefault{p}{)}
    \PYGdefault{n}{stream} \PYGdefault{o}{=} \PYGdefault{n}{stderr}\PYGdefault{p}{;}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}** event queue state **}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{ev} \PYGdefault{o}{=} \PYGdefault{n}{event\PYGdefaultZus{}queue}\PYGdefault{p}{;} \PYGdefault{n}{ev} \PYGdefault{o}{!=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;} \PYGdefault{n}{ev} \PYGdefault{o}{=} \PYGdefault{n}{ev}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* is event still valid? */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{RSLINK\PYGdefaultZus{}VALID}\PYGdefault{p}{(}\PYGdefault{n}{ev}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs} \PYGdefault{o}{=} \PYGdefault{n}{RSLINK\PYGdefaultZus{}RS}\PYGdefault{p}{(}\PYGdefault{n}{ev}\PYGdefault{p}{);}

	  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}idx: \PYGdefaultZpc{}2d: @ \PYGdefaultZpc{}.0f}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
		  \PYGdefault{p}{(}\PYGdefault{k+kt}{int}\PYGdefault{p}{)(}\PYGdefault{n}{rs} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ} \PYGdefault{o}{?} \PYGdefault{n+nl}{LSQ} \PYGdefault{p}{:} \PYGdefault{n}{RUU}\PYGdefault{p}{)),} \PYGdefault{p}{(}\PYGdefault{k+kt}{double}\PYGdefault{p}{)}\PYGdefault{n}{ev}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{x}\PYGdefault{p}{.}\PYGdefault{n}{when}\PYGdefault{p}{);}
	  \PYGdefault{n}{ruu\PYGdefaultZus{}dumpent}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{n}{rs} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ} \PYGdefault{o}{?} \PYGdefault{n+nl}{LSQ} \PYGdefault{p}{:} \PYGdefault{n}{RUU}\PYGdefault{p}{),}
		      \PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* !header */}\PYGdefault{n}{FALSE}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* insert an event for RS into the event queue, event queue is sorted from}
\PYGdefault{c+cm}{   earliest to latest event, event and associated side\PYGdefaultZhy{}effects will be}
\PYGdefault{c+cm}{   apparent at the start of cycle WHEN */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{eventq\PYGdefaultZus{}queue\PYGdefaultZus{}event}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{k+kt}{tick\PYGdefaultZus{}t} \PYGdefault{n}{when}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{prev}\PYGdefault{p}{,} \PYGdefault{o}{*}\PYGdefault{n}{ev}\PYGdefault{p}{,} \PYGdefault{o}{*}\PYGdefault{n}{new\PYGdefaultZus{}ev}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{completed}\PYGdefault{p}{)}
    \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}event completed\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{when} \PYGdefault{o}{\PYGdefaultZlt{}=} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{)}
    \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}event occurred in the past\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* get a free event record */}
  \PYGdefault{n}{RSLINK\PYGdefaultZus{}NEW}\PYGdefault{p}{(}\PYGdefault{n}{new\PYGdefaultZus{}ev}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{p}{);}
  \PYGdefault{n}{new\PYGdefaultZus{}ev}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{x}\PYGdefault{p}{.}\PYGdefault{n}{when} \PYGdefault{o}{=} \PYGdefault{n}{when}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* locate insertion point */}
  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{prev}\PYGdefault{o}{=}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{n}{ev}\PYGdefault{o}{=}\PYGdefault{n}{event\PYGdefaultZus{}queue}\PYGdefault{p}{;}
       \PYGdefault{n}{ev} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{ev}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{x}\PYGdefault{p}{.}\PYGdefault{n}{when} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{when}\PYGdefault{p}{;}
       \PYGdefault{n}{prev}\PYGdefault{o}{=}\PYGdefault{n}{ev}\PYGdefault{p}{,} \PYGdefault{n}{ev}\PYGdefault{o}{=}\PYGdefault{n}{ev}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{);}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{prev}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* insert middle or end */}
      \PYGdefault{n}{new\PYGdefaultZus{}ev}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next} \PYGdefault{o}{=} \PYGdefault{n}{prev}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{;}
      \PYGdefault{n}{prev}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next} \PYGdefault{o}{=} \PYGdefault{n}{new\PYGdefaultZus{}ev}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* insert at beginning */}
      \PYGdefault{n}{new\PYGdefaultZus{}ev}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next} \PYGdefault{o}{=} \PYGdefault{n}{event\PYGdefaultZus{}queue}\PYGdefault{p}{;}
      \PYGdefault{n}{event\PYGdefaultZus{}queue} \PYGdefault{o}{=} \PYGdefault{n}{new\PYGdefaultZus{}ev}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* return the next event that has already occurred, returns NULL when no}
\PYGdefault{c+cm}{   remaining events or all remaining events are in the future */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}
\PYGdefault{n+nf}{eventq\PYGdefaultZus{}next\PYGdefaultZus{}event}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{ev}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{event\PYGdefaultZus{}queue} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{event\PYGdefaultZus{}queue}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{x}\PYGdefault{p}{.}\PYGdefault{n}{when} \PYGdefault{o}{\PYGdefaultZlt{}=} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* unlink and return first event on priority list */}
      \PYGdefault{n}{ev} \PYGdefault{o}{=} \PYGdefault{n}{event\PYGdefaultZus{}queue}\PYGdefault{p}{;}
      \PYGdefault{n}{event\PYGdefaultZus{}queue} \PYGdefault{o}{=} \PYGdefault{n}{event\PYGdefaultZus{}queue}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* event still valid? */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{RSLINK\PYGdefaultZus{}VALID}\PYGdefault{p}{(}\PYGdefault{n}{ev}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs} \PYGdefault{o}{=} \PYGdefault{n}{RSLINK\PYGdefaultZus{}RS}\PYGdefault{p}{(}\PYGdefault{n}{ev}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* reclaim event record */}
	  \PYGdefault{n}{RSLINK\PYGdefaultZus{}FREE}\PYGdefault{p}{(}\PYGdefault{n}{ev}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* event is valid, return resv station */}
	  \PYGdefault{k}{return} \PYGdefault{n}{rs}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{else}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* reclaim event record */}
	  \PYGdefault{n}{RSLINK\PYGdefaultZus{}FREE}\PYGdefault{p}{(}\PYGdefault{n}{ev}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* receiving inst was squashed, return next event */}
	  \PYGdefault{k}{return} \PYGdefault{n}{eventq\PYGdefaultZus{}next\PYGdefaultZus{}event}\PYGdefault{p}{();}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* no event or no event is ready */}
      \PYGdefault{k}{return} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * the ready instruction queue implementation follows, the ready instruction}
\PYGdefault{c+cm}{ * queue indicates which instruction have all of there *register* dependencies}
\PYGdefault{c+cm}{ * satisfied, instruction will issue when 1) all memory dependencies for}
\PYGdefault{c+cm}{ * the instruction have been satisfied (see lsq\PYGdefaultZus{}refresh() for details on how}
\PYGdefault{c+cm}{ * this is accomplished) and 2) resources are available; ready queue is fully}
\PYGdefault{c+cm}{ * constructed each cycle before any operation is issued from it \PYGdefaultZhy{}\PYGdefaultZhy{} this}
\PYGdefault{c+cm}{ * ensures that instruction issue priorities are properly observed; NOTE:}
\PYGdefault{c+cm}{ * RS\PYGdefaultZus{}LINK nodes are used for the event queue list so that it need not be}
\PYGdefault{c+cm}{ * updated during squash events}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* the ready instruction queue */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{ready\PYGdefaultZus{}queue}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* initialize the event queue structures */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{readyq\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{n}{ready\PYGdefaultZus{}queue} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* dump the contents of the ready queue */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{readyq\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{)}			\PYGdefault{c+cm}{/* output stream */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{link}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{stream}\PYGdefault{p}{)}
    \PYGdefault{n}{stream} \PYGdefault{o}{=} \PYGdefault{n}{stderr}\PYGdefault{p}{;}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}** ready queue state **}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{link} \PYGdefault{o}{=} \PYGdefault{n}{ready\PYGdefaultZus{}queue}\PYGdefault{p}{;} \PYGdefault{n}{link} \PYGdefault{o}{!=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;} \PYGdefault{n}{link} \PYGdefault{o}{=} \PYGdefault{n}{link}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* is entry still valid? */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{RSLINK\PYGdefaultZus{}VALID}\PYGdefault{p}{(}\PYGdefault{n}{link}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs} \PYGdefault{o}{=} \PYGdefault{n}{RSLINK\PYGdefaultZus{}RS}\PYGdefault{p}{(}\PYGdefault{n}{link}\PYGdefault{p}{);}

	  \PYGdefault{n}{ruu\PYGdefaultZus{}dumpent}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{n}{rs} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ} \PYGdefault{o}{?} \PYGdefault{n+nl}{LSQ} \PYGdefault{p}{:} \PYGdefault{n}{RUU}\PYGdefault{p}{),}
		      \PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* header */}\PYGdefault{n}{TRUE}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* insert ready node into the ready list using ready instruction scheduling}
\PYGdefault{c+cm}{   policy; currently the following scheduling policy is enforced:}

\PYGdefault{c+cm}{     memory and long latency operands, and branch instructions first}

\PYGdefault{c+cm}{   then}

\PYGdefault{c+cm}{     all other instructions, oldest instructions first}

\PYGdefault{c+cm}{  this policy works well because branches pass through the machine quicker}
\PYGdefault{c+cm}{  which works to reduce branch misprediction latencies, and very long latency}
\PYGdefault{c+cm}{  instructions (such loads and multiplies) get priority since they are very}
\PYGdefault{c+cm}{  likely on the program\PYGdefaultZsq{}s critical path */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{readyq\PYGdefaultZus{}enqueue}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs}\PYGdefault{p}{)}		\PYGdefault{c+cm}{/* RS to enqueue */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{prev}\PYGdefault{p}{,} \PYGdefault{o}{*}\PYGdefault{n}{node}\PYGdefault{p}{,} \PYGdefault{o}{*}\PYGdefault{n}{new\PYGdefaultZus{}node}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* node is now queued */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{queued}\PYGdefault{p}{)}
    \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}node is already queued\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{queued} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* get a free ready list node */}
  \PYGdefault{n}{RSLINK\PYGdefaultZus{}NEW}\PYGdefault{p}{(}\PYGdefault{n}{new\PYGdefaultZus{}node}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{p}{);}
  \PYGdefault{n}{new\PYGdefaultZus{}node}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{x}\PYGdefault{p}{.}\PYGdefault{n}{seq} \PYGdefault{o}{=} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{seq}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* locate insertion point */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ} \PYGdefault{o}{||} \PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}LONGLAT}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}CTRL}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* insert loads/stores and long latency ops at the head of the queue */}
      \PYGdefault{n}{prev} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
      \PYGdefault{n}{node} \PYGdefault{o}{=} \PYGdefault{n}{ready\PYGdefaultZus{}queue}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* otherwise insert in program order (earliest seq first) */}
      \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{prev}\PYGdefault{o}{=}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{n}{node}\PYGdefault{o}{=}\PYGdefault{n}{ready\PYGdefaultZus{}queue}\PYGdefault{p}{;}
	   \PYGdefault{n}{node} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{node}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{x}\PYGdefault{p}{.}\PYGdefault{n}{seq} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{seq}\PYGdefault{p}{;}
	   \PYGdefault{n}{prev}\PYGdefault{o}{=}\PYGdefault{n}{node}\PYGdefault{p}{,} \PYGdefault{n}{node}\PYGdefault{o}{=}\PYGdefault{n}{node}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{prev}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* insert middle or end */}
      \PYGdefault{n}{new\PYGdefaultZus{}node}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next} \PYGdefault{o}{=} \PYGdefault{n}{prev}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{;}
      \PYGdefault{n}{prev}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next} \PYGdefault{o}{=} \PYGdefault{n}{new\PYGdefaultZus{}node}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* insert at beginning */}
      \PYGdefault{n}{new\PYGdefaultZus{}node}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next} \PYGdefault{o}{=} \PYGdefault{n}{ready\PYGdefaultZus{}queue}\PYGdefault{p}{;}
      \PYGdefault{n}{ready\PYGdefaultZus{}queue} \PYGdefault{o}{=} \PYGdefault{n}{new\PYGdefaultZus{}node}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * the create vector maps a logical register to a creator in the RUU (and}
\PYGdefault{c+cm}{ * specific output operand) or the architected register file (if RS\PYGdefaultZus{}link}
\PYGdefault{c+cm}{ * is NULL)}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* an entry in the create vector */}
\PYGdefault{k}{struct} \PYGdefault{n}{CV\PYGdefaultZus{}link} \PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs}\PYGdefault{p}{;}               \PYGdefault{c+cm}{/* creator\PYGdefaultZsq{}s reservation station */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{odep\PYGdefaultZus{}num}\PYGdefault{p}{;}                         \PYGdefault{c+cm}{/* specific output operand */}
\PYGdefault{p}{\PYGdefaultZcb{};}

\PYGdefault{c+cm}{/* a NULL create vector entry */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{CV\PYGdefaultZus{}link} \PYGdefault{n}{CVLINK\PYGdefaultZus{}NULL} \PYGdefault{o}{=} \PYGdefault{p}{\PYGdefaultZob{}} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0} \PYGdefault{p}{\PYGdefaultZcb{};}

\PYGdefault{c+cm}{/* get a new create vector link */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define CVLINK\PYGdefaultZus{}INIT(CV, RS,ONUM)	((CV).rs = (RS), (CV).odep\PYGdefaultZus{}num = (ONUM))}

\PYGdefault{c+cm}{/* size of the create vector (one entry per architected register) */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define CV\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ              (BITMAP\PYGdefaultZus{}SIZE(MD\PYGdefaultZus{}TOTAL\PYGdefaultZus{}REGS))}

\PYGdefault{c+cm}{/* the create vector, NOTE: speculative copy on write storage provided}
\PYGdefault{c+cm}{   for fast recovery during wrong path execute (see tracer\PYGdefaultZus{}recover() for}
\PYGdefault{c+cm}{   details on this process */}
\PYGdefault{k}{static} \PYGdefault{n+nf}{BITMAP\PYGdefaultZus{}TYPE}\PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}TOTAL\PYGdefaultZus{}REGS}\PYGdefault{p}{,} \PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}cv}\PYGdefault{p}{);}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{CV\PYGdefaultZus{}link} \PYGdefault{n}{create\PYGdefaultZus{}vector}\PYGdefault{p}{[}\PYGdefault{n}{MD\PYGdefaultZus{}TOTAL\PYGdefaultZus{}REGS}\PYGdefault{p}{];}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{CV\PYGdefaultZus{}link} \PYGdefault{n}{spec\PYGdefaultZus{}create\PYGdefaultZus{}vector}\PYGdefault{p}{[}\PYGdefault{n}{MD\PYGdefaultZus{}TOTAL\PYGdefaultZus{}REGS}\PYGdefault{p}{];}

\PYGdefault{c+cm}{/* these arrays shadow the create vector an indicate when a register was}
\PYGdefault{c+cm}{   last created */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{tick\PYGdefaultZus{}t} \PYGdefault{n}{create\PYGdefaultZus{}vector\PYGdefaultZus{}rt}\PYGdefault{p}{[}\PYGdefault{n}{MD\PYGdefaultZus{}TOTAL\PYGdefaultZus{}REGS}\PYGdefault{p}{];}
\PYGdefault{k}{static} \PYGdefault{k+kt}{tick\PYGdefaultZus{}t} \PYGdefault{n}{spec\PYGdefaultZus{}create\PYGdefaultZus{}vector\PYGdefaultZus{}rt}\PYGdefault{p}{[}\PYGdefault{n}{MD\PYGdefaultZus{}TOTAL\PYGdefaultZus{}REGS}\PYGdefault{p}{];}

\PYGdefault{c+cm}{/* read a create vector entry */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define CREATE\PYGdefaultZus{}VECTOR(N)        (BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}cv, CV\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, (N))\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}create\PYGdefaultZus{}vector[N]                \PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : create\PYGdefaultZus{}vector[N])}

\PYGdefault{c+cm}{/* read a create vector timestamp entry */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define CREATE\PYGdefaultZus{}VECTOR\PYGdefaultZus{}RT(N)     (BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}cv, CV\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, (N))\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}create\PYGdefaultZus{}vector\PYGdefaultZus{}rt[N]             \PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : create\PYGdefaultZus{}vector\PYGdefaultZus{}rt[N])}

\PYGdefault{c+cm}{/* set a create vector entry */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}CREATE\PYGdefaultZus{}VECTOR(N, L) (spec\PYGdefaultZus{}mode                              \PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? (BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}cv, CV\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, (N)),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}create\PYGdefaultZus{}vector[N] = (L))        \PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (create\PYGdefaultZus{}vector[N] = (L)))}

\PYGdefault{c+cm}{/* initialize the create vector */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{cv\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* initially all registers are valid in the architected register file,}
\PYGdefault{c+cm}{     i.e., the create vector entry is CVLINK\PYGdefaultZus{}NULL */}
  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{MD\PYGdefaultZus{}TOTAL\PYGdefaultZus{}REGS}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{n}{create\PYGdefaultZus{}vector}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{CVLINK\PYGdefaultZus{}NULL}\PYGdefault{p}{;}
      \PYGdefault{n}{create\PYGdefaultZus{}vector\PYGdefaultZus{}rt}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
      \PYGdefault{n}{spec\PYGdefaultZus{}create\PYGdefaultZus{}vector}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{CVLINK\PYGdefaultZus{}NULL}\PYGdefault{p}{;}
      \PYGdefault{n}{spec\PYGdefaultZus{}create\PYGdefaultZus{}vector\PYGdefaultZus{}rt}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* all create vector entries are non\PYGdefaultZhy{}speculative */}
  \PYGdefault{n}{BITMAP\PYGdefaultZus{}CLEAR\PYGdefaultZus{}MAP}\PYGdefault{p}{(}\PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}cv}\PYGdefault{p}{,} \PYGdefault{n}{CV\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ}\PYGdefault{p}{);}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* dump the contents of the create vector */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{cv\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{)}				\PYGdefault{c+cm}{/* output stream */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{;}
  \PYGdefault{k}{struct} \PYGdefault{n}{CV\PYGdefaultZus{}link} \PYGdefault{n}{ent}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{stream}\PYGdefault{p}{)}
    \PYGdefault{n}{stream} \PYGdefault{o}{=} \PYGdefault{n}{stderr}\PYGdefault{p}{;}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}** create vector state **}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{MD\PYGdefaultZus{}TOTAL\PYGdefaultZus{}REGS}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{n}{ent} \PYGdefault{o}{=} \PYGdefault{n}{CREATE\PYGdefaultZus{}VECTOR}\PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{p}{);}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{ent}\PYGdefault{p}{.}\PYGdefault{n}{rs}\PYGdefault{p}{)}
	\PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}[cv\PYGdefaultZpc{}02d]: from architected reg file}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{i}\PYGdefault{p}{);}
      \PYGdefault{k}{else}
	\PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}[cv\PYGdefaultZpc{}02d]: from \PYGdefaultZpc{}s, idx: \PYGdefaultZpc{}d}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
		\PYGdefault{n}{i}\PYGdefault{p}{,} \PYGdefault{p}{(}\PYGdefault{n}{ent}\PYGdefault{p}{.}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ} \PYGdefault{o}{?} \PYGdefault{l+s}{\PYGdefaultZdq{}LSQ\PYGdefaultZdq{}} \PYGdefault{o}{:} \PYGdefault{l+s}{\PYGdefaultZdq{}RUU\PYGdefaultZdq{}}\PYGdefault{p}{),}
		\PYGdefault{p}{(}\PYGdefault{k+kt}{int}\PYGdefault{p}{)(}\PYGdefault{n}{ent}\PYGdefault{p}{.}\PYGdefault{n}{rs} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{p}{(}\PYGdefault{n}{ent}\PYGdefault{p}{.}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ} \PYGdefault{o}{?} \PYGdefault{n+nl}{LSQ} \PYGdefault{p}{:} \PYGdefault{n}{RUU}\PYGdefault{p}{)));}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ *  RUU\PYGdefaultZus{}COMMIT() \PYGdefaultZhy{} instruction retirement pipeline stage}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* this function commits the results of the oldest completed entries from the}
\PYGdefault{c+cm}{   RUU and LSQ to the architected reg file, stores in the LSQ will commit}
\PYGdefault{c+cm}{   their store data to the data cache at this point as well */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{ruu\PYGdefaultZus{}commit}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{,} \PYGdefault{n}{lat}\PYGdefault{p}{,} \PYGdefault{n}{events}\PYGdefault{p}{,} \PYGdefault{n}{committed} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{k}{static} \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{sim\PYGdefaultZus{}ret\PYGdefaultZus{}insn} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* all values must be retired to the architected reg file in program order */}
  \PYGdefault{k}{while} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}num} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{l+m+mi}{0} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{committed} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{ruu\PYGdefaultZus{}commit\PYGdefaultZus{}width}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs} \PYGdefault{o}{=} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{p}{(}\PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{]);}

      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{completed}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* at least RUU entry must be complete */}
	  \PYGdefault{k}{break}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* default commit events */}
      \PYGdefault{n}{events} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* load/stores must retire load/store queue entry as well */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{ea\PYGdefaultZus{}comp}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* load/store, retire head of LSQ as well */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{LSQ\PYGdefaultZus{}num} \PYGdefault{o}{\PYGdefaultZlt{}=} \PYGdefault{l+m+mi}{0} \PYGdefault{o}{||} \PYGdefault{o}{!}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{in\PYGdefaultZus{}LSQ}\PYGdefault{p}{)}
	    \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}RUU out of sync with LSQ\PYGdefaultZdq{}}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* load/store operation must be complete */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{completed}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* load/store operation is not yet complete */}
	      \PYGdefault{k}{break}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}

	  \PYGdefault{k}{if} \PYGdefault{p}{((}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{))}
	      \PYGdefault{o}{==} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{))}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{k}{struct} \PYGdefault{n}{res\PYGdefaultZus{}template} \PYGdefault{o}{*}\PYGdefault{n}{fu}\PYGdefault{p}{;}


	      \PYGdefault{c+cm}{/* stores must retire their store value to the cache at commit,}
\PYGdefault{c+cm}{		 try to get a store port (functional unit allocation) */}
	      \PYGdefault{n}{fu} \PYGdefault{o}{=} \PYGdefault{n}{res\PYGdefaultZus{}get}\PYGdefault{p}{(}\PYGdefault{n}{fu\PYGdefaultZus{}pool}\PYGdefault{p}{,} \PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FUCLASS}\PYGdefault{p}{(}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{op}\PYGdefault{p}{));}
	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{fu}\PYGdefault{p}{)}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{c+cm}{/* reserve the functional unit */}
		  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{fu}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{master}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{busy}\PYGdefault{p}{)}
		    \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}functional unit already in use\PYGdefaultZdq{}}\PYGdefault{p}{);}

		  \PYGdefault{c+cm}{/* schedule functional unit release event */}
		  \PYGdefault{n}{fu}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{master}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{busy} \PYGdefault{o}{=} \PYGdefault{n}{fu}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{issuelat}\PYGdefault{p}{;}

		  \PYGdefault{c+cm}{/* go to the data cache */}
		  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl1}\PYGdefault{p}{)}
		    \PYGdefault{p}{\PYGdefaultZob{}}
  		      \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} D\PYGdefaultZhy{}cache access */}
		      \PYGdefault{n}{dcache\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}

              \PYGdefault{c+cm}{/* commit store value to D\PYGdefaultZhy{}cache */}
		      \PYGdefault{n}{lat} \PYGdefault{o}{=}
			\PYGdefault{n}{cache\PYGdefaultZus{}access}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl1}\PYGdefault{p}{,} \PYGdefault{n}{Write}\PYGdefault{p}{,} \PYGdefault{p}{(}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{addr}\PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZti{}}\PYGdefault{l+m+mi}{3}\PYGdefault{p}{),}
				     \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{4}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
		      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{lat} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{n}{cache\PYGdefaultZus{}dl1\PYGdefaultZus{}lat}\PYGdefault{p}{)}
			\PYGdefault{n}{events} \PYGdefault{o}{|=} \PYGdefault{n}{PEV\PYGdefaultZus{}CACHEMISS}\PYGdefault{p}{;}
		    \PYGdefault{p}{\PYGdefaultZcb{}}

		  \PYGdefault{c+cm}{/* all loads and stores must to access D\PYGdefaultZhy{}TLB */}
		  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{dtlb}\PYGdefault{p}{)}
		    \PYGdefault{p}{\PYGdefaultZob{}}
		      \PYGdefault{c+cm}{/* access the D\PYGdefaultZhy{}TLB */}
		      \PYGdefault{n}{lat} \PYGdefault{o}{=}
			\PYGdefault{n}{cache\PYGdefaultZus{}access}\PYGdefault{p}{(}\PYGdefault{n}{dtlb}\PYGdefault{p}{,} \PYGdefault{n}{Read}\PYGdefault{p}{,} \PYGdefault{p}{(}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{addr} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{o}{\PYGdefaultZti{}}\PYGdefault{l+m+mi}{3}\PYGdefault{p}{),}
				     \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{4}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
		      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{lat} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
			\PYGdefault{n}{events} \PYGdefault{o}{|=} \PYGdefault{n}{PEV\PYGdefaultZus{}TLBMISS}\PYGdefault{p}{;}
		    \PYGdefault{p}{\PYGdefaultZcb{}}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	      \PYGdefault{k}{else}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{c+cm}{/* no store ports left, cannot continue to commit insts */}
		  \PYGdefault{k}{break}\PYGdefault{p}{;}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	    \PYGdefault{p}{\PYGdefaultZcb{}}

	  \PYGdefault{c+cm}{/* invalidate load/store operation instance */}
	  \PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{tag}\PYGdefault{o}{++}\PYGdefault{p}{;}
          \PYGdefault{n}{sim\PYGdefaultZus{}slip} \PYGdefault{o}{+=} \PYGdefault{p}{(}\PYGdefault{n}{sim\PYGdefaultZus{}cycle} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{slip}\PYGdefault{p}{);}
   
	  \PYGdefault{c+cm}{/* indicate to pipeline trace that this instruction retired */}
	  \PYGdefault{n}{ptrace\PYGdefaultZus{}newstage}\PYGdefault{p}{(}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{,} \PYGdefault{n}{PST\PYGdefaultZus{}COMMIT}\PYGdefault{p}{,} \PYGdefault{n}{events}\PYGdefault{p}{);}
	  \PYGdefault{n}{ptrace\PYGdefaultZus{}endinst}\PYGdefault{p}{(}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* commit head of LSQ as well */}
	  \PYGdefault{n}{LSQ\PYGdefaultZus{}head} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{LSQ\PYGdefaultZus{}head} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{p}{;}
	  \PYGdefault{n}{LSQ\PYGdefaultZus{}num}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZhy{}}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} committed instruction to arch reg file */}
      \PYGdefault{k}{if} \PYGdefault{p}{((}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}ICOMP}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}FCOMP}\PYGdefault{p}{))} \PYGdefault{o}{||} \PYGdefault{p}{((}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}LOAD}\PYGdefault{p}{))} \PYGdefault{o}{==} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}LOAD}\PYGdefault{p}{)))} \PYGdefault{p}{\PYGdefaultZob{}}
	\PYGdefault{n}{regfile\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef DYNAMIC\PYGdefaultZus{}AF	}
	\PYGdefault{n}{regfile\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rc}\PYGdefault{p}{);}
	\PYGdefault{n}{regfile\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}
      \PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{pred}
	  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{bpred\PYGdefaultZus{}spec\PYGdefaultZus{}update} \PYGdefault{o}{==} \PYGdefault{n}{spec\PYGdefaultZus{}CT}
	  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}CTRL}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} bpred access */}
	  \PYGdefault{n}{bpred\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}

	  \PYGdefault{n}{bpred\PYGdefaultZus{}update}\PYGdefault{p}{(}\PYGdefault{n}{pred}\PYGdefault{p}{,}
		       \PYGdefault{c+cm}{/* branch address */}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{PC}\PYGdefault{p}{,}
		       \PYGdefault{c+cm}{/* actual target address */}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next\PYGdefaultZus{}PC}\PYGdefault{p}{,}
                       \PYGdefault{c+cm}{/* taken? */}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next\PYGdefaultZus{}PC} \PYGdefault{o}{!=} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{PC} \PYGdefault{o}{+}
                                                   \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{)),}
                       \PYGdefault{c+cm}{/* pred taken? */}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{!=} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{PC} \PYGdefault{o}{+}
                                                        \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{)),}
                       \PYGdefault{c+cm}{/* correct pred? */}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{==} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next\PYGdefaultZus{}PC}\PYGdefault{p}{,}
                       \PYGdefault{c+cm}{/* opcode */}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{,}
                       \PYGdefault{c+cm}{/* dir predictor update pointer */}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{dir\PYGdefaultZus{}update}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* invalidate RUU operation instance */}
      \PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{tag}\PYGdefault{o}{++}\PYGdefault{p}{;}
      \PYGdefault{n}{sim\PYGdefaultZus{}slip} \PYGdefault{o}{+=} \PYGdefault{p}{(}\PYGdefault{n}{sim\PYGdefaultZus{}cycle} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{slip}\PYGdefault{p}{);}
      \PYGdefault{c+cm}{/* print retirement trace if in verbose mode */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{verbose}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{n}{sim\PYGdefaultZus{}ret\PYGdefaultZus{}insn}\PYGdefault{o}{++}\PYGdefault{p}{;}
	  \PYGdefault{n}{myfprintf}\PYGdefault{p}{(}\PYGdefault{n}{stderr}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZpc{}10n @ 0x\PYGdefaultZpc{}08p: \PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}ret\PYGdefaultZus{}insn}\PYGdefault{p}{,} \PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{PC}\PYGdefault{p}{);}
 	  \PYGdefault{n}{md\PYGdefaultZus{}print\PYGdefaultZus{}insn}\PYGdefault{p}{(}\PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{IR}\PYGdefault{p}{,} \PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{PC}\PYGdefault{p}{,} \PYGdefault{n}{stderr}\PYGdefault{p}{);}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{p}{)}
	    \PYGdefault{n}{myfprintf}\PYGdefault{p}{(}\PYGdefault{n}{stderr}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}  mem: 0x\PYGdefaultZpc{}08p\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{addr}\PYGdefault{p}{);}
	  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stderr}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}
	  \PYGdefault{c+cm}{/* fflush(stderr); */}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* indicate to pipeline trace that this instruction retired */}
      \PYGdefault{n}{ptrace\PYGdefaultZus{}newstage}\PYGdefault{p}{(}\PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{,} \PYGdefault{n}{PST\PYGdefaultZus{}COMMIT}\PYGdefault{p}{,} \PYGdefault{n}{events}\PYGdefault{p}{);}
      \PYGdefault{n}{ptrace\PYGdefaultZus{}endinst}\PYGdefault{p}{(}\PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* commit head entry of RUU */}
      \PYGdefault{n}{RUU\PYGdefaultZus{}head} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}head} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{p}{;}
      \PYGdefault{n}{RUU\PYGdefaultZus{}num}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZhy{}}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* one more instruction committed to architected state */}
      \PYGdefault{n}{committed}\PYGdefault{o}{++}\PYGdefault{p}{;}

      \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{MAX\PYGdefaultZus{}ODEPS}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{odep\PYGdefaultZus{}list}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{])}
	    \PYGdefault{n}{panic} \PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}retired instruction has odeps}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}
        \PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ *  RUU\PYGdefaultZus{}RECOVER() \PYGdefaultZhy{} squash mispredicted microarchitecture state}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* recover processor microarchitecture state back to point of the}
\PYGdefault{c+cm}{   mis\PYGdefaultZhy{}predicted branch at RUU[BRANCH\PYGdefaultZus{}INDEX] */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{ruu\PYGdefaultZus{}recover}\PYGdefault{p}{(}\PYGdefault{k+kt}{int} \PYGdefault{n}{branch\PYGdefaultZus{}index}\PYGdefault{p}{)}			\PYGdefault{c+cm}{/* index of mis\PYGdefaultZhy{}pred branch */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{,} \PYGdefault{n}{RUU\PYGdefaultZus{}index} \PYGdefault{o}{=} \PYGdefault{n}{RUU\PYGdefaultZus{}tail}\PYGdefault{p}{,} \PYGdefault{n}{LSQ\PYGdefaultZus{}index} \PYGdefault{o}{=} \PYGdefault{n}{LSQ\PYGdefaultZus{}tail}\PYGdefault{p}{;}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{RUU\PYGdefaultZus{}prev\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{n}{RUU\PYGdefaultZus{}tail}\PYGdefault{p}{,} \PYGdefault{n}{LSQ\PYGdefaultZus{}prev\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{n}{LSQ\PYGdefaultZus{}tail}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* recover from the tail of the RUU towards the head until the branch index}
\PYGdefault{c+cm}{     is reached, this direction ensures that the LSQ can be synchronized with}
\PYGdefault{c+cm}{     the RUU */}

  \PYGdefault{c+cm}{/* go to first element to squash */}
  \PYGdefault{n}{RUU\PYGdefaultZus{}index} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}index} \PYGdefault{o}{+} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{p}{;}
  \PYGdefault{n}{LSQ\PYGdefaultZus{}index} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{LSQ\PYGdefaultZus{}index} \PYGdefault{o}{+} \PYGdefault{p}{(}\PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* traverse to older insts until the mispredicted branch is encountered */}
  \PYGdefault{k}{while} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}index} \PYGdefault{o}{!=} \PYGdefault{n}{branch\PYGdefaultZus{}index}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* the RUU should not drain since the mispredicted branch will remain */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{RUU\PYGdefaultZus{}num}\PYGdefault{p}{)}
	\PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}empty RUU\PYGdefaultZdq{}}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* should meet up with the tail first */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}index} \PYGdefault{o}{==} \PYGdefault{n}{RUU\PYGdefaultZus{}head}\PYGdefault{p}{)}
	\PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}RUU head and tail broken\PYGdefaultZdq{}}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* is this operation an effective addr calc for a load or store? */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}index}\PYGdefault{p}{].}\PYGdefault{n}{ea\PYGdefaultZus{}comp}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* should be at least one load or store in the LSQ */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{LSQ\PYGdefaultZus{}num}\PYGdefault{p}{)}
	    \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}RUU and LSQ out of sync\PYGdefaultZdq{}}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* recover any resources consumed by the load or store operation */}
	  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{MAX\PYGdefaultZus{}ODEPS}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{n}{RSLINK\PYGdefaultZus{}FREE\PYGdefaultZus{}LIST}\PYGdefault{p}{(}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}index}\PYGdefault{p}{].}\PYGdefault{n}{odep\PYGdefaultZus{}list}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]);}
	      \PYGdefault{c+cm}{/* blow away the consuming op list */}
	      \PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}index}\PYGdefault{p}{].}\PYGdefault{n}{odep\PYGdefaultZus{}list}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
      
	  \PYGdefault{c+cm}{/* squash this LSQ entry */}
	  \PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}index}\PYGdefault{p}{].}\PYGdefault{n}{tag}\PYGdefault{o}{++}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* indicate in pipetrace that this instruction was squashed */}
	  \PYGdefault{n}{ptrace\PYGdefaultZus{}endinst}\PYGdefault{p}{(}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}index}\PYGdefault{p}{].}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* go to next earlier LSQ slot */}
	  \PYGdefault{n}{LSQ\PYGdefaultZus{}prev\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{n}{LSQ\PYGdefaultZus{}index}\PYGdefault{p}{;}
	  \PYGdefault{n}{LSQ\PYGdefaultZus{}index} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{LSQ\PYGdefaultZus{}index} \PYGdefault{o}{+} \PYGdefault{p}{(}\PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{p}{;}
	  \PYGdefault{n}{LSQ\PYGdefaultZus{}num}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZhy{}}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* recover any resources used by this RUU operation */}
      \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{MAX\PYGdefaultZus{}ODEPS}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{n}{RSLINK\PYGdefaultZus{}FREE\PYGdefaultZus{}LIST}\PYGdefault{p}{(}\PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}index}\PYGdefault{p}{].}\PYGdefault{n}{odep\PYGdefaultZus{}list}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]);}
	  \PYGdefault{c+cm}{/* blow away the consuming op list */}
	  \PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}index}\PYGdefault{p}{].}\PYGdefault{n}{odep\PYGdefaultZus{}list}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      
      \PYGdefault{c+cm}{/* squash this RUU entry */}
      \PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}index}\PYGdefault{p}{].}\PYGdefault{n}{tag}\PYGdefault{o}{++}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* indicate in pipetrace that this instruction was squashed */}
      \PYGdefault{n}{ptrace\PYGdefaultZus{}endinst}\PYGdefault{p}{(}\PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}index}\PYGdefault{p}{].}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* go to next earlier slot in the RUU */}
      \PYGdefault{n}{RUU\PYGdefaultZus{}prev\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{n}{RUU\PYGdefaultZus{}index}\PYGdefault{p}{;}
      \PYGdefault{n}{RUU\PYGdefaultZus{}index} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}index} \PYGdefault{o}{+} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{p}{;}
      \PYGdefault{n}{RUU\PYGdefaultZus{}num}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZhy{}}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* reset head/tail pointers to point to the mis\PYGdefaultZhy{}predicted branch */}
  \PYGdefault{n}{RUU\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{n}{RUU\PYGdefaultZus{}prev\PYGdefaultZus{}tail}\PYGdefault{p}{;}
  \PYGdefault{n}{LSQ\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{n}{LSQ\PYGdefaultZus{}prev\PYGdefaultZus{}tail}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* revert create vector back to last precise create vector state, NOTE:}
\PYGdefault{c+cm}{     this is accomplished by resetting all the copied\PYGdefaultZhy{}on\PYGdefaultZhy{}write bits in the}
\PYGdefault{c+cm}{     USE\PYGdefaultZus{}SPEC\PYGdefaultZus{}CV bit vector */}
  \PYGdefault{n}{BITMAP\PYGdefaultZus{}CLEAR\PYGdefaultZus{}MAP}\PYGdefault{p}{(}\PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}cv}\PYGdefault{p}{,} \PYGdefault{n}{CV\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* FIXME: could reset functional units at squash time */}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ *  RUU\PYGdefaultZus{}WRITEBACK() \PYGdefaultZhy{} instruction result writeback pipeline stage}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* forward declarations */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void} \PYGdefault{n+nf}{tracer\PYGdefaultZus{}recover}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{);}

\PYGdefault{c+cm}{/* writeback completed operation results from the functional units to RUU,}
\PYGdefault{c+cm}{   at this point, the output dependency chains of completing instructions}
\PYGdefault{c+cm}{   are also walked to determine if any dependent instruction now has all}
\PYGdefault{c+cm}{   of its register operands, if so the (nearly) ready instruction is inserted}
\PYGdefault{c+cm}{   into the ready instruction queue */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{ruu\PYGdefaultZus{}writeback}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{;}
  \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* service all completed events */}
  \PYGdefault{k}{while} \PYGdefault{p}{((}\PYGdefault{n}{rs} \PYGdefault{o}{=} \PYGdefault{n}{eventq\PYGdefaultZus{}next\PYGdefaultZus{}event}\PYGdefault{p}{()))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* RS has completed execution and (possibly) produced a result */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{OPERANDS\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{)} \PYGdefault{o}{||} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{queued} \PYGdefault{o}{||} \PYGdefault{o}{!}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{issued} \PYGdefault{o}{||} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{completed}\PYGdefault{p}{)}
	\PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}inst completed and !ready, !issued, or completed\PYGdefaultZdq{}}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* operation has completed */}
      \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{completed} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} 1) Writeback result to resultbus }
\PYGdefault{c+cm}{                   2) Write result to phys. regs (RUU)}
\PYGdefault{c+cm}{		   3) Access wakeup logic}
\PYGdefault{c+cm}{       */}
      \PYGdefault{k}{if}\PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}CTRL}\PYGdefault{p}{))} \PYGdefault{p}{\PYGdefaultZob{}}
	\PYGdefault{n}{window\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
	\PYGdefault{n}{window\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
	\PYGdefault{n}{window\PYGdefaultZus{}wakeup\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
	\PYGdefault{n}{resultbus\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef DYNAMIC\PYGdefaultZus{}AF	}
	\PYGdefault{n}{window\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rc}\PYGdefault{p}{);}
	\PYGdefault{n}{window\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{++}\PYGdefault{p}{;}
	\PYGdefault{n}{resultbus\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rc}\PYGdefault{p}{);}
	\PYGdefault{n}{resultbus\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}
      \PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* does this operation reveal a mis\PYGdefaultZhy{}predicted branch? */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{recover\PYGdefaultZus{}inst}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ}\PYGdefault{p}{)}
	    \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}mis\PYGdefaultZhy{}predicted load or store?!?!?\PYGdefaultZdq{}}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* recover processor state and reinit fetch to correct path */}
	  \PYGdefault{n}{ruu\PYGdefaultZus{}recover}\PYGdefault{p}{(}\PYGdefault{n}{rs} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{RUU}\PYGdefault{p}{);}
	  \PYGdefault{n}{tracer\PYGdefaultZus{}recover}\PYGdefault{p}{();}
	  \PYGdefault{n}{bpred\PYGdefaultZus{}recover}\PYGdefault{p}{(}\PYGdefault{n}{pred}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{PC}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* stall fetch until I\PYGdefaultZhy{}fetch and I\PYGdefaultZhy{}decode recover */}
	  \PYGdefault{n}{ruu\PYGdefaultZus{}fetch\PYGdefaultZus{}issue\PYGdefaultZus{}delay} \PYGdefault{o}{=} \PYGdefault{n}{ruu\PYGdefaultZus{}branch\PYGdefaultZus{}penalty}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* continue writeback of the branch/control instruction */}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* if we speculatively update branch\PYGdefaultZhy{}predictor, do it here */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{pred}
	  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{bpred\PYGdefaultZus{}spec\PYGdefaultZus{}update} \PYGdefault{o}{==} \PYGdefault{n}{spec\PYGdefaultZus{}WB}
	  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{o}{!}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ}
	  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}CTRL}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} bpred access */}
	  \PYGdefault{n}{bpred\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
	  \PYGdefault{n}{bpred\PYGdefaultZus{}update}\PYGdefault{p}{(}\PYGdefault{n}{pred}\PYGdefault{p}{,}
		       \PYGdefault{c+cm}{/* branch address */}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{PC}\PYGdefault{p}{,}
		       \PYGdefault{c+cm}{/* actual target address */}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next\PYGdefaultZus{}PC}\PYGdefault{p}{,}
		       \PYGdefault{c+cm}{/* taken? */}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next\PYGdefaultZus{}PC} \PYGdefault{o}{!=} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{PC} \PYGdefault{o}{+}
						   \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{)),}
		       \PYGdefault{c+cm}{/* pred taken? */}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{!=} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{PC} \PYGdefault{o}{+}
							\PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{)),}
		       \PYGdefault{c+cm}{/* correct pred? */}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{==} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next\PYGdefaultZus{}PC}\PYGdefault{p}{,}
		       \PYGdefault{c+cm}{/* opcode */}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{,}
		       \PYGdefault{c+cm}{/* dir predictor update pointer */}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{dir\PYGdefaultZus{}update}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* entered writeback stage, indicate in pipe trace */}
      \PYGdefault{n}{ptrace\PYGdefaultZus{}newstage}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{,} \PYGdefault{n}{PST\PYGdefaultZus{}WRITEBACK}\PYGdefault{p}{,}
		      \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{recover\PYGdefaultZus{}inst} \PYGdefault{o}{?} \PYGdefault{n+nl}{PEV\PYGdefaultZus{}MPDETECT} \PYGdefault{p}{:} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* broadcast results to consuming operations, this is more efficiently}
\PYGdefault{c+cm}{         accomplished by walking the output dependency chains of the}
\PYGdefault{c+cm}{	 completed instruction */}
      \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{MAX\PYGdefaultZus{}ODEPS}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{onames}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{!=} \PYGdefault{n}{NA}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{k}{struct} \PYGdefault{n}{CV\PYGdefaultZus{}link} \PYGdefault{n}{link}\PYGdefault{p}{;}
	      \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{olink}\PYGdefault{p}{,} \PYGdefault{o}{*}\PYGdefault{n}{olink\PYGdefaultZus{}next}\PYGdefault{p}{;}

	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{spec\PYGdefaultZus{}mode}\PYGdefault{p}{)}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{c+cm}{/* update the speculative create vector, future operations}
\PYGdefault{c+cm}{		     get value from later creator or architected reg file */}
		  \PYGdefault{n}{link} \PYGdefault{o}{=} \PYGdefault{n}{spec\PYGdefaultZus{}create\PYGdefaultZus{}vector}\PYGdefault{p}{[}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{onames}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]];}
		  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{c+cm}{/* !NULL */}\PYGdefault{n}{link}\PYGdefault{p}{.}\PYGdefault{n}{rs}
		      \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{c+cm}{/* refs RS */}\PYGdefault{p}{(}\PYGdefault{n}{link}\PYGdefault{p}{.}\PYGdefault{n}{rs} \PYGdefault{o}{==} \PYGdefault{n}{rs} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{link}\PYGdefault{p}{.}\PYGdefault{n}{odep\PYGdefaultZus{}num} \PYGdefault{o}{==} \PYGdefault{n}{i}\PYGdefault{p}{))}
		    \PYGdefault{p}{\PYGdefaultZob{}}
		      \PYGdefault{c+cm}{/* the result can now be read from a physical register,}
\PYGdefault{c+cm}{			 indicate this as so */}
		      \PYGdefault{n}{spec\PYGdefaultZus{}create\PYGdefaultZus{}vector}\PYGdefault{p}{[}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{onames}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]]} \PYGdefault{o}{=} \PYGdefault{n}{CVLINK\PYGdefaultZus{}NULL}\PYGdefault{p}{;}
		      \PYGdefault{n}{spec\PYGdefaultZus{}create\PYGdefaultZus{}vector\PYGdefaultZus{}rt}\PYGdefault{p}{[}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{onames}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]]} \PYGdefault{o}{=} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{;}
		    \PYGdefault{p}{\PYGdefaultZcb{}}
		  \PYGdefault{c+cm}{/* else, creator invalidated or there is another creator */}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	      \PYGdefault{k}{else}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{c+cm}{/* update the non\PYGdefaultZhy{}speculative create vector, future}
\PYGdefault{c+cm}{		     operations get value from later creator or architected}
\PYGdefault{c+cm}{		     reg file */}
		  \PYGdefault{n}{link} \PYGdefault{o}{=} \PYGdefault{n}{create\PYGdefaultZus{}vector}\PYGdefault{p}{[}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{onames}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]];}
		  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{c+cm}{/* !NULL */}\PYGdefault{n}{link}\PYGdefault{p}{.}\PYGdefault{n}{rs}
		      \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{c+cm}{/* refs RS */}\PYGdefault{p}{(}\PYGdefault{n}{link}\PYGdefault{p}{.}\PYGdefault{n}{rs} \PYGdefault{o}{==} \PYGdefault{n}{rs} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{link}\PYGdefault{p}{.}\PYGdefault{n}{odep\PYGdefaultZus{}num} \PYGdefault{o}{==} \PYGdefault{n}{i}\PYGdefault{p}{))}
		    \PYGdefault{p}{\PYGdefaultZob{}}
		      \PYGdefault{c+cm}{/* the result can now be read from a physical register,}
\PYGdefault{c+cm}{			 indicate this as so */}
		      \PYGdefault{n}{create\PYGdefaultZus{}vector}\PYGdefault{p}{[}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{onames}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]]} \PYGdefault{o}{=} \PYGdefault{n}{CVLINK\PYGdefaultZus{}NULL}\PYGdefault{p}{;}
		      \PYGdefault{n}{create\PYGdefaultZus{}vector\PYGdefaultZus{}rt}\PYGdefault{p}{[}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{onames}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]]} \PYGdefault{o}{=} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{;}
		    \PYGdefault{p}{\PYGdefaultZcb{}}
		  \PYGdefault{c+cm}{/* else, creator invalidated or there is another creator */}
		\PYGdefault{p}{\PYGdefaultZcb{}}

	      \PYGdefault{c+cm}{/* walk output list, queue up ready operations */}
	      \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{olink}\PYGdefault{o}{=}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{odep\PYGdefaultZus{}list}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{];} \PYGdefault{n}{olink}\PYGdefault{p}{;} \PYGdefault{n}{olink}\PYGdefault{o}{=}\PYGdefault{n}{olink\PYGdefaultZus{}next}\PYGdefault{p}{)}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{RSLINK\PYGdefaultZus{}VALID}\PYGdefault{p}{(}\PYGdefault{n}{olink}\PYGdefault{p}{))}
		    \PYGdefault{p}{\PYGdefaultZob{}}
		      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{olink}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{idep\PYGdefaultZus{}ready}\PYGdefault{p}{[}\PYGdefault{n}{olink}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{x}\PYGdefault{p}{.}\PYGdefault{n}{opnum}\PYGdefault{p}{])}
			\PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}output dependence already satisfied\PYGdefaultZdq{}}\PYGdefault{p}{);}

		      \PYGdefault{c+cm}{/* input is now ready */}
		      \PYGdefault{n}{olink}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{idep\PYGdefaultZus{}ready}\PYGdefault{p}{[}\PYGdefault{n}{olink}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{x}\PYGdefault{p}{.}\PYGdefault{n}{opnum}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}

		      \PYGdefault{c+cm}{/* are all the register operands of target ready? */}
		      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{OPERANDS\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{n}{olink}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{rs}\PYGdefault{p}{))}
			\PYGdefault{p}{\PYGdefaultZob{}}
			  \PYGdefault{c+cm}{/* yes! enqueue instruction as ready, NOTE: stores}
\PYGdefault{c+cm}{			     complete at dispatch, so no need to enqueue}
\PYGdefault{c+cm}{			     them */}
			  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{olink}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ}
			      \PYGdefault{o}{||} \PYGdefault{p}{((}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{olink}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{))}
				  \PYGdefault{o}{==} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{)))}
			    \PYGdefault{n}{readyq\PYGdefaultZus{}enqueue}\PYGdefault{p}{(}\PYGdefault{n}{olink}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{rs}\PYGdefault{p}{);}
			  \PYGdefault{c+cm}{/* else, ld op, issued when no mem conflict */}
			\PYGdefault{p}{\PYGdefaultZcb{}}
		    \PYGdefault{p}{\PYGdefaultZcb{}}

		  \PYGdefault{c+cm}{/* grab link to next element prior to free */}
		  \PYGdefault{n}{olink\PYGdefaultZus{}next} \PYGdefault{o}{=} \PYGdefault{n}{olink}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{;}

		  \PYGdefault{c+cm}{/* free dependence link element */}
		  \PYGdefault{n}{RSLINK\PYGdefaultZus{}FREE}\PYGdefault{p}{(}\PYGdefault{n}{olink}\PYGdefault{p}{);}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	      \PYGdefault{c+cm}{/* blow away the consuming op list */}
	      \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{odep\PYGdefaultZus{}list}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}

	    \PYGdefault{p}{\PYGdefaultZcb{}} \PYGdefault{c+cm}{/* if not NA output */}

	\PYGdefault{p}{\PYGdefaultZcb{}} \PYGdefault{c+cm}{/* for all outputs */}

   \PYGdefault{p}{\PYGdefaultZcb{}} \PYGdefault{c+cm}{/* for all writeback events */}

\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ *  LSQ\PYGdefaultZus{}REFRESH() \PYGdefaultZhy{} memory access dependence checker/scheduler}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* this function locates ready instructions whose memory dependencies have}
\PYGdefault{c+cm}{   been satisfied, this is accomplished by walking the LSQ for loads, looking}
\PYGdefault{c+cm}{   for blocking memory dependency condition (e.g., earlier store with an}
\PYGdefault{c+cm}{   unknown address) */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define MAX\PYGdefaultZus{}STD\PYGdefaultZus{}UNKNOWNS		64}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{lsq\PYGdefaultZus{}refresh}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{,} \PYGdefault{n}{j}\PYGdefault{p}{,} \PYGdefault{n}{index}\PYGdefault{p}{,} \PYGdefault{n}{n\PYGdefaultZus{}std\PYGdefaultZus{}unknowns}\PYGdefault{p}{;}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{std\PYGdefaultZus{}unknowns}\PYGdefault{p}{[}\PYGdefault{n}{MAX\PYGdefaultZus{}STD\PYGdefaultZus{}UNKNOWNS}\PYGdefault{p}{];}

  \PYGdefault{c+cm}{/* scan entire queue for ready loads: scan from oldest instruction}
\PYGdefault{c+cm}{     (head) until we reach the tail or an unresolved store, after which no}
\PYGdefault{c+cm}{     other instruction will become ready */}
  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n}{index}\PYGdefault{o}{=}\PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{,} \PYGdefault{n}{n\PYGdefaultZus{}std\PYGdefaultZus{}unknowns}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
       \PYGdefault{n}{i} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{LSQ\PYGdefaultZus{}num}\PYGdefault{p}{;}
       \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{,} \PYGdefault{n}{index}\PYGdefault{o}{=}\PYGdefault{p}{(}\PYGdefault{n}{index} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* terminate search for ready loads after first unresolved store,}
\PYGdefault{c+cm}{	 as no later load could be resolved in its presence */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{c+cm}{/* store? */}
	  \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{].}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{))} \PYGdefault{o}{==} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{STORE\PYGdefaultZus{}ADDR\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{]))}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* FIXME: a later STD + STD known could hide the STA unknown */}
	      \PYGdefault{c+cm}{/* sta unknown, blocks all later loads, stop search */}
	      \PYGdefault{k}{break}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	  \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{OPERANDS\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{]))}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* sta known, but std unknown, may block a later store, record}
\PYGdefault{c+cm}{		 this address for later referral, we use an array here because}
\PYGdefault{c+cm}{		 for most simulations the number of entries to search will be}
\PYGdefault{c+cm}{		 very small */}
	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{n\PYGdefaultZus{}std\PYGdefaultZus{}unknowns} \PYGdefault{o}{==} \PYGdefault{n}{MAX\PYGdefaultZus{}STD\PYGdefaultZus{}UNKNOWNS}\PYGdefault{p}{)}
		\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}STD unknown array overflow, increase MAX\PYGdefaultZus{}STD\PYGdefaultZus{}UNKNOWNS\PYGdefaultZdq{}}\PYGdefault{p}{);}
	      \PYGdefault{n}{std\PYGdefaultZus{}unknowns}\PYGdefault{p}{[}\PYGdefault{n}{n\PYGdefaultZus{}std\PYGdefaultZus{}unknowns}\PYGdefault{o}{++}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{].}\PYGdefault{n}{addr}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	  \PYGdefault{k}{else} \PYGdefault{c+cm}{/* STORE\PYGdefaultZus{}ADDR\PYGdefaultZus{}READY() \PYGdefaultZam{}\PYGdefaultZam{} OPERANDS\PYGdefaultZus{}READY() */}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* a later STD known hides an earlier STD unknown */}
	      \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{j}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{j}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{n\PYGdefaultZus{}std\PYGdefaultZus{}unknowns}\PYGdefault{p}{;} \PYGdefault{n}{j}\PYGdefault{o}{++}\PYGdefault{p}{)}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{std\PYGdefaultZus{}unknowns}\PYGdefault{p}{[}\PYGdefault{n}{j}\PYGdefault{p}{]} \PYGdefault{o}{==} \PYGdefault{c+cm}{/* STA/STD known */}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{].}\PYGdefault{n}{addr}\PYGdefault{p}{)}
		    \PYGdefault{n}{std\PYGdefaultZus{}unknowns}\PYGdefault{p}{[}\PYGdefault{n}{j}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{c+cm}{/* bogus addr */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{c+cm}{/* load? */}
	  \PYGdefault{p}{((}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{].}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}LOAD}\PYGdefault{p}{))} \PYGdefault{o}{==} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}LOAD}\PYGdefault{p}{))}
	  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{c+cm}{/* queued? */}\PYGdefault{o}{!}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{].}\PYGdefault{n}{queued}
	  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{c+cm}{/* waiting? */}\PYGdefault{o}{!}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{].}\PYGdefault{n}{issued}
	  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{c+cm}{/* completed? */}\PYGdefault{o}{!}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{].}\PYGdefault{n}{completed}
	  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{c+cm}{/* regs ready? */}\PYGdefault{n}{OPERANDS\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{]))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* no STA unknown conflict (because we got to this check), check for}
\PYGdefault{c+cm}{	     a STD unknown conflict */}
	  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{j}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{j}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{n\PYGdefaultZus{}std\PYGdefaultZus{}unknowns}\PYGdefault{p}{;} \PYGdefault{n}{j}\PYGdefault{o}{++}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* found a relevant STD unknown? */}
	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{std\PYGdefaultZus{}unknowns}\PYGdefault{p}{[}\PYGdefault{n}{j}\PYGdefault{p}{]} \PYGdefault{o}{==} \PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{].}\PYGdefault{n}{addr}\PYGdefault{p}{)}
		\PYGdefault{k}{break}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{j} \PYGdefault{o}{==} \PYGdefault{n}{n\PYGdefaultZus{}std\PYGdefaultZus{}unknowns}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* no STA or STD unknown conflicts, put load on ready queue */}
	      \PYGdefault{n}{readyq\PYGdefaultZus{}enqueue}\PYGdefault{p}{(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{]);}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ *  RUU\PYGdefaultZus{}ISSUE() \PYGdefaultZhy{} issue instructions to functional units}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* attempt to issue all operations in the ready queue; insts in the ready}
\PYGdefault{c+cm}{   instruction queue have all register dependencies satisfied, this function}
\PYGdefault{c+cm}{   must then 1) ensure the instructions memory dependencies have been satisfied}
\PYGdefault{c+cm}{   (see lsq\PYGdefaultZus{}refresh() for details on this process) and 2) a function unit}
\PYGdefault{c+cm}{   is available in this cycle to commence execution of the operation; if all}
\PYGdefault{c+cm}{   goes well, the function unit is allocated, a writeback event is scheduled,}
\PYGdefault{c+cm}{   and the instruction begins execution */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{ruu\PYGdefaultZus{}issue}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{,} \PYGdefault{n}{load\PYGdefaultZus{}lat}\PYGdefault{p}{,} \PYGdefault{n}{tlb\PYGdefaultZus{}lat}\PYGdefault{p}{,} \PYGdefault{n}{n\PYGdefaultZus{}issued}\PYGdefault{p}{;}
  \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{node}\PYGdefault{p}{,} \PYGdefault{o}{*}\PYGdefault{n}{next\PYGdefaultZus{}node}\PYGdefault{p}{;}
  \PYGdefault{k}{struct} \PYGdefault{n}{res\PYGdefaultZus{}template} \PYGdefault{o}{*}\PYGdefault{n}{fu}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* FIXME: could be a little more efficient when scanning the ready queue */}

  \PYGdefault{c+cm}{/* copy and then blow away the ready list, NOTE: the ready list is}
\PYGdefault{c+cm}{     always totally reclaimed each cycle, and instructions that are not}
\PYGdefault{c+cm}{     issue are explicitly reinserted into the ready instruction queue,}
\PYGdefault{c+cm}{     this management strategy ensures that the ready instruction queue}
\PYGdefault{c+cm}{     is always properly sorted */}
  \PYGdefault{n}{node} \PYGdefault{o}{=} \PYGdefault{n}{ready\PYGdefaultZus{}queue}\PYGdefault{p}{;}
  \PYGdefault{n}{ready\PYGdefaultZus{}queue} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* visit all ready instructions (i.e., insts whose register input}
\PYGdefault{c+cm}{     dependencies have been satisfied, stop issue when no more instructions}
\PYGdefault{c+cm}{     are available or issue bandwidth is exhausted */}
  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{n\PYGdefaultZus{}issued}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
       \PYGdefault{n}{node} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{n\PYGdefaultZus{}issued} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{ruu\PYGdefaultZus{}issue\PYGdefaultZus{}width}\PYGdefault{p}{;}
       \PYGdefault{n}{node} \PYGdefault{o}{=} \PYGdefault{n}{next\PYGdefaultZus{}node}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{n}{next\PYGdefaultZus{}node} \PYGdefault{o}{=} \PYGdefault{n}{node}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* still valid? */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{RSLINK\PYGdefaultZus{}VALID}\PYGdefault{p}{(}\PYGdefault{n}{node}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs} \PYGdefault{o}{=} \PYGdefault{n}{RSLINK\PYGdefaultZus{}RS}\PYGdefault{p}{(}\PYGdefault{n}{node}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* issue operation, both reg and mem deps have been satisfied */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{OPERANDS\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{)} \PYGdefault{o}{||} \PYGdefault{o}{!}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{queued}
	      \PYGdefault{o}{||} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{issued} \PYGdefault{o}{||} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{completed}\PYGdefault{p}{)}
	    \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}issued inst !ready, issued, or completed\PYGdefaultZdq{}}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} access window selection logic */}
	  \PYGdefault{n}{window\PYGdefaultZus{}selection\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* node is now un\PYGdefaultZhy{}queued */}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{queued} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}

	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ}
	      \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{p}{((}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{))} \PYGdefault{o}{==} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{)))}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* stores complete in effectively zero time, result is}
\PYGdefault{c+cm}{		 written into the load/store queue, the actual store into}
\PYGdefault{c+cm}{		 the memory system occurs when the instruction is retired}
\PYGdefault{c+cm}{		 (see ruu\PYGdefaultZus{}commit()) */}
	      \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{issued} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
	      \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{completed} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{onames}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]} \PYGdefault{o}{||} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{onames}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{])}
		\PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}store creates result\PYGdefaultZdq{}}\PYGdefault{p}{);}

	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{recover\PYGdefaultZus{}inst}\PYGdefault{p}{)}
		\PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}mis\PYGdefaultZhy{}predicted store\PYGdefaultZdq{}}\PYGdefault{p}{);}

	      \PYGdefault{c+cm}{/* entered execute stage, indicate in pipe trace */}
	      \PYGdefault{n}{ptrace\PYGdefaultZus{}newstage}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{,} \PYGdefault{n}{PST\PYGdefaultZus{}WRITEBACK}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}

	      \PYGdefault{c+cm}{/* one more inst issued */}
	      \PYGdefault{n}{n\PYGdefaultZus{}issued}\PYGdefault{o}{++}\PYGdefault{p}{;}

	      \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} LSQ access \PYGdefaultZhy{}\PYGdefaultZhy{} write data into store buffer */}
	      \PYGdefault{n}{lsq\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq\PYGdefaultZus{}store\PYGdefaultZus{}data\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef DYNAMIC\PYGdefaultZus{}AF	}
	      \PYGdefault{n}{lsq\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra}\PYGdefault{p}{);}
	      \PYGdefault{n}{lsq\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	  \PYGdefault{k}{else}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* issue the instruction to a functional unit */}
	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FUCLASS}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{!=} \PYGdefault{n}{NA}\PYGdefault{p}{)}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{n}{fu} \PYGdefault{o}{=} \PYGdefault{n}{res\PYGdefaultZus{}get}\PYGdefault{p}{(}\PYGdefault{n}{fu\PYGdefaultZus{}pool}\PYGdefault{p}{,} \PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FUCLASS}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{));}
		  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{fu}\PYGdefault{p}{)}
		    \PYGdefault{p}{\PYGdefaultZob{}}
		      \PYGdefault{c+cm}{/* got one! issue inst to functional unit */}
		      \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{issued} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
		      \PYGdefault{c+cm}{/* reserve the functional unit */}
		      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{fu}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{master}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{busy}\PYGdefault{p}{)}
			\PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}functional unit already in use\PYGdefaultZdq{}}\PYGdefault{p}{);}

		      \PYGdefault{c+cm}{/* schedule functional unit release event */}
		      \PYGdefault{n}{fu}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{master}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{busy} \PYGdefault{o}{=} \PYGdefault{n}{fu}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{issuelat}\PYGdefault{p}{;}

		      \PYGdefault{c+cm}{/* schedule a result writeback event */}
		      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ}
			  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{p}{((}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}LOAD}\PYGdefault{p}{))}
			      \PYGdefault{o}{==} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}LOAD}\PYGdefault{p}{)))}
			\PYGdefault{p}{\PYGdefaultZob{}}
			  \PYGdefault{k+kt}{int} \PYGdefault{n}{events} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

			  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} LSQ access */}
			  \PYGdefault{n}{lsq\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
			  \PYGdefault{n}{lsq\PYGdefaultZus{}wakeup\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}

			  \PYGdefault{c+cm}{/* for loads, determine cache access latency:}
\PYGdefault{c+cm}{			     first scan LSQ to see if a store forward is}
\PYGdefault{c+cm}{			     possible, if not, access the data cache */}
			  \PYGdefault{n}{load\PYGdefaultZus{}lat} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
			  \PYGdefault{n}{i} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{rs} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{LSQ}\PYGdefault{p}{);}
			  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{i} \PYGdefault{o}{!=} \PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{)}
			    \PYGdefault{p}{\PYGdefaultZob{}}
			      \PYGdefault{k}{for} \PYGdefault{p}{(;;)}
				\PYGdefault{p}{\PYGdefaultZob{}}
				  \PYGdefault{c+cm}{/* go to next earlier LSQ entry */}
				  \PYGdefault{n}{i} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{i} \PYGdefault{o}{+} \PYGdefault{p}{(}\PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{p}{;}

				  \PYGdefault{c+cm}{/* FIXME: not dealing with partials! */}
				  \PYGdefault{k}{if} \PYGdefault{p}{((}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{].}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{)}
				      \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{].}\PYGdefault{n}{addr} \PYGdefault{o}{==} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{addr}\PYGdefault{p}{))}
				    \PYGdefault{p}{\PYGdefaultZob{}}
				      \PYGdefault{c+cm}{/* hit in the LSQ */}
				      \PYGdefault{n}{load\PYGdefaultZus{}lat} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{;}
				      \PYGdefault{n}{lsq\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
				      \PYGdefault{n}{lsq\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
				      \PYGdefault{n}{lsq\PYGdefaultZus{}load\PYGdefaultZus{}data\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef DYNAMIC\PYGdefaultZus{}AF	}
				      \PYGdefault{n}{lsq\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra\PYGdefaultZus{}result}\PYGdefault{p}{);}
				      \PYGdefault{n}{lsq\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}
				      \PYGdefault{k}{break}\PYGdefault{p}{;}
				    \PYGdefault{p}{\PYGdefaultZcb{}}

				  \PYGdefault{c+cm}{/* scan finished? */}
				  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{i} \PYGdefault{o}{==} \PYGdefault{n}{LSQ\PYGdefaultZus{}head}\PYGdefault{p}{)}
				    \PYGdefault{k}{break}\PYGdefault{p}{;}
				\PYGdefault{p}{\PYGdefaultZcb{}}
			    \PYGdefault{p}{\PYGdefaultZcb{}}

			  \PYGdefault{c+cm}{/* was the value store forwared from the LSQ? */}
			  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{load\PYGdefaultZus{}lat}\PYGdefault{p}{)}
			    \PYGdefault{p}{\PYGdefaultZob{}}
			      \PYGdefault{k+kt}{int} \PYGdefault{n}{valid\PYGdefaultZus{}addr} \PYGdefault{o}{=} \PYGdefault{n}{MD\PYGdefaultZus{}VALID\PYGdefaultZus{}ADDR}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{addr}\PYGdefault{p}{);}

			      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{spec\PYGdefaultZus{}mode} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{o}{!}\PYGdefault{n}{valid\PYGdefaultZus{}addr}\PYGdefault{p}{)}
				\PYGdefault{n}{sim\PYGdefaultZus{}invalid\PYGdefaultZus{}addrs}\PYGdefault{o}{++}\PYGdefault{p}{;}

			      \PYGdefault{c+cm}{/* no! go to the data cache if addr is valid */}
			      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl1} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{valid\PYGdefaultZus{}addr}\PYGdefault{p}{)}
				\PYGdefault{p}{\PYGdefaultZob{}}
				  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} D\PYGdefaultZhy{}cache access */}
				  \PYGdefault{n}{dcache\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
				  \PYGdefault{c+cm}{/* access the cache if non\PYGdefaultZhy{}faulting */}
				  \PYGdefault{n}{load\PYGdefaultZus{}lat} \PYGdefault{o}{=}
				    \PYGdefault{n}{cache\PYGdefaultZus{}access}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}dl1}\PYGdefault{p}{,} \PYGdefault{n}{Read}\PYGdefault{p}{,}
						 \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{addr} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{o}{\PYGdefaultZti{}}\PYGdefault{l+m+mi}{3}\PYGdefault{p}{),} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{4}\PYGdefault{p}{,}
						 \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
				  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{load\PYGdefaultZus{}lat} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{n}{cache\PYGdefaultZus{}dl1\PYGdefaultZus{}lat}\PYGdefault{p}{)}
				    \PYGdefault{n}{events} \PYGdefault{o}{|=} \PYGdefault{n}{PEV\PYGdefaultZus{}CACHEMISS}\PYGdefault{p}{;}
				\PYGdefault{p}{\PYGdefaultZcb{}}
			      \PYGdefault{k}{else}
				\PYGdefault{p}{\PYGdefaultZob{}}
				  \PYGdefault{c+cm}{/* no caches defined, just use op latency */}
				  \PYGdefault{n}{load\PYGdefaultZus{}lat} \PYGdefault{o}{=} \PYGdefault{n}{fu}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{oplat}\PYGdefault{p}{;}
				\PYGdefault{p}{\PYGdefaultZcb{}}
			    \PYGdefault{p}{\PYGdefaultZcb{}}

			  \PYGdefault{c+cm}{/* all loads and stores must to access D\PYGdefaultZhy{}TLB */}
			  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{dtlb} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{MD\PYGdefaultZus{}VALID\PYGdefaultZus{}ADDR}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{addr}\PYGdefault{p}{))}
			    \PYGdefault{p}{\PYGdefaultZob{}}
			      \PYGdefault{c+cm}{/* access the D\PYGdefaultZhy{}DLB, NOTE: this code will}
\PYGdefault{c+cm}{				 initiate speculative TLB misses */}
			      \PYGdefault{n}{tlb\PYGdefaultZus{}lat} \PYGdefault{o}{=}
				\PYGdefault{n}{cache\PYGdefaultZus{}access}\PYGdefault{p}{(}\PYGdefault{n}{dtlb}\PYGdefault{p}{,} \PYGdefault{n}{Read}\PYGdefault{p}{,} \PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{addr} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{o}{\PYGdefaultZti{}}\PYGdefault{l+m+mi}{3}\PYGdefault{p}{),}
					     \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{4}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
			      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{tlb\PYGdefaultZus{}lat} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
				\PYGdefault{n}{events} \PYGdefault{o}{|=} \PYGdefault{n}{PEV\PYGdefaultZus{}TLBMISS}\PYGdefault{p}{;}

			      \PYGdefault{c+cm}{/* D\PYGdefaultZhy{}cache/D\PYGdefaultZhy{}TLB accesses occur in parallel */}
			      \PYGdefault{n}{load\PYGdefaultZus{}lat} \PYGdefault{o}{=} \PYGdefault{n}{MAX}\PYGdefault{p}{(}\PYGdefault{n}{tlb\PYGdefaultZus{}lat}\PYGdefault{p}{,} \PYGdefault{n}{load\PYGdefaultZus{}lat}\PYGdefault{p}{);}
			    \PYGdefault{p}{\PYGdefaultZcb{}}

			  \PYGdefault{c+cm}{/* use computed cache access latency */}
			  \PYGdefault{n}{eventq\PYGdefaultZus{}queue\PYGdefaultZus{}event}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}cycle} \PYGdefault{o}{+} \PYGdefault{n}{load\PYGdefaultZus{}lat}\PYGdefault{p}{);}

			  \PYGdefault{c+cm}{/* entered execute stage, indicate in pipe trace */}
			  \PYGdefault{n}{ptrace\PYGdefaultZus{}newstage}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{,} \PYGdefault{n}{PST\PYGdefaultZus{}EXECUTE}\PYGdefault{p}{,}
					  \PYGdefault{p}{((}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ea\PYGdefaultZus{}comp} \PYGdefault{o}{?} \PYGdefault{n+nl}{PEV\PYGdefaultZus{}AGEN} \PYGdefault{p}{:} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
					   \PYGdefault{o}{|} \PYGdefault{n}{events}\PYGdefault{p}{));}
			\PYGdefault{p}{\PYGdefaultZcb{}}
		      \PYGdefault{k}{else} \PYGdefault{c+cm}{/* !load \PYGdefaultZam{}\PYGdefaultZam{} !store */}
			\PYGdefault{p}{\PYGdefaultZob{}}
			  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} ALU access Wattch\PYGdefaultZhy{}FIXME }
\PYGdefault{c+cm}{			     (different op types) }
\PYGdefault{c+cm}{			     also spread out power of multi\PYGdefaultZhy{}cycle ops }
\PYGdefault{c+cm}{			  */}
			  \PYGdefault{n}{alu\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}

			  \PYGdefault{k}{if}\PYGdefault{p}{((}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}FCOMP}\PYGdefault{p}{))}\PYGdefault{o}{==} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}FCOMP}\PYGdefault{p}{))}
			    \PYGdefault{n}{falu\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
			  \PYGdefault{k}{else}
			    \PYGdefault{n}{ialu\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}

			  \PYGdefault{c+cm}{/* use deterministic functional unit latency */}
			  \PYGdefault{n}{eventq\PYGdefaultZus{}queue\PYGdefaultZus{}event}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}cycle} \PYGdefault{o}{+} \PYGdefault{n}{fu}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{oplat}\PYGdefault{p}{);}

			  \PYGdefault{c+cm}{/* entered execute stage, indicate in pipe trace */}
			  \PYGdefault{n}{ptrace\PYGdefaultZus{}newstage}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{,} \PYGdefault{n}{PST\PYGdefaultZus{}EXECUTE}\PYGdefault{p}{,} 
					  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ea\PYGdefaultZus{}comp} \PYGdefault{o}{?} \PYGdefault{n+nl}{PEV\PYGdefaultZus{}AGEN} \PYGdefault{p}{:} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}
			\PYGdefault{p}{\PYGdefaultZcb{}}

		      \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} window access */}
		      \PYGdefault{n}{window\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		      \PYGdefault{c+cm}{/* read values from window send to FUs */}
		      \PYGdefault{n}{window\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		      \PYGdefault{n}{window\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef DYNAMIC\PYGdefaultZus{}AF	}
	      \PYGdefault{n}{window\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra}\PYGdefault{p}{)} \PYGdefault{o}{+} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rb}\PYGdefault{p}{);}
	      \PYGdefault{n}{window\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{+=}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

		      \PYGdefault{c+cm}{/* one more inst issued */}
		      \PYGdefault{n}{n\PYGdefaultZus{}issued}\PYGdefault{o}{++}\PYGdefault{p}{;}
		    \PYGdefault{p}{\PYGdefaultZcb{}}
		  \PYGdefault{k}{else} \PYGdefault{c+cm}{/* no functional unit */}
		    \PYGdefault{p}{\PYGdefaultZob{}}
		      \PYGdefault{c+cm}{/* insufficient functional unit resources, put operation}
\PYGdefault{c+cm}{			 back onto the ready list, we\PYGdefaultZsq{}ll try to issue it}
\PYGdefault{c+cm}{			 again next cycle */}
		      \PYGdefault{n}{readyq\PYGdefaultZus{}enqueue}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{);}
		    \PYGdefault{p}{\PYGdefaultZcb{}}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	      \PYGdefault{k}{else} \PYGdefault{c+cm}{/* does not require a functional unit! */}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{c+cm}{/* FIXME: need better solution for these */}
		  \PYGdefault{c+cm}{/* the instruction does not need a functional unit */}
		  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{issued} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}

		  \PYGdefault{c+cm}{/* schedule a result event */}
		  \PYGdefault{n}{eventq\PYGdefaultZus{}queue\PYGdefaultZus{}event}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}cycle} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{);}

		  \PYGdefault{c+cm}{/* entered execute stage, indicate in pipe trace */}
		  \PYGdefault{n}{ptrace\PYGdefaultZus{}newstage}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{,} \PYGdefault{n}{PST\PYGdefaultZus{}EXECUTE}\PYGdefault{p}{,}
				  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ea\PYGdefaultZus{}comp} \PYGdefault{o}{?} \PYGdefault{n+nl}{PEV\PYGdefaultZus{}AGEN} \PYGdefault{p}{:} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}

		  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} Window access */}
		  \PYGdefault{n}{window\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		  \PYGdefault{c+cm}{/* read values from window send to FUs */}
		  \PYGdefault{n}{window\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		  \PYGdefault{n}{window\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef DYNAMIC\PYGdefaultZus{}AF	}
	      \PYGdefault{n}{window\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra}\PYGdefault{p}{)} \PYGdefault{o}{+} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rb}\PYGdefault{p}{);}
	      \PYGdefault{n}{window\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{+=}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

		  \PYGdefault{c+cm}{/* one more inst issued */}
		  \PYGdefault{n}{n\PYGdefaultZus{}issued}\PYGdefault{o}{++}\PYGdefault{p}{;}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	    \PYGdefault{p}{\PYGdefaultZcb{}} \PYGdefault{c+cm}{/* !store */}

	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{c+cm}{/* else, RUU entry was squashed */}

      \PYGdefault{c+cm}{/* reclaim ready list entry, NOTE: this is done whether or not the}
\PYGdefault{c+cm}{         instruction issued, since the instruction was once again reinserted}
\PYGdefault{c+cm}{         into the ready queue if it did not issue, this ensures that the ready}
\PYGdefault{c+cm}{         queue is always properly sorted */}
      \PYGdefault{n}{RSLINK\PYGdefaultZus{}FREE}\PYGdefault{p}{(}\PYGdefault{n}{node}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* put any instruction not issued back into the ready queue, go through}
\PYGdefault{c+cm}{     normal channels to ensure instruction stay ordered correctly */}
  \PYGdefault{k}{for} \PYGdefault{p}{(;} \PYGdefault{n}{node}\PYGdefault{p}{;} \PYGdefault{n}{node} \PYGdefault{o}{=} \PYGdefault{n}{next\PYGdefaultZus{}node}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{n}{next\PYGdefaultZus{}node} \PYGdefault{o}{=} \PYGdefault{n}{node}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* still valid? */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{RSLINK\PYGdefaultZus{}VALID}\PYGdefault{p}{(}\PYGdefault{n}{node}\PYGdefault{p}{))}
        \PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs} \PYGdefault{o}{=} \PYGdefault{n}{RSLINK\PYGdefaultZus{}RS}\PYGdefault{p}{(}\PYGdefault{n}{node}\PYGdefault{p}{);}

          \PYGdefault{c+cm}{/* node is now un\PYGdefaultZhy{}queued */}
          \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{queued} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* not issued, put operation back onto the ready list, we\PYGdefaultZsq{}ll try to}
\PYGdefault{c+cm}{	     issue it again next cycle */}
          \PYGdefault{n}{readyq\PYGdefaultZus{}enqueue}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{);}
        \PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{c+cm}{/* else, RUU entry was squashed */}

      \PYGdefault{c+cm}{/* reclaim ready list entry, NOTE: this is done whether or not the}
\PYGdefault{c+cm}{         instruction issued, since the instruction was once again reinserted}
\PYGdefault{c+cm}{         into the ready queue if it did not issue, this ensures that the ready}
\PYGdefault{c+cm}{         queue is always properly sorted */}
      \PYGdefault{n}{RSLINK\PYGdefaultZus{}FREE}\PYGdefault{p}{(}\PYGdefault{n}{node}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * routines for generating on\PYGdefaultZhy{}the\PYGdefaultZhy{}fly instruction traces with support}
\PYGdefault{c+cm}{ * for control and data misspeculation modeling}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* integer register file */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define R\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ       (BITMAP\PYGdefaultZus{}SIZE(MD\PYGdefaultZus{}NUM\PYGdefaultZus{}IREGS))}
\PYGdefault{k}{static} \PYGdefault{n+nf}{BITMAP\PYGdefaultZus{}TYPE}\PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}NUM\PYGdefaultZus{}IREGS}\PYGdefault{p}{,} \PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}R}\PYGdefault{p}{);}
\PYGdefault{k}{static} \PYGdefault{k+kt}{md\PYGdefaultZus{}gpr\PYGdefaultZus{}t} \PYGdefault{n}{spec\PYGdefaultZus{}regs\PYGdefaultZus{}R}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* floating point register file */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ       (BITMAP\PYGdefaultZus{}SIZE(MD\PYGdefaultZus{}NUM\PYGdefaultZus{}FREGS))}
\PYGdefault{k}{static} \PYGdefault{n+nf}{BITMAP\PYGdefaultZus{}TYPE}\PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}NUM\PYGdefaultZus{}FREGS}\PYGdefault{p}{,} \PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}F}\PYGdefault{p}{);}
\PYGdefault{k}{static} \PYGdefault{k+kt}{md\PYGdefaultZus{}fpr\PYGdefaultZus{}t} \PYGdefault{n}{spec\PYGdefaultZus{}regs\PYGdefaultZus{}F}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* miscellaneous registers */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ       (BITMAP\PYGdefaultZus{}SIZE(MD\PYGdefaultZus{}NUM\PYGdefaultZus{}CREGS))}
\PYGdefault{k}{static} \PYGdefault{n+nf}{BITMAP\PYGdefaultZus{}TYPE}\PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}NUM\PYGdefaultZus{}FREGS}\PYGdefault{p}{,} \PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}C}\PYGdefault{p}{);}
\PYGdefault{k}{static} \PYGdefault{k+kt}{md\PYGdefaultZus{}ctrl\PYGdefaultZus{}t} \PYGdefault{n}{spec\PYGdefaultZus{}regs\PYGdefaultZus{}C}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* dump speculative register state */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{rspec\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{)}			\PYGdefault{c+cm}{/* output stream */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{stream}\PYGdefault{p}{)}
    \PYGdefault{n}{stream} \PYGdefault{o}{=} \PYGdefault{n}{stderr}\PYGdefault{p}{;}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}** speculative register contents **}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}spec\PYGdefaultZus{}mode: \PYGdefaultZpc{}s}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{spec\PYGdefaultZus{}mode} \PYGdefault{o}{?} \PYGdefault{l+s}{\PYGdefaultZdq{}t\PYGdefaultZdq{}} \PYGdefault{o}{:} \PYGdefault{l+s}{\PYGdefaultZdq{}f\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* dump speculative integer regs */}
  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{MD\PYGdefaultZus{}NUM\PYGdefaultZus{}IREGS}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P}\PYGdefault{p}{(}\PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}R}\PYGdefault{p}{,} \PYGdefault{n}{R\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ}\PYGdefault{p}{,} \PYGdefault{n}{i}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{n}{md\PYGdefaultZus{}print\PYGdefaultZus{}ireg}\PYGdefault{p}{(}\PYGdefault{n}{spec\PYGdefaultZus{}regs\PYGdefaultZus{}R}\PYGdefault{p}{,} \PYGdefault{n}{i}\PYGdefault{p}{,} \PYGdefault{n}{stream}\PYGdefault{p}{);}
	  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* dump speculative FP regs */}
  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{MD\PYGdefaultZus{}NUM\PYGdefaultZus{}FREGS}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P}\PYGdefault{p}{(}\PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}F}\PYGdefault{p}{,} \PYGdefault{n}{F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ}\PYGdefault{p}{,} \PYGdefault{n}{i}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{n}{md\PYGdefaultZus{}print\PYGdefaultZus{}fpreg}\PYGdefault{p}{(}\PYGdefault{n}{spec\PYGdefaultZus{}regs\PYGdefaultZus{}F}\PYGdefault{p}{,} \PYGdefault{n}{i}\PYGdefault{p}{,} \PYGdefault{n}{stream}\PYGdefault{p}{);}
	  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* dump speculative CTRL regs */}
  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{MD\PYGdefaultZus{}NUM\PYGdefaultZus{}CREGS}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P}\PYGdefault{p}{(}\PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}C}\PYGdefault{p}{,} \PYGdefault{n}{C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ}\PYGdefault{p}{,} \PYGdefault{n}{i}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{n}{md\PYGdefaultZus{}print\PYGdefaultZus{}creg}\PYGdefault{p}{(}\PYGdefault{n}{spec\PYGdefaultZus{}regs\PYGdefaultZus{}C}\PYGdefault{p}{,} \PYGdefault{n}{i}\PYGdefault{p}{,} \PYGdefault{n}{stream}\PYGdefault{p}{);}
	  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/* speculative memory hash table size, NOTE: this must be a power\PYGdefaultZhy{}of\PYGdefaultZhy{}two */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define STORE\PYGdefaultZus{}HASH\PYGdefaultZus{}SIZE		32}

\PYGdefault{c+cm}{/* speculative memory hash table definition, accesses go through this hash}
\PYGdefault{c+cm}{   table when accessing memory in speculative mode, the hash table flush the}
\PYGdefault{c+cm}{   table when recovering from mispredicted branches */}
\PYGdefault{k}{struct} \PYGdefault{n}{spec\PYGdefaultZus{}mem\PYGdefaultZus{}ent} \PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{struct} \PYGdefault{n}{spec\PYGdefaultZus{}mem\PYGdefaultZus{}ent} \PYGdefault{o}{*}\PYGdefault{n}{next}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* ptr to next hash table bucket */}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{addr}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* virtual address of spec state */}
  \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{];}			\PYGdefault{c+cm}{/* spec buffer, up to 8 bytes */}
\PYGdefault{p}{\PYGdefaultZcb{};}

\PYGdefault{c+cm}{/* speculative memory hash table */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{spec\PYGdefaultZus{}mem\PYGdefaultZus{}ent} \PYGdefault{o}{*}\PYGdefault{n}{store\PYGdefaultZus{}htable}\PYGdefault{p}{[}\PYGdefault{n}{STORE\PYGdefaultZus{}HASH\PYGdefaultZus{}SIZE}\PYGdefault{p}{];}

\PYGdefault{c+cm}{/* speculative memory hash table bucket free list */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{spec\PYGdefaultZus{}mem\PYGdefaultZus{}ent} \PYGdefault{o}{*}\PYGdefault{n}{bucket\PYGdefaultZus{}free\PYGdefaultZus{}list} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}


\PYGdefault{c+cm}{/* program counter */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{pred\PYGdefaultZus{}PC}\PYGdefault{p}{;}
\PYGdefault{k}{static} \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{recover\PYGdefaultZus{}PC}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* fetch unit next fetch address */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC}\PYGdefault{p}{;}
\PYGdefault{k}{static} \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* IFETCH \PYGdefaultZhy{}\PYGdefaultZgt{} DISPATCH instruction queue definition */}
\PYGdefault{k}{struct} \PYGdefault{n}{fetch\PYGdefaultZus{}rec} \PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t} \PYGdefault{n}{IR}\PYGdefault{p}{;}				\PYGdefault{c+cm}{/* inst register */}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{pred\PYGdefaultZus{}PC}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* current PC, predicted next PC */}
  \PYGdefault{k}{struct} \PYGdefault{k+kt}{bpred\PYGdefaultZus{}update\PYGdefaultZus{}t} \PYGdefault{n}{dir\PYGdefaultZus{}update}\PYGdefault{p}{;}	\PYGdefault{c+cm}{/* bpred direction update info */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* branch predictor RSB index */}
  \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* print trace sequence id */}
\PYGdefault{p}{\PYGdefaultZcb{};}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{fetch\PYGdefaultZus{}rec} \PYGdefault{o}{*}\PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{;}	\PYGdefault{c+cm}{/* IFETCH \PYGdefaultZhy{}\PYGdefaultZgt{} DISPATCH inst queue */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{fetch\PYGdefaultZus{}num}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* num entries in IF \PYGdefaultZhy{}\PYGdefaultZgt{} DIS queue */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{fetch\PYGdefaultZus{}tail}\PYGdefault{p}{,} \PYGdefault{n}{fetch\PYGdefaultZus{}head}\PYGdefault{p}{;}	\PYGdefault{c+cm}{/* head and tail pointers of queue */}

\PYGdefault{c+cm}{/* recover instruction trace generator state to precise state state immediately}
\PYGdefault{c+cm}{   before the first mis\PYGdefaultZhy{}predicted branch; this is accomplished by resetting}
\PYGdefault{c+cm}{   all register value copied\PYGdefaultZhy{}on\PYGdefaultZhy{}write bitmasks are reset, and the speculative}
\PYGdefault{c+cm}{   memory hash table is cleared */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{tracer\PYGdefaultZus{}recover}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{;}
  \PYGdefault{k}{struct} \PYGdefault{n}{spec\PYGdefaultZus{}mem\PYGdefaultZus{}ent} \PYGdefault{o}{*}\PYGdefault{n}{ent}\PYGdefault{p}{,} \PYGdefault{o}{*}\PYGdefault{n}{ent\PYGdefaultZus{}next}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* better be in mis\PYGdefaultZhy{}speculative trace generation mode */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{spec\PYGdefaultZus{}mode}\PYGdefault{p}{)}
    \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}cannot recover unless in speculative mode\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* reset to non\PYGdefaultZhy{}speculative trace generation mode */}
  \PYGdefault{n}{spec\PYGdefaultZus{}mode} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* reset copied\PYGdefaultZhy{}on\PYGdefaultZhy{}write register bitmasks back to non\PYGdefaultZhy{}speculative state */}
  \PYGdefault{n}{BITMAP\PYGdefaultZus{}CLEAR\PYGdefaultZus{}MAP}\PYGdefault{p}{(}\PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}R}\PYGdefault{p}{,} \PYGdefault{n}{R\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ}\PYGdefault{p}{);}
  \PYGdefault{n}{BITMAP\PYGdefaultZus{}CLEAR\PYGdefaultZus{}MAP}\PYGdefault{p}{(}\PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}F}\PYGdefault{p}{,} \PYGdefault{n}{F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ}\PYGdefault{p}{);}
  \PYGdefault{n}{BITMAP\PYGdefaultZus{}CLEAR\PYGdefaultZus{}MAP}\PYGdefault{p}{(}\PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}C}\PYGdefault{p}{,} \PYGdefault{n}{C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* reset memory state back to non\PYGdefaultZhy{}speculative state */}
  \PYGdefault{c+cm}{/* FIXME: could version stamps be used here?!?!? */}
  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{STORE\PYGdefaultZus{}HASH\PYGdefaultZus{}SIZE}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* release all hash table buckets */}
      \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{ent}\PYGdefault{o}{=}\PYGdefault{n}{store\PYGdefaultZus{}htable}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{];} \PYGdefault{n}{ent}\PYGdefault{p}{;} \PYGdefault{n}{ent}\PYGdefault{o}{=}\PYGdefault{n}{ent\PYGdefaultZus{}next}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{n}{ent\PYGdefaultZus{}next} \PYGdefault{o}{=} \PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{;}
	  \PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next} \PYGdefault{o}{=} \PYGdefault{n}{bucket\PYGdefaultZus{}free\PYGdefaultZus{}list}\PYGdefault{p}{;}
	  \PYGdefault{n}{bucket\PYGdefaultZus{}free\PYGdefaultZus{}list} \PYGdefault{o}{=} \PYGdefault{n}{ent}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{n}{store\PYGdefaultZus{}htable}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* if pipetracing, indicate squash of instructions in the inst fetch queue */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ptrace\PYGdefaultZus{}active}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{while} \PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}num} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* squash the next instruction from the IFETCH \PYGdefaultZhy{}\PYGdefaultZgt{} DISPATCH queue */}
	  \PYGdefault{n}{ptrace\PYGdefaultZus{}endinst}\PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* consume instruction from IFETCH \PYGdefaultZhy{}\PYGdefaultZgt{} DISPATCH queue */}
	  \PYGdefault{n}{fetch\PYGdefaultZus{}head} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}head}\PYGdefault{o}{+}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{);}
	  \PYGdefault{n}{fetch\PYGdefaultZus{}num}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZhy{}}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* reset IFETCH state */}
  \PYGdefault{n}{fetch\PYGdefaultZus{}num} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{n}{fetch\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}head} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{n}{fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{recover\PYGdefaultZus{}PC}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* initialize the speculative instruction state generator state */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{tracer\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* initially in non\PYGdefaultZhy{}speculative mode */}
  \PYGdefault{n}{spec\PYGdefaultZus{}mode} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* register state is from non\PYGdefaultZhy{}speculative state buffers */}
  \PYGdefault{n}{BITMAP\PYGdefaultZus{}CLEAR\PYGdefaultZus{}MAP}\PYGdefault{p}{(}\PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}R}\PYGdefault{p}{,} \PYGdefault{n}{R\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ}\PYGdefault{p}{);}
  \PYGdefault{n}{BITMAP\PYGdefaultZus{}CLEAR\PYGdefaultZus{}MAP}\PYGdefault{p}{(}\PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}F}\PYGdefault{p}{,} \PYGdefault{n}{F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ}\PYGdefault{p}{);}
  \PYGdefault{n}{BITMAP\PYGdefaultZus{}CLEAR\PYGdefaultZus{}MAP}\PYGdefault{p}{(}\PYGdefault{n}{use\PYGdefaultZus{}spec\PYGdefaultZus{}C}\PYGdefault{p}{,} \PYGdefault{n}{C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* memory state is from non\PYGdefaultZhy{}speculative memory pages */}
  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{STORE\PYGdefaultZus{}HASH\PYGdefaultZus{}SIZE}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
    \PYGdefault{n}{store\PYGdefaultZus{}htable}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/* speculative memory hash table address hash function */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define HASH\PYGdefaultZus{}ADDR(ADDR)							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  ((((ADDR) \PYGdefaultZgt{}\PYGdefaultZgt{} 24)\PYGdefaultZca{}((ADDR) \PYGdefaultZgt{}\PYGdefaultZgt{} 16)\PYGdefaultZca{}((ADDR) \PYGdefaultZgt{}\PYGdefaultZgt{} 8)\PYGdefaultZca{}(ADDR)) \PYGdefaultZam{} (STORE\PYGdefaultZus{}HASH\PYGdefaultZus{}SIZE\PYGdefaultZhy{}1))}

\PYGdefault{c+cm}{/* this functional provides a layer of mis\PYGdefaultZhy{}speculated state over the}
\PYGdefault{c+cm}{   non\PYGdefaultZhy{}speculative memory state, when in mis\PYGdefaultZhy{}speculation trace generation mode,}
\PYGdefault{c+cm}{   the simulator will call this function to access memory, instead of the}
\PYGdefault{c+cm}{   non\PYGdefaultZhy{}speculative memory access interfaces defined in memory.h; when storage}
\PYGdefault{c+cm}{   is written, an entry is allocated in the speculative memory hash table,}
\PYGdefault{c+cm}{   future reads and writes while in mis\PYGdefaultZhy{}speculative trace generation mode will}
\PYGdefault{c+cm}{   access this buffer instead of non\PYGdefaultZhy{}speculative memory state; when the trace}
\PYGdefault{c+cm}{   generator transitions back to non\PYGdefaultZhy{}speculative trace generation mode,}
\PYGdefault{c+cm}{   tracer\PYGdefaultZus{}recover() clears this table, returns any access fault */}
\PYGdefault{k}{static} \PYGdefault{k}{enum} \PYGdefault{n}{md\PYGdefaultZus{}fault\PYGdefaultZus{}type}
\PYGdefault{n+nf}{spec\PYGdefaultZus{}mem\PYGdefaultZus{}access}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{k+kt}{mem\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{mem}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* memory space to access */}
		\PYGdefault{k}{enum} \PYGdefault{n}{mem\PYGdefaultZus{}cmd} \PYGdefault{n}{cmd}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* Read or Write access cmd */}
		\PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{addr}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* virtual address of access */}
		\PYGdefault{k+kt}{void} \PYGdefault{o}{*}\PYGdefault{n}{p}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* input/output buffer */}
		\PYGdefault{k+kt}{int} \PYGdefault{n}{nbytes}\PYGdefault{p}{)}			\PYGdefault{c+cm}{/* number of bytes to access */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{,} \PYGdefault{n}{index}\PYGdefault{p}{;}
  \PYGdefault{k}{struct} \PYGdefault{n}{spec\PYGdefaultZus{}mem\PYGdefaultZus{}ent} \PYGdefault{o}{*}\PYGdefault{n}{ent}\PYGdefault{p}{,} \PYGdefault{o}{*}\PYGdefault{n}{prev}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* FIXME: partially overlapping writes are not combined... */}
  \PYGdefault{c+cm}{/* FIXME: partially overlapping reads are not handled correctly... */}

  \PYGdefault{c+cm}{/* check alignments, even speculative this test should always pass */}
  \PYGdefault{k}{if} \PYGdefault{p}{((}\PYGdefault{n}{nbytes} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{nbytes}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{0} \PYGdefault{o}{||} \PYGdefault{p}{(}\PYGdefault{n}{addr} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{nbytes}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{))} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* no can do, return zero result */}
      \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{nbytes}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
	\PYGdefault{p}{((}\PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

      \PYGdefault{k}{return} \PYGdefault{n}{md\PYGdefaultZus{}fault\PYGdefaultZus{}none}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* check permissions */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{p}{((}\PYGdefault{n}{addr} \PYGdefault{o}{\PYGdefaultZgt{}=} \PYGdefault{n}{ld\PYGdefaultZus{}text\PYGdefaultZus{}base} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{addr} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{p}{(}\PYGdefault{n}{ld\PYGdefaultZus{}text\PYGdefaultZus{}base}\PYGdefault{o}{+}\PYGdefault{n}{ld\PYGdefaultZus{}text\PYGdefaultZus{}size}\PYGdefault{p}{)}
	 \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{cmd} \PYGdefault{o}{==} \PYGdefault{n}{Read}\PYGdefault{p}{)}
	\PYGdefault{o}{||} \PYGdefault{n}{MD\PYGdefaultZus{}VALID\PYGdefaultZus{}ADDR}\PYGdefault{p}{(}\PYGdefault{n}{addr}\PYGdefault{p}{)))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* no can do, return zero result */}
      \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{nbytes}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
	\PYGdefault{p}{((}\PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

      \PYGdefault{k}{return} \PYGdefault{n}{md\PYGdefaultZus{}fault\PYGdefaultZus{}none}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* has this memory state been copied on mis\PYGdefaultZhy{}speculative write? */}
  \PYGdefault{n}{index} \PYGdefault{o}{=} \PYGdefault{n}{HASH\PYGdefaultZus{}ADDR}\PYGdefault{p}{(}\PYGdefault{n}{addr}\PYGdefault{p}{);}
  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{prev}\PYGdefault{o}{=}\PYGdefault{n+nb}{NULL}\PYGdefault{p}{,}\PYGdefault{n}{ent}\PYGdefault{o}{=}\PYGdefault{n}{store\PYGdefaultZus{}htable}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{];} \PYGdefault{n}{ent}\PYGdefault{p}{;} \PYGdefault{n}{prev}\PYGdefault{o}{=}\PYGdefault{n}{ent}\PYGdefault{p}{,}\PYGdefault{n}{ent}\PYGdefault{o}{=}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{addr} \PYGdefault{o}{==} \PYGdefault{n}{addr}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* reorder chains to speed access into hash table */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{prev} \PYGdefault{o}{!=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* not at head of list, relink the hash table entry at front */}
	      \PYGdefault{n}{prev}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next} \PYGdefault{o}{=} \PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{;}
              \PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next} \PYGdefault{o}{=} \PYGdefault{n}{store\PYGdefaultZus{}htable}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{];}
              \PYGdefault{n}{store\PYGdefaultZus{}htable}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{ent}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	  \PYGdefault{k}{break}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* no, if it is a write, allocate a hash table entry to hold the data */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{ent} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{cmd} \PYGdefault{o}{==} \PYGdefault{n}{Write}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* try to get an entry from the free list, if available */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{bucket\PYGdefaultZus{}free\PYGdefaultZus{}list}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* otherwise, call calloc() to get the needed storage */}
	  \PYGdefault{n}{bucket\PYGdefaultZus{}free\PYGdefaultZus{}list} \PYGdefault{o}{=} \PYGdefault{n}{calloc}\PYGdefault{p}{(}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{n}{spec\PYGdefaultZus{}mem\PYGdefaultZus{}ent}\PYGdefault{p}{));}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{bucket\PYGdefaultZus{}free\PYGdefaultZus{}list}\PYGdefault{p}{)}
	    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}out of virtual memory\PYGdefaultZdq{}}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{n}{ent} \PYGdefault{o}{=} \PYGdefault{n}{bucket\PYGdefaultZus{}free\PYGdefaultZus{}list}\PYGdefault{p}{;}
      \PYGdefault{n}{bucket\PYGdefaultZus{}free\PYGdefaultZus{}list} \PYGdefault{o}{=} \PYGdefault{n}{bucket\PYGdefaultZus{}free\PYGdefaultZus{}list}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{;}

      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{bugcompat\PYGdefaultZus{}mode}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* insert into hash table */}
	  \PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next} \PYGdefault{o}{=} \PYGdefault{n}{store\PYGdefaultZus{}htable}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{];}
	  \PYGdefault{n}{store\PYGdefaultZus{}htable}\PYGdefault{p}{[}\PYGdefault{n}{index}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{ent}\PYGdefault{p}{;}
	  \PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{addr} \PYGdefault{o}{=} \PYGdefault{n}{addr}\PYGdefault{p}{;}
	  \PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* handle the read or write to speculative or non\PYGdefaultZhy{}speculative storage */}
  \PYGdefault{k}{switch} \PYGdefault{p}{(}\PYGdefault{n}{nbytes}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
    \PYGdefault{k}{case} \PYGdefault{l+m+mi}{1}\PYGdefault{o}{:}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cmd} \PYGdefault{o}{==} \PYGdefault{n}{Read}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ent}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* read from mis\PYGdefaultZhy{}speculated state buffer */}
	      \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{byte\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)} \PYGdefault{o}{=} \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{byte\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]));}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	  \PYGdefault{k}{else}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* read from non\PYGdefaultZhy{}speculative memory state, don\PYGdefaultZsq{}t allocate}
\PYGdefault{c+cm}{	         memory pages with speculative loads */}
	      \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{byte\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)} \PYGdefault{o}{=} \PYGdefault{n}{MEM\PYGdefaultZus{}READ\PYGdefaultZus{}BYTE}\PYGdefault{p}{(}\PYGdefault{n}{mem}\PYGdefault{p}{,} \PYGdefault{n}{addr}\PYGdefault{p}{);}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{else}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* always write into mis\PYGdefaultZhy{}speculated state buffer */}
	  \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{byte\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]))} \PYGdefault{o}{=} \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{byte\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{break}\PYGdefault{p}{;}
    \PYGdefault{k}{case} \PYGdefault{l+m+mi}{2}\PYGdefault{o}{:}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cmd} \PYGdefault{o}{==} \PYGdefault{n}{Read}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ent}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* read from mis\PYGdefaultZhy{}speculated state buffer */}
	      \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{half\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)} \PYGdefault{o}{=} \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{half\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]));}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	  \PYGdefault{k}{else}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* read from non\PYGdefaultZhy{}speculative memory state, don\PYGdefaultZsq{}t allocate}
\PYGdefault{c+cm}{	         memory pages with speculative loads */}
	      \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{half\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)} \PYGdefault{o}{=} \PYGdefault{n}{MEM\PYGdefaultZus{}READ\PYGdefaultZus{}HALF}\PYGdefault{p}{(}\PYGdefault{n}{mem}\PYGdefault{p}{,} \PYGdefault{n}{addr}\PYGdefault{p}{);}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{else}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* always write into mis\PYGdefaultZhy{}speculated state buffer */}
	  \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{half\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{])} \PYGdefault{o}{=} \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{half\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{break}\PYGdefault{p}{;}
    \PYGdefault{k}{case} \PYGdefault{l+m+mi}{4}\PYGdefault{o}{:}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cmd} \PYGdefault{o}{==} \PYGdefault{n}{Read}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ent}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* read from mis\PYGdefaultZhy{}speculated state buffer */}
	      \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)} \PYGdefault{o}{=} \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]);}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	  \PYGdefault{k}{else}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* read from non\PYGdefaultZhy{}speculative memory state, don\PYGdefaultZsq{}t allocate}
\PYGdefault{c+cm}{	         memory pages with speculative loads */}
	      \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)} \PYGdefault{o}{=} \PYGdefault{n}{MEM\PYGdefaultZus{}READ\PYGdefaultZus{}WORD}\PYGdefault{p}{(}\PYGdefault{n}{mem}\PYGdefault{p}{,} \PYGdefault{n}{addr}\PYGdefault{p}{);}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{else}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* always write into mis\PYGdefaultZhy{}speculated state buffer */}
	  \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{])} \PYGdefault{o}{=} \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{break}\PYGdefault{p}{;}
    \PYGdefault{k}{case} \PYGdefault{l+m+mi}{8}\PYGdefault{o}{:}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cmd} \PYGdefault{o}{==} \PYGdefault{n}{Read}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ent}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* read from mis\PYGdefaultZhy{}speculated state buffer */}
	      \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)} \PYGdefault{o}{=} \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]);}
	      \PYGdefault{o}{*}\PYGdefault{p}{(((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)}\PYGdefault{o}{+}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{=} \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{]);}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	  \PYGdefault{k}{else}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* read from non\PYGdefaultZhy{}speculative memory state, don\PYGdefaultZsq{}t allocate}
\PYGdefault{c+cm}{	         memory pages with speculative loads */}
	      \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)} \PYGdefault{o}{=} \PYGdefault{n}{MEM\PYGdefaultZus{}READ\PYGdefaultZus{}WORD}\PYGdefault{p}{(}\PYGdefault{n}{mem}\PYGdefault{p}{,} \PYGdefault{n}{addr}\PYGdefault{p}{);}
	      \PYGdefault{o}{*}\PYGdefault{p}{(((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)}\PYGdefault{o}{+}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{=}
		\PYGdefault{n}{MEM\PYGdefaultZus{}READ\PYGdefaultZus{}WORD}\PYGdefault{p}{(}\PYGdefault{n}{mem}\PYGdefault{p}{,} \PYGdefault{n}{addr} \PYGdefault{o}{+} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{word\PYGdefaultZus{}t}\PYGdefault{p}{));}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{else}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* always write into mis\PYGdefaultZhy{}speculated state buffer */}
	  \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{])} \PYGdefault{o}{=} \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{);}
	  \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{])} \PYGdefault{o}{=} \PYGdefault{o}{*}\PYGdefault{p}{(((}\PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{p}\PYGdefault{p}{)}\PYGdefault{o}{+}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{break}\PYGdefault{p}{;}
    \PYGdefault{k}{default}\PYGdefault{o}{:}
      \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}access size not supported in mis\PYGdefaultZhy{}speculative mode\PYGdefaultZdq{}}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{k}{return} \PYGdefault{n}{md\PYGdefaultZus{}fault\PYGdefaultZus{}none}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* dump speculative memory state */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{mspec\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{)}			\PYGdefault{c+cm}{/* output stream */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{;}
  \PYGdefault{k}{struct} \PYGdefault{n}{spec\PYGdefaultZus{}mem\PYGdefaultZus{}ent} \PYGdefault{o}{*}\PYGdefault{n}{ent}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{stream}\PYGdefault{p}{)}
    \PYGdefault{n}{stream} \PYGdefault{o}{=} \PYGdefault{n}{stderr}\PYGdefault{p}{;}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}** speculative memory contents **}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}spec\PYGdefaultZus{}mode: \PYGdefaultZpc{}s}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{spec\PYGdefaultZus{}mode} \PYGdefault{o}{?} \PYGdefault{l+s}{\PYGdefaultZdq{}t\PYGdefaultZdq{}} \PYGdefault{o}{:} \PYGdefault{l+s}{\PYGdefaultZdq{}f\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{STORE\PYGdefaultZus{}HASH\PYGdefaultZus{}SIZE}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* dump contents of all hash table buckets */}
      \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{ent}\PYGdefault{o}{=}\PYGdefault{n}{store\PYGdefaultZus{}htable}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{];} \PYGdefault{n}{ent}\PYGdefault{p}{;} \PYGdefault{n}{ent}\PYGdefault{o}{=}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{n}{myfprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}[0x\PYGdefaultZpc{}08p]: \PYGdefaultZpc{}12.0f/0x\PYGdefaultZpc{}08x:\PYGdefaultZpc{}08x}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
		    \PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{addr}\PYGdefault{p}{,} \PYGdefault{p}{(}\PYGdefault{k+kt}{double}\PYGdefault{p}{)(}\PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{double} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{)),}
		    \PYGdefault{o}{*}\PYGdefault{p}{((}\PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{]),}
		    \PYGdefault{o}{*}\PYGdefault{p}{(((}\PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{ent}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{data}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{])} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{));}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* default memory state accessor, used by DLite */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}					\PYGdefault{c+cm}{/* err str, NULL for no err */}
\PYGdefault{n}{simoo\PYGdefaultZus{}mem\PYGdefaultZus{}obj}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{k+kt}{mem\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{mem}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* memory space to access */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{is\PYGdefaultZus{}write}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* access type */}
	      \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{addr}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* address to access */}
	      \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{p}\PYGdefault{p}{,}				\PYGdefault{c+cm}{/* input/output buffer */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{nbytes}\PYGdefault{p}{)}			\PYGdefault{c+cm}{/* size of access */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{enum} \PYGdefault{n}{mem\PYGdefaultZus{}cmd} \PYGdefault{n}{cmd}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{is\PYGdefaultZus{}write}\PYGdefault{p}{)}
    \PYGdefault{n}{cmd} \PYGdefault{o}{=} \PYGdefault{n}{Read}\PYGdefault{p}{;}
  \PYGdefault{k}{else}
    \PYGdefault{n}{cmd} \PYGdefault{o}{=} \PYGdefault{n}{Write}\PYGdefault{p}{;}

\PYGdefault{c+cp}{\PYGdefaultZsh{}if 0}
\PYGdefault{c}{  char *errstr;}

\PYGdefault{c}{  errstr = mem\PYGdefaultZus{}valid(cmd, addr, nbytes, /* declare */FALSE);}
\PYGdefault{c}{  if (errstr)}
\PYGdefault{c}{    return errstr;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

  \PYGdefault{c+cm}{/* else, no error, access memory */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{spec\PYGdefaultZus{}mode}\PYGdefault{p}{)}
    \PYGdefault{n}{spec\PYGdefaultZus{}mem\PYGdefaultZus{}access}\PYGdefault{p}{(}\PYGdefault{n}{mem}\PYGdefault{p}{,} \PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{n}{addr}\PYGdefault{p}{,} \PYGdefault{n}{p}\PYGdefault{p}{,} \PYGdefault{n}{nbytes}\PYGdefault{p}{);}
  \PYGdefault{k}{else}
    \PYGdefault{n+nf}{mem\PYGdefaultZus{}access}\PYGdefault{p}{(}\PYGdefault{n}{mem}\PYGdefault{p}{,} \PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{n}{addr}\PYGdefault{p}{,} \PYGdefault{n}{p}\PYGdefault{p}{,} \PYGdefault{n}{nbytes}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* no error */}
  \PYGdefault{k}{return} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ *  RUU\PYGdefaultZus{}DISPATCH() \PYGdefaultZhy{} decode instructions and allocate RUU and LSQ resources}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* link RS onto the output chain number of whichever operation will next}
\PYGdefault{c+cm}{   create the architected register value IDEP\PYGdefaultZus{}NAME */}
\PYGdefault{k}{static} \PYGdefault{n}{INLINE} \PYGdefault{k+kt}{void}
\PYGdefault{n}{ruu\PYGdefaultZus{}link\PYGdefaultZus{}idep}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* rs station to link */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{idep\PYGdefaultZus{}num}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* input dependence number */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{idep\PYGdefaultZus{}name}\PYGdefault{p}{)}			\PYGdefault{c+cm}{/* input register name */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{struct} \PYGdefault{n}{CV\PYGdefaultZus{}link} \PYGdefault{n}{head}\PYGdefault{p}{;}
  \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{o}{*}\PYGdefault{n}{link}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* any dependence? */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{idep\PYGdefaultZus{}name} \PYGdefault{o}{==} \PYGdefault{n}{NA}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* no input dependence for this input slot, mark operand as ready */}
      \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{idep\PYGdefaultZus{}ready}\PYGdefault{p}{[}\PYGdefault{n}{idep\PYGdefaultZus{}num}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
      \PYGdefault{k}{return}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* locate creator of operand */}
  \PYGdefault{n}{head} \PYGdefault{o}{=} \PYGdefault{n}{CREATE\PYGdefaultZus{}VECTOR}\PYGdefault{p}{(}\PYGdefault{n}{idep\PYGdefaultZus{}name}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* any creator? */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{head}\PYGdefault{p}{.}\PYGdefault{n}{rs}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* no active creator, use value available in architected reg file,}
\PYGdefault{c+cm}{         indicate the operand is ready for use */}
      \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{idep\PYGdefaultZus{}ready}\PYGdefault{p}{[}\PYGdefault{n}{idep\PYGdefaultZus{}num}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} regfile access (value from arch regfile) */}
      \PYGdefault{n}{regfile\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef DYNAMIC\PYGdefaultZus{}AF	}
      \PYGdefault{k}{if}\PYGdefault{p}{(}\PYGdefault{n}{idep\PYGdefaultZus{}num} \PYGdefault{o}{==} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
	\PYGdefault{n}{regfile\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra}\PYGdefault{p}{);}
      \PYGdefault{k}{else}
	\PYGdefault{n}{regfile\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rb}\PYGdefault{p}{);}
      \PYGdefault{n}{regfile\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

      \PYGdefault{k}{return}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{c+cm}{/* else, creator operation will make this value sometime in the future */}

  \PYGdefault{c+cm}{/* indicate value will be created sometime in the future, i.e., operand}
\PYGdefault{c+cm}{     is not yet ready for use */}
  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{idep\PYGdefaultZus{}ready}\PYGdefault{p}{[}\PYGdefault{n}{idep\PYGdefaultZus{}num}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* link onto creator\PYGdefaultZsq{}s output list of dependant operand */}
  \PYGdefault{n}{RSLINK\PYGdefaultZus{}NEW}\PYGdefault{p}{(}\PYGdefault{n}{link}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{p}{);} \PYGdefault{n}{link}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{x}\PYGdefault{p}{.}\PYGdefault{n}{opnum} \PYGdefault{o}{=} \PYGdefault{n}{idep\PYGdefaultZus{}num}\PYGdefault{p}{;}
  \PYGdefault{n}{link}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next} \PYGdefault{o}{=} \PYGdefault{n}{head}\PYGdefault{p}{.}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{odep\PYGdefaultZus{}list}\PYGdefault{p}{[}\PYGdefault{n}{head}\PYGdefault{p}{.}\PYGdefault{n}{odep\PYGdefaultZus{}num}\PYGdefault{p}{];}
  \PYGdefault{n}{head}\PYGdefault{p}{.}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{odep\PYGdefaultZus{}list}\PYGdefault{p}{[}\PYGdefault{n}{head}\PYGdefault{p}{.}\PYGdefault{n}{odep\PYGdefaultZus{}num}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{link}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* make RS the creator of architected register ODEP\PYGdefaultZus{}NAME */}
\PYGdefault{k}{static} \PYGdefault{n}{INLINE} \PYGdefault{k+kt}{void}
\PYGdefault{n}{ruu\PYGdefaultZus{}install\PYGdefaultZus{}odep}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs}\PYGdefault{p}{,}	\PYGdefault{c+cm}{/* creating RUU station */}
		 \PYGdefault{k+kt}{int} \PYGdefault{n}{odep\PYGdefaultZus{}num}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* output operand number */}
		 \PYGdefault{k+kt}{int} \PYGdefault{n}{odep\PYGdefaultZus{}name}\PYGdefault{p}{)}			\PYGdefault{c+cm}{/* output register name */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{struct} \PYGdefault{n}{CV\PYGdefaultZus{}link} \PYGdefault{n}{cv}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* any dependence? */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{odep\PYGdefaultZus{}name} \PYGdefault{o}{==} \PYGdefault{n}{NA}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* no value created */}
      \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{onames}\PYGdefault{p}{[}\PYGdefault{n}{odep\PYGdefaultZus{}num}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{NA}\PYGdefault{p}{;}
      \PYGdefault{k}{return}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{c+cm}{/* else, create a RS\PYGdefaultZus{}NULL terminated output chain in create vector */}

  \PYGdefault{c+cm}{/* record output name, used to update create vector at completion */}
  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{onames}\PYGdefault{p}{[}\PYGdefault{n}{odep\PYGdefaultZus{}num}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{odep\PYGdefaultZus{}name}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* initialize output chain to empty list */}
  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{odep\PYGdefaultZus{}list}\PYGdefault{p}{[}\PYGdefault{n}{odep\PYGdefaultZus{}num}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* indicate this operation is latest creator of ODEP\PYGdefaultZus{}NAME */}
  \PYGdefault{n}{CVLINK\PYGdefaultZus{}INIT}\PYGdefault{p}{(}\PYGdefault{n}{cv}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{n}{odep\PYGdefaultZus{}num}\PYGdefault{p}{);}
  \PYGdefault{n}{SET\PYGdefaultZus{}CREATE\PYGdefaultZus{}VECTOR}\PYGdefault{p}{(}\PYGdefault{n}{odep\PYGdefaultZus{}name}\PYGdefault{p}{,} \PYGdefault{n}{cv}\PYGdefault{p}{);}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * configure the instruction decode engine}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cp}{\PYGdefaultZsh{}define DNA			(0)}

\PYGdefault{c+cp}{\PYGdefaultZsh{}if defined(TARGET\PYGdefaultZus{}PISA)}

\PYGdefault{c+cm}{/* general register dependence decoders */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DGPR(N)			(N)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DGPR\PYGdefaultZus{}D(N)		((N) \PYGdefaultZam{}\PYGdefaultZti{}1)}

\PYGdefault{c+cm}{/* floating point register dependence decoders */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DFPR\PYGdefaultZus{}L(N)		(((N)+32)\PYGdefaultZam{}\PYGdefaultZti{}1)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DFPR\PYGdefaultZus{}F(N)		(((N)+32)\PYGdefaultZam{}\PYGdefaultZti{}1)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DFPR\PYGdefaultZus{}D(N)		(((N)+32)\PYGdefaultZam{}\PYGdefaultZti{}1)}

\PYGdefault{c+cm}{/* miscellaneous register dependence decoders */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DHI			(0+32+32)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DLO			(1+32+32)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DFCC			(2+32+32)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DTMP			(3+32+32)}

\PYGdefault{c+cp}{\PYGdefaultZsh{}elif defined(TARGET\PYGdefaultZus{}ALPHA)}

\PYGdefault{c+cm}{/* general register dependence decoders, \PYGdefaultZdl{}r31 maps to DNA (0) */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DGPR(N)			(31 \PYGdefaultZhy{} (N)) }\PYGdefault{c+cm}{/* was: (((N) == 31) ? DNA : (N)) */}

\PYGdefault{c+cm}{/* floating point register dependence decoders */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DFPR(N)			(((N) == 31) ? DNA : ((N)+32))}

\PYGdefault{c+cm}{/* miscellaneous register dependence decoders */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DFPCR			(0+32+32)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DUNIQ			(1+32+32)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DTMP			(2+32+32)}

\PYGdefault{c+cp}{\PYGdefaultZsh{}else}
\PYGdefault{c+cp}{\PYGdefaultZsh{}error No ISA target defined...}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ * configure the execution engine}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* next program counter */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}NPC(EXPR)           (regs.regs\PYGdefaultZus{}NPC = (EXPR))}

\PYGdefault{c+cm}{/* target program counter */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}undef  SET\PYGdefaultZus{}TPC}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}TPC(EXPR)		(target\PYGdefaultZus{}PC = (EXPR))}

\PYGdefault{c+cm}{/* current program counter */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define CPC                     (regs.regs\PYGdefaultZus{}PC)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}CPC(EXPR)           (regs.regs\PYGdefaultZus{}PC = (EXPR))}

\PYGdefault{c+cm}{/* general purpose register accessors, NOTE: speculative copy on write storage}
\PYGdefault{c+cm}{   provided for fast recovery during wrong path execute (see tracer\PYGdefaultZus{}recover()}
\PYGdefault{c+cm}{   for details on this process */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define GPR(N)                  (BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}R, R\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, (N))\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}regs\PYGdefaultZus{}R[N]                       \PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : regs.regs\PYGdefaultZus{}R[N])}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}GPR(N,EXPR)         (spec\PYGdefaultZus{}mode				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? ((spec\PYGdefaultZus{}regs\PYGdefaultZus{}R[N] = (EXPR)),		\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}R, R\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, (N)),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}regs\PYGdefaultZus{}R[N])			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (regs.regs\PYGdefaultZus{}R[N] = (EXPR)))}

\PYGdefault{c+cp}{\PYGdefaultZsh{}if defined(TARGET\PYGdefaultZus{}PISA)}

\PYGdefault{c+cm}{/* floating point register accessors, NOTE: speculative copy on write storage}
\PYGdefault{c+cm}{   provided for fast recovery during wrong path execute (see tracer\PYGdefaultZus{}recover()}
\PYGdefault{c+cm}{   for details on this process */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FPR\PYGdefaultZus{}L(N)                (BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}F, F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, ((N)\PYGdefaultZam{}\PYGdefaultZti{}1))\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.l[(N)]                   \PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : regs.regs\PYGdefaultZus{}F.l[(N)])}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}FPR\PYGdefaultZus{}L(N,EXPR)       (spec\PYGdefaultZus{}mode				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? ((spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.l[(N)] = (EXPR)),	\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}F,F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,((N)\PYGdefaultZam{}\PYGdefaultZti{}1)),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.l[(N)])			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (regs.regs\PYGdefaultZus{}F.l[(N)] = (EXPR)))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FPR\PYGdefaultZus{}F(N)                (BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}F, F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, ((N)\PYGdefaultZam{}\PYGdefaultZti{}1))\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.f[(N)]                   \PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : regs.regs\PYGdefaultZus{}F.f[(N)])}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}FPR\PYGdefaultZus{}F(N,EXPR)       (spec\PYGdefaultZus{}mode				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? ((spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.f[(N)] = (EXPR)),	\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}F,F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,((N)\PYGdefaultZam{}\PYGdefaultZti{}1)),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.f[(N)])			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (regs.regs\PYGdefaultZus{}F.f[(N)] = (EXPR)))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FPR\PYGdefaultZus{}D(N)                (BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}F, F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, ((N)\PYGdefaultZam{}\PYGdefaultZti{}1))\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.d[(N) \PYGdefaultZgt{}\PYGdefaultZgt{} 1]              \PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : regs.regs\PYGdefaultZus{}F.d[(N) \PYGdefaultZgt{}\PYGdefaultZgt{} 1])}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}FPR\PYGdefaultZus{}D(N,EXPR)       (spec\PYGdefaultZus{}mode				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? ((spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.d[(N) \PYGdefaultZgt{}\PYGdefaultZgt{} 1] = (EXPR)),	\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}F,F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,((N)\PYGdefaultZam{}\PYGdefaultZti{}1)),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.d[(N) \PYGdefaultZgt{}\PYGdefaultZgt{} 1])		\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (regs.regs\PYGdefaultZus{}F.d[(N) \PYGdefaultZgt{}\PYGdefaultZgt{} 1] = (EXPR)))}

\PYGdefault{c+cm}{/* miscellanous register accessors, NOTE: speculative copy on write storage}
\PYGdefault{c+cm}{   provided for fast recovery during wrong path execute (see tracer\PYGdefaultZus{}recover()}
\PYGdefault{c+cm}{   for details on this process */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define HI			(BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}C, C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, }\PYGdefault{c+cm}{/*hi*/}\PYGdefault{c+cp}{0)\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.hi			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : regs.regs\PYGdefaultZus{}C.hi)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}HI(EXPR)		(spec\PYGdefaultZus{}mode				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? ((spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.hi = (EXPR)),		\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}C, C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,}\PYGdefault{c+cm}{/*hi*/}\PYGdefault{c+cp}{0),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.hi)			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (regs.regs\PYGdefaultZus{}C.hi = (EXPR)))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define LO			(BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}C, C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, }\PYGdefault{c+cm}{/*lo*/}\PYGdefault{c+cp}{1)\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.lo			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : regs.regs\PYGdefaultZus{}C.lo)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}LO(EXPR)		(spec\PYGdefaultZus{}mode				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? ((spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.lo = (EXPR)),		\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}C, C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,}\PYGdefault{c+cm}{/*lo*/}\PYGdefault{c+cp}{1),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.lo)			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (regs.regs\PYGdefaultZus{}C.lo = (EXPR)))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FCC			(BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}C, C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,}\PYGdefault{c+cm}{/*fcc*/}\PYGdefault{c+cp}{2)\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.fcc			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : regs.regs\PYGdefaultZus{}C.fcc)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}FCC(EXPR)		(spec\PYGdefaultZus{}mode				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? ((spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.fcc = (EXPR)),		\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}C,C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,}\PYGdefault{c+cm}{/*fcc*/}\PYGdefault{c+cp}{2),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.fcc)			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (regs.regs\PYGdefaultZus{}C.fcc = (EXPR)))}

\PYGdefault{c+cp}{\PYGdefaultZsh{}elif defined(TARGET\PYGdefaultZus{}ALPHA)}

\PYGdefault{c+cm}{/* floating point register accessors, NOTE: speculative copy on write storage}
\PYGdefault{c+cm}{   provided for fast recovery during wrong path execute (see tracer\PYGdefaultZus{}recover()}
\PYGdefault{c+cm}{   for details on this process */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FPR\PYGdefaultZus{}Q(N)		(BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}F, F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, (N))\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.q[(N)]                   \PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : regs.regs\PYGdefaultZus{}F.q[(N)])}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}FPR\PYGdefaultZus{}Q(N,EXPR)	(spec\PYGdefaultZus{}mode				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? ((spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.q[(N)] = (EXPR)),	\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}F,F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, (N)),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.q[(N)])			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (regs.regs\PYGdefaultZus{}F.q[(N)] = (EXPR)))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FPR(N)			(BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}F, F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, (N))\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.d[(N)]			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : regs.regs\PYGdefaultZus{}F.d[(N)])}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}FPR(N,EXPR)		(spec\PYGdefaultZus{}mode				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? ((spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.d[(N)] = (EXPR)),	\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}F,F\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ, (N)),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}regs\PYGdefaultZus{}F.d[(N)])			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (regs.regs\PYGdefaultZus{}F.d[(N)] = (EXPR)))}

\PYGdefault{c+cm}{/* miscellanous register accessors, NOTE: speculative copy on write storage}
\PYGdefault{c+cm}{   provided for fast recovery during wrong path execute (see tracer\PYGdefaultZus{}recover()}
\PYGdefault{c+cm}{   for details on this process */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FPCR			(BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}C, C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,}\PYGdefault{c+cm}{/*fpcr*/}\PYGdefault{c+cp}{0)\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.fpcr			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : regs.regs\PYGdefaultZus{}C.fpcr)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}FPCR(EXPR)		(spec\PYGdefaultZus{}mode				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? ((spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.fpcr = (EXPR)),	\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				   BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}C,C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,}\PYGdefault{c+cm}{/*fpcr*/}\PYGdefault{c+cp}{0),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.fpcr)			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (regs.regs\PYGdefaultZus{}C.fpcr = (EXPR)))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define UNIQ			(BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}C, C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,}\PYGdefault{c+cm}{/*uniq*/}\PYGdefault{c+cp}{1)\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.uniq			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : regs.regs\PYGdefaultZus{}C.uniq)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}UNIQ(EXPR)		(spec\PYGdefaultZus{}mode				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? ((spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.uniq = (EXPR)),	\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				   BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}C,C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,}\PYGdefault{c+cm}{/*uniq*/}\PYGdefault{c+cp}{1),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.uniq)			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (regs.regs\PYGdefaultZus{}C.uniq = (EXPR)))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define FCC			(BITMAP\PYGdefaultZus{}SET\PYGdefaultZus{}P(use\PYGdefaultZus{}spec\PYGdefaultZus{}C, C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,}\PYGdefault{c+cm}{/*fcc*/}\PYGdefault{c+cp}{2)\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.fcc			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : regs.regs\PYGdefaultZus{}C.fcc)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SET\PYGdefaultZus{}FCC(EXPR)		(spec\PYGdefaultZus{}mode				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 ? ((spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.fcc = (EXPR)),		\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    BITMAP\PYGdefaultZus{}SET(use\PYGdefaultZus{}spec\PYGdefaultZus{}C,C\PYGdefaultZus{}BMAP\PYGdefaultZus{}SZ,}\PYGdefault{c+cm}{/*fcc*/}\PYGdefault{c+cp}{1),\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				    spec\PYGdefaultZus{}regs\PYGdefaultZus{}C.fcc)			\PYGdefaultZbs{}}
\PYGdefault{c+cp}{				 : (regs.regs\PYGdefaultZus{}C.fcc = (EXPR)))}

\PYGdefault{c+cp}{\PYGdefaultZsh{}else}
\PYGdefault{c+cp}{\PYGdefaultZsh{}error No ISA target defined...}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

\PYGdefault{c+cm}{/* precise architected memory state accessor macros, NOTE: speculative copy on}
\PYGdefault{c+cm}{   write storage provided for fast recovery during wrong path execute (see}
\PYGdefault{c+cm}{   tracer\PYGdefaultZus{}recover() for details on this process */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define \PYGdefaultZus{}\PYGdefaultZus{}READ\PYGdefaultZus{}SPECMEM(SRC, SRC\PYGdefaultZus{}V, FAULT)				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  (addr = (SRC),							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{   (spec\PYGdefaultZus{}mode								\PYGdefaultZbs{}}
\PYGdefault{c+cp}{    ? ((FAULT) = spec\PYGdefaultZus{}mem\PYGdefaultZus{}access(mem, Read, addr, \PYGdefaultZam{}SRC\PYGdefaultZus{}V, sizeof(SRC\PYGdefaultZus{}V)))\PYGdefaultZbs{}}
\PYGdefault{c+cp}{    : ((FAULT) = mem\PYGdefaultZus{}access(mem, Read, addr, \PYGdefaultZam{}SRC\PYGdefaultZus{}V, sizeof(SRC\PYGdefaultZus{}V)))),	\PYGdefaultZbs{}}
\PYGdefault{c+cp}{   SRC\PYGdefaultZus{}V)}

\PYGdefault{c+cp}{\PYGdefaultZsh{}define READ\PYGdefaultZus{}BYTE(SRC, FAULT)						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  \PYGdefaultZus{}\PYGdefaultZus{}READ\PYGdefaultZus{}SPECMEM((SRC), temp\PYGdefaultZus{}byte, (FAULT))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define READ\PYGdefaultZus{}HALF(SRC, FAULT)						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  MD\PYGdefaultZus{}SWAPH(\PYGdefaultZus{}\PYGdefaultZus{}READ\PYGdefaultZus{}SPECMEM((SRC), temp\PYGdefaultZus{}half, (FAULT)))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define READ\PYGdefaultZus{}WORD(SRC, FAULT)						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  MD\PYGdefaultZus{}SWAPW(\PYGdefaultZus{}\PYGdefaultZus{}READ\PYGdefaultZus{}SPECMEM((SRC), temp\PYGdefaultZus{}word, (FAULT)))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef HOST\PYGdefaultZus{}HAS\PYGdefaultZus{}QWORD}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define READ\PYGdefaultZus{}QWORD(SRC, FAULT)						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  MD\PYGdefaultZus{}SWAPQ(\PYGdefaultZus{}\PYGdefaultZus{}READ\PYGdefaultZus{}SPECMEM((SRC), temp\PYGdefaultZus{}qword, (FAULT)))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif }\PYGdefault{c+cm}{/* HOST\PYGdefaultZus{}HAS\PYGdefaultZus{}QWORD */}


\PYGdefault{c+cp}{\PYGdefaultZsh{}define \PYGdefaultZus{}\PYGdefaultZus{}WRITE\PYGdefaultZus{}SPECMEM(SRC, DST, DST\PYGdefaultZus{}V, FAULT)				\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  (DST\PYGdefaultZus{}V = (SRC), addr = (DST),						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{   (spec\PYGdefaultZus{}mode								\PYGdefaultZbs{}}
\PYGdefault{c+cp}{    ? ((FAULT) = spec\PYGdefaultZus{}mem\PYGdefaultZus{}access(mem, Write, addr, \PYGdefaultZam{}DST\PYGdefaultZus{}V, sizeof(DST\PYGdefaultZus{}V)))\PYGdefaultZbs{}}
\PYGdefault{c+cp}{    : ((FAULT) = mem\PYGdefaultZus{}access(mem, Write, addr, \PYGdefaultZam{}DST\PYGdefaultZus{}V, sizeof(DST\PYGdefaultZus{}V)))))}

\PYGdefault{c+cp}{\PYGdefaultZsh{}define WRITE\PYGdefaultZus{}BYTE(SRC, DST, FAULT)					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  \PYGdefaultZus{}\PYGdefaultZus{}WRITE\PYGdefaultZus{}SPECMEM((SRC), (DST), temp\PYGdefaultZus{}byte, (FAULT))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define WRITE\PYGdefaultZus{}HALF(SRC, DST, FAULT)					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  \PYGdefaultZus{}\PYGdefaultZus{}WRITE\PYGdefaultZus{}SPECMEM(MD\PYGdefaultZus{}SWAPH(SRC), (DST), temp\PYGdefaultZus{}half, (FAULT))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define WRITE\PYGdefaultZus{}WORD(SRC, DST, FAULT)					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  \PYGdefaultZus{}\PYGdefaultZus{}WRITE\PYGdefaultZus{}SPECMEM(MD\PYGdefaultZus{}SWAPW(SRC), (DST), temp\PYGdefaultZus{}word, (FAULT))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef HOST\PYGdefaultZus{}HAS\PYGdefaultZus{}QWORD}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define WRITE\PYGdefaultZus{}QWORD(SRC, DST, FAULT)					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  \PYGdefaultZus{}\PYGdefaultZus{}WRITE\PYGdefaultZus{}SPECMEM(MD\PYGdefaultZus{}SWAPQ(SRC), (DST), temp\PYGdefaultZus{}qword, (FAULT))}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif }\PYGdefault{c+cm}{/* HOST\PYGdefaultZus{}HAS\PYGdefaultZus{}QWORD */}

\PYGdefault{c+cm}{/* system call handler macro */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define SYSCALL(INST)							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{  (}\PYGdefault{c+cm}{/* only execute system calls in non\PYGdefaultZhy{}speculative mode */}\PYGdefault{c+cp}{		\PYGdefaultZbs{}}
\PYGdefault{c+cp}{   (spec\PYGdefaultZus{}mode ? panic(\PYGdefaultZdq{}speculative syscall\PYGdefaultZdq{}) : (void) 0),		\PYGdefaultZbs{}}
\PYGdefault{c+cp}{   sys\PYGdefaultZus{}syscall(\PYGdefaultZam{}regs, mem\PYGdefaultZus{}access, mem, INST, TRUE))}

\PYGdefault{c+cm}{/* default register state accessor, used by DLite */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}					\PYGdefault{c+cm}{/* err str, NULL for no err */}
\PYGdefault{n}{simoo\PYGdefaultZus{}reg\PYGdefaultZus{}obj}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{k+kt}{regs\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{xregs}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* registers to access */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{is\PYGdefaultZus{}write}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* access type */}
	      \PYGdefault{k}{enum} \PYGdefault{n}{md\PYGdefaultZus{}reg\PYGdefaultZus{}type} \PYGdefault{n}{rt}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* reg bank to probe */}
	      \PYGdefault{k+kt}{int} \PYGdefault{n}{reg}\PYGdefault{p}{,}				\PYGdefault{c+cm}{/* register number */}
	      \PYGdefault{k}{struct} \PYGdefault{k+kt}{eval\PYGdefaultZus{}value\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{val}\PYGdefault{p}{)}		\PYGdefault{c+cm}{/* input, output */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{switch} \PYGdefault{p}{(}\PYGdefault{n}{rt}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
    \PYGdefault{k}{case} \PYGdefault{n+nl}{rt\PYGdefaultZus{}gpr}\PYGdefault{p}{:}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{reg} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{0} \PYGdefault{o}{||} \PYGdefault{n}{reg} \PYGdefault{o}{\PYGdefaultZgt{}=} \PYGdefault{n}{MD\PYGdefaultZus{}NUM\PYGdefaultZus{}IREGS}\PYGdefault{p}{)}
	\PYGdefault{k}{return} \PYGdefault{l+s}{\PYGdefaultZdq{}register number out of range\PYGdefaultZdq{}}\PYGdefault{p}{;}

      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{is\PYGdefaultZus{}write}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{n}{val}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{type} \PYGdefault{o}{=} \PYGdefault{n}{et\PYGdefaultZus{}uint}\PYGdefault{p}{;}
	  \PYGdefault{n}{val}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{value}\PYGdefault{p}{.}\PYGdefault{n}{as\PYGdefaultZus{}uint} \PYGdefault{o}{=} \PYGdefault{n}{GPR}\PYGdefault{p}{(}\PYGdefault{n}{reg}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{else}
	\PYGdefault{n}{SET\PYGdefaultZus{}GPR}\PYGdefault{p}{(}\PYGdefault{n}{reg}\PYGdefault{p}{,} \PYGdefault{n}{eval\PYGdefaultZus{}as\PYGdefaultZus{}uint}\PYGdefault{p}{(}\PYGdefault{o}{*}\PYGdefault{n}{val}\PYGdefault{p}{));}
      \PYGdefault{k}{break}\PYGdefault{p}{;}

    \PYGdefault{k}{case} \PYGdefault{n+nl}{rt\PYGdefaultZus{}lpr}\PYGdefault{p}{:}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{reg} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mi}{0} \PYGdefault{o}{||} \PYGdefault{n}{reg} \PYGdefault{o}{\PYGdefaultZgt{}=} \PYGdefault{n}{MD\PYGdefaultZus{}NUM\PYGdefaultZus{}FREGS}\PYGdefault{p}{)}
	\PYGdefault{k}{return} \PYGdefault{l+s}{\PYGdefaultZdq{}register number out of range\PYGdefaultZdq{}}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* FIXME: this is not portable... */}
      \PYGdefault{n}{abort}\PYGdefault{p}{();}
\PYGdefault{c+cp}{\PYGdefaultZsh{}if 0}
\PYGdefault{c}{      if (!is\PYGdefaultZus{}write)}
\PYGdefault{c}{	\PYGdefaultZob{}}
\PYGdefault{c}{	  val\PYGdefaultZhy{}\PYGdefaultZgt{}type = et\PYGdefaultZus{}uint;}
\PYGdefault{c}{	  val\PYGdefaultZhy{}\PYGdefaultZgt{}value.as\PYGdefaultZus{}uint = FPR\PYGdefaultZus{}L(reg);}
\PYGdefault{c}{	\PYGdefaultZcb{}}
\PYGdefault{c}{      else}
\PYGdefault{c}{	SET\PYGdefaultZus{}FPR\PYGdefaultZus{}L(reg, eval\PYGdefaultZus{}as\PYGdefaultZus{}uint(*val));}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}
      \PYGdefault{k}{break}\PYGdefault{p}{;}

    \PYGdefault{k}{case} \PYGdefault{n+nl}{rt\PYGdefaultZus{}fpr}\PYGdefault{p}{:}
      \PYGdefault{c+cm}{/* FIXME: this is not portable... */}
      \PYGdefault{n}{abort}\PYGdefault{p}{();}
\PYGdefault{c+cp}{\PYGdefaultZsh{}if 0}
\PYGdefault{c}{      if (!is\PYGdefaultZus{}write)}
\PYGdefault{c}{	val\PYGdefaultZhy{}\PYGdefaultZgt{}value.as\PYGdefaultZus{}float = FPR\PYGdefaultZus{}F(reg);}
\PYGdefault{c}{      else}
\PYGdefault{c}{	SET\PYGdefaultZus{}FPR\PYGdefaultZus{}F(reg, val\PYGdefaultZhy{}\PYGdefaultZgt{}value.as\PYGdefaultZus{}float);}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}
      \PYGdefault{k}{break}\PYGdefault{p}{;}

    \PYGdefault{k}{case} \PYGdefault{n+nl}{rt\PYGdefaultZus{}dpr}\PYGdefault{p}{:}
      \PYGdefault{c+cm}{/* FIXME: this is not portable... */}
      \PYGdefault{n}{abort}\PYGdefault{p}{();}
\PYGdefault{c+cp}{\PYGdefaultZsh{}if 0}
\PYGdefault{c}{      /* 1/2 as many regs in this mode */}
\PYGdefault{c}{      if (reg \PYGdefaultZlt{} 0 || reg \PYGdefaultZgt{}= MD\PYGdefaultZus{}NUM\PYGdefaultZus{}REGS/2)}
\PYGdefault{c}{	return \PYGdefaultZdq{}register number out of range\PYGdefaultZdq{};}

\PYGdefault{c}{      if (at == at\PYGdefaultZus{}read)}
\PYGdefault{c}{	val\PYGdefaultZhy{}\PYGdefaultZgt{}as\PYGdefaultZus{}double = FPR\PYGdefaultZus{}D(reg * 2);}
\PYGdefault{c}{      else}
\PYGdefault{c}{	SET\PYGdefaultZus{}FPR\PYGdefaultZus{}D(reg * 2, val\PYGdefaultZhy{}\PYGdefaultZgt{}as\PYGdefaultZus{}double);}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}
      \PYGdefault{k}{break}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* FIXME: this is not portable... */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}if 0}
\PYGdefault{c}{      abort();}
\PYGdefault{c}{    case rt\PYGdefaultZus{}hi:}
\PYGdefault{c}{      if (at == at\PYGdefaultZus{}read)}
\PYGdefault{c}{	val\PYGdefaultZhy{}\PYGdefaultZgt{}as\PYGdefaultZus{}word = HI;}
\PYGdefault{c}{      else}
\PYGdefault{c}{	SET\PYGdefaultZus{}HI(val\PYGdefaultZhy{}\PYGdefaultZgt{}as\PYGdefaultZus{}word);}
\PYGdefault{c}{      break;}
\PYGdefault{c}{    case rt\PYGdefaultZus{}lo:}
\PYGdefault{c}{      if (at == at\PYGdefaultZus{}read)}
\PYGdefault{c}{	val\PYGdefaultZhy{}\PYGdefaultZgt{}as\PYGdefaultZus{}word = LO;}
\PYGdefault{c}{      else}
\PYGdefault{c}{	SET\PYGdefaultZus{}LO(val\PYGdefaultZhy{}\PYGdefaultZgt{}as\PYGdefaultZus{}word);}
\PYGdefault{c}{      break;}
\PYGdefault{c}{    case rt\PYGdefaultZus{}FCC:}
\PYGdefault{c}{      if (at == at\PYGdefaultZus{}read)}
\PYGdefault{c}{	val\PYGdefaultZhy{}\PYGdefaultZgt{}as\PYGdefaultZus{}condition = FCC;}
\PYGdefault{c}{      else}
\PYGdefault{c}{	SET\PYGdefaultZus{}FCC(val\PYGdefaultZhy{}\PYGdefaultZgt{}as\PYGdefaultZus{}condition);}
\PYGdefault{c}{      break;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

    \PYGdefault{k}{case} \PYGdefault{n+nl}{rt\PYGdefaultZus{}PC}\PYGdefault{p}{:}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{is\PYGdefaultZus{}write}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{n}{val}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{type} \PYGdefault{o}{=} \PYGdefault{n}{et\PYGdefaultZus{}addr}\PYGdefault{p}{;}
	  \PYGdefault{n}{val}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{value}\PYGdefault{p}{.}\PYGdefault{n}{as\PYGdefaultZus{}addr} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{else}
	\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{eval\PYGdefaultZus{}as\PYGdefaultZus{}addr}\PYGdefault{p}{(}\PYGdefault{o}{*}\PYGdefault{n}{val}\PYGdefault{p}{);}
      \PYGdefault{k}{break}\PYGdefault{p}{;}

    \PYGdefault{k}{case} \PYGdefault{n+nl}{rt\PYGdefaultZus{}NPC}\PYGdefault{p}{:}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{is\PYGdefaultZus{}write}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{n}{val}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{type} \PYGdefault{o}{=} \PYGdefault{n}{et\PYGdefaultZus{}addr}\PYGdefault{p}{;}
	  \PYGdefault{n}{val}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{value}\PYGdefault{p}{.}\PYGdefault{n}{as\PYGdefaultZus{}addr} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{else}
	\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC} \PYGdefault{o}{=} \PYGdefault{n}{eval\PYGdefaultZus{}as\PYGdefaultZus{}addr}\PYGdefault{p}{(}\PYGdefault{o}{*}\PYGdefault{n}{val}\PYGdefault{p}{);}
      \PYGdefault{k}{break}\PYGdefault{p}{;}

    \PYGdefault{k}{default}\PYGdefault{o}{:}
      \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}bogus register bank\PYGdefaultZdq{}}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* no error */}
  \PYGdefault{k}{return} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* the last operation that ruu\PYGdefaultZus{}dispatch() attempted to dispatch, for}
\PYGdefault{c+cm}{   implementing in\PYGdefaultZhy{}order issue */}
\PYGdefault{k}{static} \PYGdefault{k}{struct} \PYGdefault{n}{RS\PYGdefaultZus{}link} \PYGdefault{n}{last\PYGdefaultZus{}op} \PYGdefault{o}{=} \PYGdefault{n}{RSLINK\PYGdefaultZus{}NULL\PYGdefaultZus{}DATA}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* dispatch instructions from the IFETCH \PYGdefaultZhy{}\PYGdefaultZgt{} DISPATCH queue: instructions are}
\PYGdefault{c+cm}{   first decoded, then they allocated RUU (and LSQ for load/stores) resources}
\PYGdefault{c+cm}{   and input and output dependence chains are updated accordingly */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{ruu\PYGdefaultZus{}dispatch}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{;}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{n\PYGdefaultZus{}dispatched}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* total insts dispatched */}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t} \PYGdefault{n}{inst}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* actual instruction bits */}
  \PYGdefault{k}{enum} \PYGdefault{n}{md\PYGdefaultZus{}opcode} \PYGdefault{n}{op}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* decoded opcode enum */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{out1}\PYGdefault{p}{,} \PYGdefault{n}{out2}\PYGdefault{p}{,} \PYGdefault{n}{in1}\PYGdefault{p}{,} \PYGdefault{n}{in2}\PYGdefault{p}{,} \PYGdefault{n}{in3}\PYGdefault{p}{;}	\PYGdefault{c+cm}{/* output/input register names */}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{target\PYGdefaultZus{}PC}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* actual next/target PC address */}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{addr}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* effective address, if load/store */}
  \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{rs}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* RUU station being allocated */}
  \PYGdefault{k}{struct} \PYGdefault{n}{RUU\PYGdefaultZus{}station} \PYGdefault{o}{*}\PYGdefault{n}{lsq}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* LSQ station for ld/st\PYGdefaultZsq{}s */}
  \PYGdefault{k}{struct} \PYGdefault{k+kt}{bpred\PYGdefaultZus{}update\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{dir\PYGdefaultZus{}update\PYGdefaultZus{}ptr}\PYGdefault{p}{;}\PYGdefault{c+cm}{/* branch predictor dir update ptr */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* bpred retstack recovery index */}
  \PYGdefault{k+kt}{unsigned} \PYGdefault{k+kt}{int} \PYGdefault{n}{pseq}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* pipetrace sequence number */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{is\PYGdefaultZus{}write}\PYGdefault{p}{;}				\PYGdefault{c+cm}{/* store? */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{made\PYGdefaultZus{}check}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* used to ensure DLite entry */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{br\PYGdefaultZus{}taken}\PYGdefault{p}{,} \PYGdefault{n}{br\PYGdefaultZus{}pred\PYGdefaultZus{}taken}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* if br, taken?  predicted taken? */}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{fetch\PYGdefaultZus{}redirected} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}
  \PYGdefault{k+kt}{byte\PYGdefaultZus{}t} \PYGdefault{n}{temp\PYGdefaultZus{}byte} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* temp variable for spec mem access */}
  \PYGdefault{k+kt}{half\PYGdefaultZus{}t} \PYGdefault{n}{temp\PYGdefaultZus{}half} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* \PYGdefaultZdq{} ditto \PYGdefaultZdq{} */}
  \PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{n}{temp\PYGdefaultZus{}word} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* \PYGdefaultZdq{} ditto \PYGdefaultZdq{} */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef HOST\PYGdefaultZus{}HAS\PYGdefaultZus{}QWORD}
  \PYGdefault{k+kt}{qword\PYGdefaultZus{}t} \PYGdefault{n}{temp\PYGdefaultZus{}qword} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* \PYGdefaultZdq{} ditto \PYGdefaultZdq{} */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif }\PYGdefault{c+cm}{/* HOST\PYGdefaultZus{}HAS\PYGdefaultZus{}QWORD */}
  \PYGdefault{k}{enum} \PYGdefault{n}{md\PYGdefaultZus{}fault\PYGdefaultZus{}type} \PYGdefault{n}{fault}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* Wattch:  Added for pop count generation (AFs) */}
  \PYGdefault{k+kt}{qword\PYGdefaultZus{}t} \PYGdefault{n}{val\PYGdefaultZus{}ra}\PYGdefault{p}{,} \PYGdefault{n}{val\PYGdefaultZus{}rb}\PYGdefault{p}{,} \PYGdefault{n}{val\PYGdefaultZus{}rc}\PYGdefault{p}{,} \PYGdefault{n}{val\PYGdefaultZus{}ra\PYGdefaultZus{}result}\PYGdefault{p}{;}

  \PYGdefault{n}{made\PYGdefaultZus{}check} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}
  \PYGdefault{n}{n\PYGdefaultZus{}dispatched} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{k}{while} \PYGdefault{p}{(}\PYGdefault{c+cm}{/* instruction decode B/W left? */}
	 \PYGdefault{n}{n\PYGdefaultZus{}dispatched} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}decode\PYGdefaultZus{}width} \PYGdefault{o}{*} \PYGdefault{n}{fetch\PYGdefaultZus{}speed}\PYGdefault{p}{)}
	 \PYGdefault{c+cm}{/* RUU and LSQ not full? */}
	 \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{RUU\PYGdefaultZus{}num} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{RUU\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{LSQ\PYGdefaultZus{}num} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{LSQ\PYGdefaultZus{}size}
	 \PYGdefault{c+cm}{/* insts still available from fetch unit? */}
	 \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{fetch\PYGdefaultZus{}num} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{0}
	 \PYGdefault{c+cm}{/* on an acceptable trace path */}
	 \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}include\PYGdefaultZus{}spec} \PYGdefault{o}{||} \PYGdefault{o}{!}\PYGdefault{n}{spec\PYGdefaultZus{}mode}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* if issuing in\PYGdefaultZhy{}order, block until last op issues if inorder issue */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}inorder\PYGdefaultZus{}issue}
	  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{last\PYGdefaultZus{}op}\PYGdefault{p}{.}\PYGdefault{n}{rs} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{RSLINK\PYGdefaultZus{}VALID}\PYGdefault{p}{(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{last\PYGdefaultZus{}op}\PYGdefault{p}{)}
	      \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{o}{!}\PYGdefault{n}{OPERANDS\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{n}{last\PYGdefaultZus{}op}\PYGdefault{p}{.}\PYGdefault{n}{rs}\PYGdefault{p}{)))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* stall until last operation is ready to issue */}
	  \PYGdefault{k}{break}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* get the next instruction from the IFETCH \PYGdefaultZhy{}\PYGdefaultZgt{} DISPATCH queue */}
      \PYGdefault{n}{inst} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{IR}\PYGdefault{p}{;}
      \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{;}
      \PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{pred\PYGdefaultZus{}PC}\PYGdefault{p}{;}
      \PYGdefault{n}{dir\PYGdefaultZus{}update\PYGdefaultZus{}ptr} \PYGdefault{o}{=} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{dir\PYGdefaultZus{}update}\PYGdefault{p}{);}
      \PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx}\PYGdefault{p}{;}
      \PYGdefault{n}{pseq} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}head}\PYGdefault{p}{].}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* decode the inst */}
      \PYGdefault{n}{MD\PYGdefaultZus{}SET\PYGdefaultZus{}OPCODE}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{,} \PYGdefault{n}{inst}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* compute default next PC */}
      \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{+} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* drain RUU for TRAPs and system calls */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}TRAP}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}num} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
	    \PYGdefault{k}{break}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* else, syscall is only instruction in the machine, at this}
\PYGdefault{c+cm}{	     point we should not be in (mis\PYGdefaultZhy{})speculative mode */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{spec\PYGdefaultZus{}mode}\PYGdefault{p}{)}
	    \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}drained and speculative\PYGdefaultZdq{}}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* maintain \PYGdefaultZdl{}r0 semantics (in spec and non\PYGdefaultZhy{}spec space) */}
      \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}R}\PYGdefault{p}{[}\PYGdefault{n}{MD\PYGdefaultZus{}REG\PYGdefaultZus{}ZERO}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{spec\PYGdefaultZus{}regs\PYGdefaultZus{}R}\PYGdefault{p}{[}\PYGdefault{n}{MD\PYGdefaultZus{}REG\PYGdefaultZus{}ZERO}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef TARGET\PYGdefaultZus{}ALPHA}
      \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}F}\PYGdefault{p}{.}\PYGdefault{n}{d}\PYGdefault{p}{[}\PYGdefault{n}{MD\PYGdefaultZus{}REG\PYGdefaultZus{}ZERO}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{l+m+mf}{0.0}\PYGdefault{p}{;} \PYGdefault{n}{spec\PYGdefaultZus{}regs\PYGdefaultZus{}F}\PYGdefault{p}{.}\PYGdefault{n}{d}\PYGdefault{p}{[}\PYGdefault{n}{MD\PYGdefaultZus{}REG\PYGdefaultZus{}ZERO}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{l+m+mf}{0.0}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif }\PYGdefault{c+cm}{/* TARGET\PYGdefaultZus{}ALPHA */}

      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{spec\PYGdefaultZus{}mode}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* one more non\PYGdefaultZhy{}speculative instruction executed */}
	  \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}insn}\PYGdefault{o}{++}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* default effective address (none) and access */}
      \PYGdefault{n}{addr} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{is\PYGdefaultZus{}write} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* Wattch: Get values of source operands */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}if defined(TARGET\PYGdefaultZus{}PISA)}
      \PYGdefault{n}{val\PYGdefaultZus{}ra} \PYGdefault{o}{=} \PYGdefault{n}{GPR}\PYGdefault{p}{(}\PYGdefault{n}{RS}\PYGdefault{p}{);}
      \PYGdefault{n}{val\PYGdefaultZus{}rb} \PYGdefault{o}{=} \PYGdefault{n}{GPR}\PYGdefault{p}{(}\PYGdefault{n}{RT}\PYGdefault{p}{);}
\PYGdefault{c+cp}{\PYGdefaultZsh{}elif defined(TARGET\PYGdefaultZus{}ALPHA)}
      \PYGdefault{n}{val\PYGdefaultZus{}ra} \PYGdefault{o}{=} \PYGdefault{n}{GPR}\PYGdefault{p}{(}\PYGdefault{n}{RA}\PYGdefault{p}{);}
      \PYGdefault{n}{val\PYGdefaultZus{}rb} \PYGdefault{o}{=} \PYGdefault{n}{GPR}\PYGdefault{p}{(}\PYGdefault{n}{RB}\PYGdefault{p}{);}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

      \PYGdefault{c+cm}{/* set default fault \PYGdefaultZhy{} none */}
      \PYGdefault{n}{fault} \PYGdefault{o}{=} \PYGdefault{n}{md\PYGdefaultZus{}fault\PYGdefaultZus{}none}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* more decoding and execution */}
      \PYGdefault{k}{switch} \PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DEFINST(OP,MSK,NAME,OPFORM,RES,CLASS,O1,O2,I1,I2,I3)		\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	case OP:							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  }\PYGdefault{c+cm}{/* compute output/input dependencies to out1\PYGdefaultZhy{}2 and in1\PYGdefaultZhy{}3 */}\PYGdefault{c+cp}{	\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  out1 = O1; out2 = O2;						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  in1 = I1; in2 = I2; in3 = I3;					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  }\PYGdefault{c+cm}{/* execute the instruction */}\PYGdefault{c+cp}{					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  SYMCAT(OP,\PYGdefaultZus{}IMPL);						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  break;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DEFLINK(OP,MSK,NAME,MASK,SHIFT)					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	case OP:							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  }\PYGdefault{c+cm}{/* could speculatively decode a bogus inst, convert to NOP */}\PYGdefault{c+cp}{	\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  op = MD\PYGdefaultZus{}NOP\PYGdefaultZus{}OP;						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  }\PYGdefault{c+cm}{/* compute output/input dependencies to out1\PYGdefaultZhy{}2 and in1\PYGdefaultZhy{}3 */}\PYGdefault{c+cp}{	\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  out1 = NA; out2 = NA;						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  in1 = NA; in2 = NA; in3 = NA;					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  }\PYGdefault{c+cm}{/* no EXPR */}\PYGdefault{c+cp}{							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  break;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define CONNECT(OP)	}\PYGdefault{c+cm}{/* nada... */}
	  \PYGdefault{c+cm}{/* the following macro wraps the instruction fault declaration macro}
\PYGdefault{c+cm}{	     with a test to see if the trace generator is in non\PYGdefaultZhy{}speculative}
\PYGdefault{c+cm}{	     mode, if so the instruction fault is declared, otherwise, the}
\PYGdefault{c+cm}{	     error is shunted because instruction faults need to be masked on}
\PYGdefault{c+cm}{	     the mis\PYGdefaultZhy{}speculated instruction paths */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DECLARE\PYGdefaultZus{}FAULT(FAULT)						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  \PYGdefaultZob{}								\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	    if (!spec\PYGdefaultZus{}mode)						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	      fault = (FAULT);						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	    }\PYGdefault{c+cm}{/* else, spec fault, ignore it, always terminate exec... */}\PYGdefault{c+cp}{	\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	    break;							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	  \PYGdefaultZcb{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}machine.def\PYGdefaultZdq{}}
	\PYGdefault{k}{default}\PYGdefault{o}{:}
	  \PYGdefault{c+cm}{/* can speculatively decode a bogus inst, convert to a NOP */}
	  \PYGdefault{n}{op} \PYGdefault{o}{=} \PYGdefault{n}{MD\PYGdefaultZus{}NOP\PYGdefaultZus{}OP}\PYGdefault{p}{;}
	  \PYGdefault{c+cm}{/* compute output/input dependencies to out1\PYGdefaultZhy{}2 and in1\PYGdefaultZhy{}3 */}	\PYGdefaultZbs{}
	  \PYGdefault{n}{out1} \PYGdefault{o}{=} \PYGdefault{n}{NA}\PYGdefault{p}{;} \PYGdefault{n}{out2} \PYGdefault{o}{=} \PYGdefault{n}{NA}\PYGdefault{p}{;}
	  \PYGdefault{n}{in1} \PYGdefault{o}{=} \PYGdefault{n}{NA}\PYGdefault{p}{;} \PYGdefault{n}{in2} \PYGdefault{o}{=} \PYGdefault{n}{NA}\PYGdefault{p}{;} \PYGdefault{n}{in3} \PYGdefault{o}{=} \PYGdefault{n}{NA}\PYGdefault{p}{;}
	  \PYGdefault{c+cm}{/* no EXPR */}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{c+cm}{/* operation sets next PC */}

      \PYGdefault{c+cm}{/* print retirement trace if in verbose mode */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{spec\PYGdefaultZus{}mode} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{verbose}\PYGdefault{p}{)}
        \PYGdefault{p}{\PYGdefaultZob{}}
          \PYGdefault{n}{myfprintf}\PYGdefault{p}{(}\PYGdefault{n}{stderr}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}++ \PYGdefaultZpc{}10n [xor: 0x\PYGdefaultZpc{}08x] \PYGdefaultZob{}\PYGdefaultZpc{}d\PYGdefaultZcb{} @ 0x\PYGdefaultZpc{}08p: \PYGdefaultZdq{}}\PYGdefault{p}{,}
                    \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}insn}\PYGdefault{p}{,} \PYGdefault{n}{md\PYGdefaultZus{}xor\PYGdefaultZus{}regs}\PYGdefault{p}{(}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{regs}\PYGdefault{p}{),}
                    \PYGdefault{n}{inst\PYGdefaultZus{}seq}\PYGdefault{o}{+}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{);}
          \PYGdefault{n}{md\PYGdefaultZus{}print\PYGdefaultZus{}insn}\PYGdefault{p}{(}\PYGdefault{n}{inst}\PYGdefault{p}{,} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{stderr}\PYGdefault{p}{);}
          \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stderr}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}
          \PYGdefault{c+cm}{/* fflush(stderr); */}
        \PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{fault} \PYGdefault{o}{!=} \PYGdefault{n}{md\PYGdefaultZus{}fault\PYGdefaultZus{}none}\PYGdefault{p}{)}
	\PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}non\PYGdefaultZhy{}speculative fault (\PYGdefaultZpc{}d) detected @ 0x\PYGdefaultZpc{}08p\PYGdefaultZdq{}}\PYGdefault{p}{,}
	      \PYGdefault{n}{fault}\PYGdefault{p}{,} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* Wattch: Get values of source operands */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}if defined(TARGET\PYGdefaultZus{}PISA)}
      \PYGdefault{n}{val\PYGdefaultZus{}ra} \PYGdefault{o}{=} \PYGdefault{n}{GPR}\PYGdefault{p}{(}\PYGdefault{n}{RS}\PYGdefault{p}{);}
      \PYGdefault{n}{val\PYGdefaultZus{}rb} \PYGdefault{o}{=} \PYGdefault{n}{GPR}\PYGdefault{p}{(}\PYGdefault{n}{RT}\PYGdefault{p}{);}
\PYGdefault{c+cp}{\PYGdefaultZsh{}elif defined(TARGET\PYGdefaultZus{}ALPHA)}
      \PYGdefault{n}{val\PYGdefaultZus{}ra} \PYGdefault{o}{=} \PYGdefault{n}{GPR}\PYGdefault{p}{(}\PYGdefault{n}{RA}\PYGdefault{p}{);}
      \PYGdefault{n}{val\PYGdefaultZus{}rb} \PYGdefault{o}{=} \PYGdefault{n}{GPR}\PYGdefault{p}{(}\PYGdefault{n}{RB}\PYGdefault{p}{);}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

      \PYGdefault{c+cm}{/* update memory access stats */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{n}{sim\PYGdefaultZus{}total\PYGdefaultZus{}refs}\PYGdefault{o}{++}\PYGdefault{p}{;}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{spec\PYGdefaultZus{}mode}\PYGdefault{p}{)}
	    \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}refs}\PYGdefault{o}{++}\PYGdefault{p}{;}

	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{)}
	    \PYGdefault{n}{is\PYGdefaultZus{}write} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
	  \PYGdefault{k}{else}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{n}{sim\PYGdefaultZus{}total\PYGdefaultZus{}loads}\PYGdefault{o}{++}\PYGdefault{p}{;}
	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{spec\PYGdefaultZus{}mode}\PYGdefault{p}{)}
		\PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}loads}\PYGdefault{o}{++}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{n}{br\PYGdefaultZus{}taken} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC} \PYGdefault{o}{!=} \PYGdefault{p}{(}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{+} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{)));}
      \PYGdefault{n}{br\PYGdefaultZus{}pred\PYGdefaultZus{}taken} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{!=} \PYGdefault{p}{(}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{+} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{)));}

      \PYGdefault{k}{if} \PYGdefault{p}{((}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{!=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{pred\PYGdefaultZus{}perfect}\PYGdefault{p}{)}
	  \PYGdefault{o}{||} \PYGdefault{p}{((}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}CTRL}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}DIRJMP}\PYGdefault{p}{))} \PYGdefault{o}{==} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}CTRL}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}DIRJMP}\PYGdefault{p}{)}
	      \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{target\PYGdefaultZus{}PC} \PYGdefault{o}{!=} \PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{br\PYGdefaultZus{}pred\PYGdefaultZus{}taken}\PYGdefault{p}{))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* Either 1) we\PYGdefaultZsq{}re simulating perfect prediction and are in a}
\PYGdefault{c+cm}{             mis\PYGdefaultZhy{}predict state and need to patch up, or 2) We\PYGdefaultZsq{}re not simulating}
\PYGdefault{c+cm}{             perfect prediction, we\PYGdefaultZsq{}ve predicted the branch taken, but our}
\PYGdefault{c+cm}{             predicted target doesn\PYGdefaultZsq{}t match the computed target (i.e.,}
\PYGdefault{c+cm}{             mis\PYGdefaultZhy{}fetch).  Just update the PC values and do a fetch squash.}
\PYGdefault{c+cm}{             This is just like calling fetch\PYGdefaultZus{}squash() except we pre\PYGdefaultZhy{}anticipate}
\PYGdefault{c+cm}{             the updates to the fetch values at the end of this function.  If}
\PYGdefault{c+cm}{             case \PYGdefaultZsh{}2, also charge a mispredict penalty for redirecting fetch */}
	  \PYGdefault{n}{fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC}\PYGdefault{p}{;}
	  \PYGdefault{c+cm}{/* was: if (pred\PYGdefaultZus{}perfect) */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{pred\PYGdefaultZus{}perfect}\PYGdefault{p}{)}
	    \PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC}\PYGdefault{p}{;}

	  \PYGdefault{n}{fetch\PYGdefaultZus{}head} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{);}
	  \PYGdefault{n}{fetch\PYGdefaultZus{}num} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{;}
	  \PYGdefault{n}{fetch\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{pred\PYGdefaultZus{}perfect}\PYGdefault{p}{)}
	    \PYGdefault{n}{ruu\PYGdefaultZus{}fetch\PYGdefaultZus{}issue\PYGdefaultZus{}delay} \PYGdefault{o}{=} \PYGdefault{n}{ruu\PYGdefaultZus{}branch\PYGdefaultZus{}penalty}\PYGdefault{p}{;}

	  \PYGdefault{n}{fetch\PYGdefaultZus{}redirected} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* is this a NOP */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{op} \PYGdefault{o}{!=} \PYGdefault{n}{MD\PYGdefaultZus{}NOP\PYGdefaultZus{}OP}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* for load/stores:}
\PYGdefault{c+cm}{	       idep \PYGdefaultZsh{}0     \PYGdefaultZhy{} store operand (value that is store\PYGdefaultZsq{}ed)}
\PYGdefault{c+cm}{	       idep \PYGdefaultZsh{}1, \PYGdefaultZsh{}2 \PYGdefaultZhy{} eff addr computation inputs (addr of access)}

\PYGdefault{c+cm}{	     resulting RUU/LSQ operation pair:}
\PYGdefault{c+cm}{	       RUU (effective address computation operation):}
\PYGdefault{c+cm}{		 idep \PYGdefaultZsh{}0, \PYGdefaultZsh{}1 \PYGdefaultZhy{} eff addr computation inputs (addr of access)}
\PYGdefault{c+cm}{	       LSQ (memory access operation):}
\PYGdefault{c+cm}{		 idep \PYGdefaultZsh{}0     \PYGdefaultZhy{} operand input (value that is store\PYGdefaultZsq{}d)}
\PYGdefault{c+cm}{		 idep \PYGdefaultZsh{}1     \PYGdefaultZhy{} eff addr computation result (from RUU op)}

\PYGdefault{c+cm}{	     effective address computation is transfered via the reserved}
\PYGdefault{c+cm}{	     name DTMP}
\PYGdefault{c+cm}{	   */}

	  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} Dispatch + RAT lookup stage */}
	  \PYGdefault{n}{rename\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* fill in RUU reservation station */}
	  \PYGdefault{n}{rs} \PYGdefault{o}{=} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{RUU}\PYGdefault{p}{[}\PYGdefault{n}{RUU\PYGdefaultZus{}tail}\PYGdefault{p}{];}
          \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{slip} \PYGdefault{o}{=} \PYGdefault{n}{sim\PYGdefaultZus{}cycle} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{IR} \PYGdefault{o}{=} \PYGdefault{n}{inst}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op} \PYGdefault{o}{=} \PYGdefault{n}{op}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{PC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC}\PYGdefault{p}{;} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{pred\PYGdefaultZus{}PC}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ea\PYGdefaultZus{}comp} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{recover\PYGdefaultZus{}inst} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}
          \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{dir\PYGdefaultZus{}update} \PYGdefault{o}{=} \PYGdefault{o}{*}\PYGdefault{n}{dir\PYGdefaultZus{}update\PYGdefaultZus{}ptr}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx} \PYGdefault{o}{=} \PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{spec\PYGdefaultZus{}mode} \PYGdefault{o}{=} \PYGdefault{n}{spec\PYGdefaultZus{}mode}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{addr} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
	  \PYGdefault{c+cm}{/* rs\PYGdefaultZhy{}\PYGdefaultZgt{}tag is already set */}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{seq} \PYGdefault{o}{=} \PYGdefault{o}{++}\PYGdefault{n}{inst\PYGdefaultZus{}seq}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{queued} \PYGdefault{o}{=} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{issued} \PYGdefault{o}{=} \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{completed} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq} \PYGdefault{o}{=} \PYGdefault{n}{pseq}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* Wattch: Maintain values through core for AFs*/}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra} \PYGdefault{o}{=} \PYGdefault{n}{val\PYGdefaultZus{}ra}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rb} \PYGdefault{o}{=} \PYGdefault{n}{val\PYGdefaultZus{}rb}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rc} \PYGdefault{o}{=} \PYGdefault{n}{val\PYGdefaultZus{}rc}\PYGdefault{p}{;}
	  \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra\PYGdefaultZus{}result} \PYGdefault{o}{=} \PYGdefault{n}{val\PYGdefaultZus{}ra\PYGdefaultZus{}result}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* split ld/st\PYGdefaultZsq{}s into two operations: eff addr comp + mem access */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* convert RUU operation from ld/st to an add (eff addr comp) */}
	      \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op} \PYGdefault{o}{=} \PYGdefault{n}{MD\PYGdefaultZus{}AGEN\PYGdefaultZus{}OP}\PYGdefault{p}{;}
	      \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ea\PYGdefaultZus{}comp} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}

	      \PYGdefault{c+cm}{/* fill in LSQ reservation station */}
	      \PYGdefault{n}{lsq} \PYGdefault{o}{=} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{LSQ}\PYGdefault{p}{[}\PYGdefault{n}{LSQ\PYGdefaultZus{}tail}\PYGdefault{p}{];}
              \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{slip} \PYGdefault{o}{=} \PYGdefault{n}{sim\PYGdefaultZus{}cycle} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{IR} \PYGdefault{o}{=} \PYGdefault{n}{inst}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{op} \PYGdefault{o}{=} \PYGdefault{n}{op}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{PC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{next\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC}\PYGdefault{p}{;} \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{pred\PYGdefaultZus{}PC}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{in\PYGdefaultZus{}LSQ} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ea\PYGdefaultZus{}comp} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{recover\PYGdefaultZus{}inst} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{dir\PYGdefaultZus{}update}\PYGdefault{p}{.}\PYGdefault{n}{pdir1} \PYGdefault{o}{=} \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{dir\PYGdefaultZus{}update}\PYGdefault{p}{.}\PYGdefault{n}{pdir2} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{dir\PYGdefaultZus{}update}\PYGdefault{p}{.}\PYGdefault{n}{pmeta} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{spec\PYGdefaultZus{}mode} \PYGdefault{o}{=} \PYGdefault{n}{spec\PYGdefaultZus{}mode}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{addr} \PYGdefault{o}{=} \PYGdefault{n}{addr}\PYGdefault{p}{;}
	      \PYGdefault{c+cm}{/* lsq\PYGdefaultZhy{}\PYGdefaultZgt{}tag is already set */}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{seq} \PYGdefault{o}{=} \PYGdefault{o}{++}\PYGdefault{n}{inst\PYGdefaultZus{}seq}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{queued} \PYGdefault{o}{=} \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{issued} \PYGdefault{o}{=} \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{completed} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq} \PYGdefault{o}{=} \PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{o}{++}\PYGdefault{p}{;}

	      \PYGdefault{c+cm}{/* Wattch: Maintain values through core for AFs*/}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra} \PYGdefault{o}{=} \PYGdefault{n}{val\PYGdefaultZus{}ra}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rb} \PYGdefault{o}{=} \PYGdefault{n}{val\PYGdefaultZus{}rb}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rc} \PYGdefault{o}{=} \PYGdefault{n}{val\PYGdefaultZus{}rc}\PYGdefault{p}{;}
	      \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra\PYGdefaultZus{}result} \PYGdefault{o}{=} \PYGdefault{n}{val\PYGdefaultZus{}ra\PYGdefaultZus{}result}\PYGdefault{p}{;}

	      \PYGdefault{c+cm}{/* pipetrace this uop */}
	      \PYGdefault{n}{ptrace\PYGdefaultZus{}newuop}\PYGdefault{p}{(}\PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}internal ld/st\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{PC}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}
	      \PYGdefault{n}{ptrace\PYGdefaultZus{}newstage}\PYGdefault{p}{(}\PYGdefault{n}{lsq}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{,} \PYGdefault{n}{PST\PYGdefaultZus{}DISPATCH}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}

	      \PYGdefault{c+cm}{/* link eff addr computation onto operand\PYGdefaultZsq{}s output chains */}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}link\PYGdefaultZus{}idep}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* idep\PYGdefaultZus{}ready[] index */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n}{NA}\PYGdefault{p}{);}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}link\PYGdefaultZus{}idep}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* idep\PYGdefaultZus{}ready[] index */}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{n}{in2}\PYGdefault{p}{);}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}link\PYGdefaultZus{}idep}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* idep\PYGdefaultZus{}ready[] index */}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{,} \PYGdefault{n}{in3}\PYGdefault{p}{);}

	      \PYGdefault{c+cm}{/* install output after inputs to prevent self reference */}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}install\PYGdefaultZus{}odep}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* odep\PYGdefaultZus{}list[] index */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n}{DTMP}\PYGdefault{p}{);}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}install\PYGdefaultZus{}odep}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* odep\PYGdefaultZus{}list[] index */}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{n}{NA}\PYGdefault{p}{);}

	      \PYGdefault{c+cm}{/* link memory access onto output chain of eff addr operation */}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}link\PYGdefaultZus{}idep}\PYGdefault{p}{(}\PYGdefault{n}{lsq}\PYGdefault{p}{,}
			    \PYGdefault{c+cm}{/* idep\PYGdefaultZus{}ready[] index */}\PYGdefault{n}{STORE\PYGdefaultZus{}OP\PYGdefaultZus{}INDEX}\PYGdefault{c+cm}{/* 0 */}\PYGdefault{p}{,}
			    \PYGdefault{n}{in1}\PYGdefault{p}{);}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}link\PYGdefaultZus{}idep}\PYGdefault{p}{(}\PYGdefault{n}{lsq}\PYGdefault{p}{,}
			    \PYGdefault{c+cm}{/* idep\PYGdefaultZus{}ready[] index */}\PYGdefault{n}{STORE\PYGdefaultZus{}ADDR\PYGdefaultZus{}INDEX}\PYGdefault{c+cm}{/* 1 */}\PYGdefault{p}{,}
			    \PYGdefault{n}{DTMP}\PYGdefault{p}{);}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}link\PYGdefaultZus{}idep}\PYGdefault{p}{(}\PYGdefault{n}{lsq}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* idep\PYGdefaultZus{}ready[] index */}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{,} \PYGdefault{n}{NA}\PYGdefault{p}{);}

	      \PYGdefault{c+cm}{/* install output after inputs to prevent self reference */}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}install\PYGdefaultZus{}odep}\PYGdefault{p}{(}\PYGdefault{n}{lsq}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* odep\PYGdefaultZus{}list[] index */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n}{out1}\PYGdefault{p}{);}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}install\PYGdefaultZus{}odep}\PYGdefault{p}{(}\PYGdefault{n}{lsq}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* odep\PYGdefaultZus{}list[] index */}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{n}{out2}\PYGdefault{p}{);}

	      \PYGdefault{c+cm}{/* install operation in the RUU and LSQ */}
	      \PYGdefault{n}{n\PYGdefaultZus{}dispatched}\PYGdefault{o}{++}\PYGdefault{p}{;}
	      \PYGdefault{n}{RUU\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}tail} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{p}{;}
	      \PYGdefault{n}{RUU\PYGdefaultZus{}num}\PYGdefault{o}{++}\PYGdefault{p}{;}
	      \PYGdefault{n}{LSQ\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{LSQ\PYGdefaultZus{}tail} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{p}{;}
	      \PYGdefault{n}{LSQ\PYGdefaultZus{}num}\PYGdefault{o}{++}\PYGdefault{p}{;}

	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{OPERANDS\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{))}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} both operands ready, 2 window write accesses */}
		  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} FIXME: currently being read from arch.}
\PYGdefault{c+cm}{		     regfile (in ruu\PYGdefaultZus{}link\PYGdefaultZus{}idep) and written to window here.}
\PYGdefault{c+cm}{		     should these values be read from arch. regfile or }
\PYGdefault{c+cm}{		     another window entry? */}
		  \PYGdefault{n}{window\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		  \PYGdefault{n}{window\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		  \PYGdefault{n}{window\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		  \PYGdefault{n}{window\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}

\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef DYNAMIC\PYGdefaultZus{}AF	}
		  \PYGdefault{n}{regfile\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra}\PYGdefault{p}{);}
		  \PYGdefault{n}{regfile\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rb}\PYGdefault{p}{);}
		  \PYGdefault{n}{regfile\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{+=}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

		  \PYGdefault{c+cm}{/* eff addr computation ready, queue it on ready list */}
		  \PYGdefault{n}{readyq\PYGdefaultZus{}enqueue}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{);}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	      \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ONE\PYGdefaultZus{}OPERANDS\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{))}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} one operand ready, 1 window write accesses */}
		  \PYGdefault{n}{window\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		  \PYGdefault{n}{window\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef DYNAMIC\PYGdefaultZus{}AF	}
		  \PYGdefault{k}{if}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{idep\PYGdefaultZus{}ready}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{])}
		    \PYGdefault{n}{regfile\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra}\PYGdefault{p}{);}
		  \PYGdefault{k}{else}
		    \PYGdefault{n}{regfile\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rb}\PYGdefault{p}{);}
		  \PYGdefault{n}{regfile\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

		\PYGdefault{p}{\PYGdefaultZcb{}}
		      \PYGdefault{c+cm}{/* issue may continue when the load/store is issued */}
	      \PYGdefault{n}{RSLINK\PYGdefaultZus{}INIT}\PYGdefault{p}{(}\PYGdefault{n}{last\PYGdefaultZus{}op}\PYGdefault{p}{,} \PYGdefault{n}{lsq}\PYGdefault{p}{);}

	      \PYGdefault{c+cm}{/* issue stores only, loads are issued by lsq\PYGdefaultZus{}refresh() */}
	      \PYGdefault{k}{if} \PYGdefault{p}{(((}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{))} \PYGdefault{o}{==} \PYGdefault{p}{(}\PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{o}{|}\PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{))}
		  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{OPERANDS\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{n}{lsq}\PYGdefault{p}{))}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} store operand ready, 1 LSQ access */}
		  \PYGdefault{n}{lsq\PYGdefaultZus{}store\PYGdefaultZus{}data\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		  \PYGdefault{c+cm}{/* panic(\PYGdefaultZdq{}store immediately ready\PYGdefaultZdq{}); */}
		  \PYGdefault{c+cm}{/* put operation on ready list, ruu\PYGdefaultZus{}issue() issue it later */}
		  \PYGdefault{n}{readyq\PYGdefaultZus{}enqueue}\PYGdefault{p}{(}\PYGdefault{n}{lsq}\PYGdefault{p}{);}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	  \PYGdefault{k}{else} \PYGdefault{c+cm}{/* !(MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS(op) \PYGdefaultZam{} F\PYGdefaultZus{}MEM) */}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* Wattch: Regfile writes taken care of inside ruu\PYGdefaultZus{}link\PYGdefaultZus{}idep */}
	      \PYGdefault{c+cm}{/* link onto producing operation */}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}link\PYGdefaultZus{}idep}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* idep\PYGdefaultZus{}ready[] index */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n}{in1}\PYGdefault{p}{);}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}link\PYGdefaultZus{}idep}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* idep\PYGdefaultZus{}ready[] index */}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{n}{in2}\PYGdefault{p}{);}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}link\PYGdefaultZus{}idep}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* idep\PYGdefaultZus{}ready[] index */}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{,} \PYGdefault{n}{in3}\PYGdefault{p}{);}

	      \PYGdefault{c+cm}{/* install output after inputs to prevent self reference */}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}install\PYGdefaultZus{}odep}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* odep\PYGdefaultZus{}list[] index */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n}{out1}\PYGdefault{p}{);}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}install\PYGdefaultZus{}odep}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* odep\PYGdefaultZus{}list[] index */}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{,} \PYGdefault{n}{out2}\PYGdefault{p}{);}

	      \PYGdefault{c+cm}{/* install operation in the RUU */}
	      \PYGdefault{n}{n\PYGdefaultZus{}dispatched}\PYGdefault{o}{++}\PYGdefault{p}{;}
	      \PYGdefault{n}{RUU\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}tail} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{p}{;}
	      \PYGdefault{n}{RUU\PYGdefaultZus{}num}\PYGdefault{o}{++}\PYGdefault{p}{;}

	      \PYGdefault{c+cm}{/* issue op if all its reg operands are ready (no mem input) */}
	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{OPERANDS\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{))}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} window access,}
\PYGdefault{c+cm}{		     both operands ready, write them to window,}
\PYGdefault{c+cm}{		  */}
		  \PYGdefault{n}{window\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		  \PYGdefault{n}{window\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		  \PYGdefault{n}{window\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		  \PYGdefault{n}{window\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}

\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef DYNAMIC\PYGdefaultZus{}AF	}
		  \PYGdefault{n}{regfile\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra}\PYGdefault{p}{);}
		  \PYGdefault{n}{regfile\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rb}\PYGdefault{p}{);}
		  \PYGdefault{n}{regfile\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{+=}\PYGdefault{l+m+mi}{2}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

		  \PYGdefault{c+cm}{/* put operation on ready list, ruu\PYGdefaultZus{}issue() issue it later */}
		  \PYGdefault{n}{readyq\PYGdefaultZus{}enqueue}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{);}
		  \PYGdefault{c+cm}{/* issue may continue */}
		  \PYGdefault{n}{last\PYGdefaultZus{}op} \PYGdefault{o}{=} \PYGdefault{n}{RSLINK\PYGdefaultZus{}NULL}\PYGdefault{p}{;}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	      \PYGdefault{k}{else} \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ONE\PYGdefaultZus{}OPERANDS\PYGdefaultZus{}READY}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{p}{))}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{c+cm}{/* Wattch \PYGdefaultZhy{}\PYGdefaultZhy{} window access,}
\PYGdefault{c+cm}{		     one operand ready, write them to window,}
\PYGdefault{c+cm}{		  */}
		  \PYGdefault{n}{window\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
		  \PYGdefault{n}{window\PYGdefaultZus{}preg\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef DYNAMIC\PYGdefaultZus{}AF	}
		  \PYGdefault{k}{if}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{idep\PYGdefaultZus{}ready}\PYGdefault{p}{[}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{])}
		    \PYGdefault{n}{regfile\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}ra}\PYGdefault{p}{);}
		  \PYGdefault{k}{else}
		    \PYGdefault{n}{regfile\PYGdefaultZus{}total\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle} \PYGdefault{o}{+=} \PYGdefault{n}{pop\PYGdefaultZus{}count}\PYGdefault{p}{(}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{val\PYGdefaultZus{}rb}\PYGdefault{p}{);}
		  \PYGdefault{n}{regfile\PYGdefaultZus{}num\PYGdefaultZus{}pop\PYGdefaultZus{}count\PYGdefaultZus{}cycle}\PYGdefault{o}{++}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

		  \PYGdefault{c+cm}{/* could not issue this inst, stall issue until we can */}
		  \PYGdefault{n}{RSLINK\PYGdefaultZus{}INIT}\PYGdefault{p}{(}\PYGdefault{n}{last\PYGdefaultZus{}op}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{p}{);}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	      \PYGdefault{k}{else}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{c+cm}{/* could not issue this inst, stall issue until we can */}
		  \PYGdefault{n}{RSLINK\PYGdefaultZus{}INIT}\PYGdefault{p}{(}\PYGdefault{n}{last\PYGdefaultZus{}op}\PYGdefault{p}{,} \PYGdefault{n}{rs}\PYGdefault{p}{);}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{else}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* this is a NOP, no need to update RUU/LSQ state */}
	  \PYGdefault{n}{rs} \PYGdefault{o}{=} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* one more instruction executed, speculative or otherwise */}
      \PYGdefault{n}{sim\PYGdefaultZus{}total\PYGdefaultZus{}insn}\PYGdefault{o}{++}\PYGdefault{p}{;}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}CTRL}\PYGdefault{p}{)}
	\PYGdefault{n}{sim\PYGdefaultZus{}total\PYGdefaultZus{}branches}\PYGdefault{o}{++}\PYGdefault{p}{;}

      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{spec\PYGdefaultZus{}mode}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}if 0}\PYGdefault{c}{ /* moved above for EIO trace file support */}
\PYGdefault{c}{	  /* one more non\PYGdefaultZhy{}speculative instruction executed */}
\PYGdefault{c}{	  sim\PYGdefaultZus{}num\PYGdefaultZus{}insn++;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif}

	  \PYGdefault{c+cm}{/* if this is a branching instruction update BTB, i.e., only}
\PYGdefault{c+cm}{	     non\PYGdefaultZhy{}speculative state is committed into the BTB */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}CTRL}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}branches}\PYGdefault{o}{++}\PYGdefault{p}{;}
	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{pred} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{bpred\PYGdefaultZus{}spec\PYGdefaultZus{}update} \PYGdefault{o}{==} \PYGdefault{n}{spec\PYGdefaultZus{}ID}\PYGdefault{p}{)}
		\PYGdefault{p}{\PYGdefaultZob{}}
		  \PYGdefault{n}{bpred\PYGdefaultZus{}update}\PYGdefault{p}{(}\PYGdefault{n}{pred}\PYGdefault{p}{,}
			       \PYGdefault{c+cm}{/* branch address */}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,}
			       \PYGdefault{c+cm}{/* actual target address */}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC}\PYGdefault{p}{,}
			       \PYGdefault{c+cm}{/* taken? */}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC} \PYGdefault{o}{!=} \PYGdefault{p}{(}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{+}
						       \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{)),}
			       \PYGdefault{c+cm}{/* pred taken? */}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{!=} \PYGdefault{p}{(}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{+}
							\PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{)),}
			       \PYGdefault{c+cm}{/* correct pred? */}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{==} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC}\PYGdefault{p}{,}
			       \PYGdefault{c+cm}{/* opcode */}\PYGdefault{n}{op}\PYGdefault{p}{,}
			       \PYGdefault{c+cm}{/* predictor update ptr */}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{dir\PYGdefaultZus{}update}\PYGdefault{p}{);}
		\PYGdefault{p}{\PYGdefaultZcb{}}
	    \PYGdefault{p}{\PYGdefaultZcb{}}

	  \PYGdefault{c+cm}{/* is the trace generator trasitioning into mis\PYGdefaultZhy{}speculation mode? */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{!=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{o}{!}\PYGdefault{n}{fetch\PYGdefaultZus{}redirected}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* entering mis\PYGdefaultZhy{}speculation mode, indicate this and save PC */}
	      \PYGdefault{n}{spec\PYGdefaultZus{}mode} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
	      \PYGdefault{n}{rs}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZgt{}}\PYGdefault{n}{recover\PYGdefaultZus{}inst} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
	      \PYGdefault{n}{recover\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* entered decode/allocate stage, indicate in pipe trace */}
      \PYGdefault{n}{ptrace\PYGdefaultZus{}newstage}\PYGdefault{p}{(}\PYGdefault{n}{pseq}\PYGdefault{p}{,} \PYGdefault{n}{PST\PYGdefaultZus{}DISPATCH}\PYGdefault{p}{,}
		      \PYGdefault{p}{(}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{!=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC}\PYGdefault{p}{)} \PYGdefault{o}{?} \PYGdefault{n+nl}{PEV\PYGdefaultZus{}MPOCCURED} \PYGdefault{p}{:} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{op} \PYGdefault{o}{==} \PYGdefault{n}{MD\PYGdefaultZus{}NOP\PYGdefaultZus{}OP}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* end of the line */}
	  \PYGdefault{n}{ptrace\PYGdefaultZus{}endinst}\PYGdefault{p}{(}\PYGdefault{n}{pseq}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* update any stats tracked by PC */}
      \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{\PYGdefaultZlt{}}\PYGdefault{n}{pcstat\PYGdefaultZus{}nelt}\PYGdefault{p}{;} \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k+kt}{counter\PYGdefaultZus{}t} \PYGdefault{n}{newval}\PYGdefault{p}{;}
	  \PYGdefault{k+kt}{int} \PYGdefault{n}{delta}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* check if any tracked stats changed */}
	  \PYGdefault{n}{newval} \PYGdefault{o}{=} \PYGdefault{n}{STATVAL}\PYGdefault{p}{(}\PYGdefault{n}{pcstat\PYGdefaultZus{}stats}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]);}
	  \PYGdefault{n}{delta} \PYGdefault{o}{=} \PYGdefault{n}{newval} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{pcstat\PYGdefaultZus{}lastvals}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{];}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{delta} \PYGdefault{o}{!=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{n}{stat\PYGdefaultZus{}add\PYGdefaultZus{}samples}\PYGdefault{p}{(}\PYGdefault{n}{pcstat\PYGdefaultZus{}sdists}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{],} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{delta}\PYGdefault{p}{);}
	      \PYGdefault{n}{pcstat\PYGdefaultZus{}lastvals}\PYGdefault{p}{[}\PYGdefault{n}{i}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{n}{newval}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* consume instruction from IFETCH \PYGdefaultZhy{}\PYGdefaultZgt{} DISPATCH queue */}
      \PYGdefault{n}{fetch\PYGdefaultZus{}head} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}head}\PYGdefault{o}{+}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{);}
      \PYGdefault{n}{fetch\PYGdefaultZus{}num}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZhy{}}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* check for DLite debugger entry condition */}
      \PYGdefault{n}{made\PYGdefaultZus{}check} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{dlite\PYGdefaultZus{}check\PYGdefaultZus{}break}\PYGdefault{p}{(}\PYGdefault{n}{pred\PYGdefaultZus{}PC}\PYGdefault{p}{,}
			    \PYGdefault{n}{is\PYGdefaultZus{}write} \PYGdefault{o}{?} \PYGdefault{n+nl}{ACCESS\PYGdefaultZus{}WRITE} \PYGdefault{p}{:} \PYGdefault{n}{ACCESS\PYGdefaultZus{}READ}\PYGdefault{p}{,}
			    \PYGdefault{n}{addr}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}insn}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{))}
	\PYGdefault{n}{dlite\PYGdefaultZus{}main}\PYGdefault{p}{(}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{pred\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{regs}\PYGdefault{p}{,} \PYGdefault{n}{mem}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{c+cm}{/* need to enter DLite at least once per cycle */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{made\PYGdefaultZus{}check}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{dlite\PYGdefaultZus{}check\PYGdefaultZus{}break}\PYGdefault{p}{(}\PYGdefault{c+cm}{/* no next PC */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
			    \PYGdefault{n}{is\PYGdefaultZus{}write} \PYGdefault{o}{?} \PYGdefault{n+nl}{ACCESS\PYGdefaultZus{}WRITE} \PYGdefault{p}{:} \PYGdefault{n}{ACCESS\PYGdefaultZus{}READ}\PYGdefault{p}{,}
			    \PYGdefault{n}{addr}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}insn}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{))}
	\PYGdefault{n}{dlite\PYGdefaultZus{}main}\PYGdefault{p}{(}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* no next PC */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{regs}\PYGdefault{p}{,} \PYGdefault{n}{mem}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/*}
\PYGdefault{c+cm}{ *  RUU\PYGdefaultZus{}FETCH() \PYGdefaultZhy{} instruction fetch pipeline stage(s)}
\PYGdefault{c+cm}{ */}

\PYGdefault{c+cm}{/* initialize the instruction fetch pipeline stage */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{fetch\PYGdefaultZus{}init}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{c+cm}{/* allocate the IFETCH \PYGdefaultZhy{}\PYGdefaultZgt{} DISPATCH instruction queue */}
  \PYGdefault{n}{fetch\PYGdefaultZus{}data} \PYGdefault{o}{=}
    \PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{n}{fetch\PYGdefaultZus{}rec} \PYGdefault{o}{*}\PYGdefault{p}{)}\PYGdefault{n}{calloc}\PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size}\PYGdefault{p}{,} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k}{struct} \PYGdefault{n}{fetch\PYGdefaultZus{}rec}\PYGdefault{p}{));}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{)}
    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}out of virtual memory\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{n}{fetch\PYGdefaultZus{}num} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{n}{fetch\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}head} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{n}{IFQ\PYGdefaultZus{}count} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
  \PYGdefault{n}{IFQ\PYGdefaultZus{}fcount} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* dump contents of fetch stage registers and fetch queue */}
\PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{fetch\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{)}			\PYGdefault{c+cm}{/* output stream */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{num}\PYGdefault{p}{,} \PYGdefault{n}{head}\PYGdefault{p}{;}

  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{stream}\PYGdefault{p}{)}
    \PYGdefault{n}{stream} \PYGdefault{o}{=} \PYGdefault{n}{stderr}\PYGdefault{p}{;}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}** fetch stage state **}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}spec\PYGdefaultZus{}mode: \PYGdefaultZpc{}s}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{spec\PYGdefaultZus{}mode} \PYGdefault{o}{?} \PYGdefault{l+s}{\PYGdefaultZdq{}t\PYGdefaultZdq{}} \PYGdefault{o}{:} \PYGdefault{l+s}{\PYGdefaultZdq{}f\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{myfprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}pred\PYGdefaultZus{}PC: 0x\PYGdefaultZpc{}08p, recover\PYGdefaultZus{}PC: 0x\PYGdefaultZpc{}08p}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
	    \PYGdefault{n}{pred\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{recover\PYGdefaultZus{}PC}\PYGdefault{p}{);}
  \PYGdefault{n}{myfprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC: 0x\PYGdefaultZpc{}08p, fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC: 0x\PYGdefaultZpc{}08p}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
	    \PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC}\PYGdefault{p}{);}
  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}** fetch queue contents **}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}
  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}fetch\PYGdefaultZus{}num: \PYGdefaultZpc{}d}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{fetch\PYGdefaultZus{}num}\PYGdefault{p}{);}
  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}fetch\PYGdefaultZus{}head: \PYGdefaultZpc{}d, fetch\PYGdefaultZus{}tail: \PYGdefaultZpc{}d}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
	  \PYGdefault{n}{fetch\PYGdefaultZus{}head}\PYGdefault{p}{,} \PYGdefault{n}{fetch\PYGdefaultZus{}tail}\PYGdefault{p}{);}

  \PYGdefault{n}{num} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}num}\PYGdefault{p}{;}
  \PYGdefault{n}{head} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}head}\PYGdefault{p}{;}
  \PYGdefault{k}{while} \PYGdefault{p}{(}\PYGdefault{n}{num}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}idx: \PYGdefaultZpc{}2d: inst: `\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{head}\PYGdefault{p}{);}
      \PYGdefault{n}{md\PYGdefaultZus{}print\PYGdefaultZus{}insn}\PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{head}\PYGdefault{p}{].}\PYGdefault{n}{IR}\PYGdefault{p}{,} \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{head}\PYGdefault{p}{].}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{stream}\PYGdefault{p}{);}
      \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZsq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{n}{myfprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}         regs\PYGdefaultZus{}PC: 0x\PYGdefaultZpc{}08p, pred\PYGdefaultZus{}PC: 0x\PYGdefaultZpc{}08p}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,}
		\PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{head}\PYGdefault{p}{].}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{head}\PYGdefault{p}{].}\PYGdefault{n}{pred\PYGdefaultZus{}PC}\PYGdefault{p}{);}
      \PYGdefault{n}{head} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{head} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{);}
      \PYGdefault{n}{num}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZhy{}}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{last\PYGdefaultZus{}inst\PYGdefaultZus{}missed} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}
\PYGdefault{k}{static} \PYGdefault{k+kt}{int} \PYGdefault{n}{last\PYGdefaultZus{}inst\PYGdefaultZus{}tmissed} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}

\PYGdefault{c+cm}{/* fetch up as many instruction as one branch prediction and one cache line}
\PYGdefault{c+cm}{   acess will support without overflowing the IFETCH \PYGdefaultZhy{}\PYGdefaultZgt{} DISPATCH QUEUE */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{void}
\PYGdefault{n+nf}{ruu\PYGdefaultZus{}fetch}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{i}\PYGdefault{p}{,} \PYGdefault{n}{lat}\PYGdefault{p}{,} \PYGdefault{n}{tlb\PYGdefaultZus{}lat}\PYGdefault{p}{,} \PYGdefault{n}{done} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}
  \PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t} \PYGdefault{n}{inst}\PYGdefault{p}{;}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx}\PYGdefault{p}{;}
  \PYGdefault{k+kt}{int} \PYGdefault{n}{branch\PYGdefaultZus{}cnt}\PYGdefault{p}{;}

  \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{i}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{n}{branch\PYGdefaultZus{}cnt}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
       \PYGdefault{c+cm}{/* fetch up to as many instruction as the DISPATCH stage can decode */}
       \PYGdefault{n}{i} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}decode\PYGdefaultZus{}width} \PYGdefault{o}{*} \PYGdefault{n}{fetch\PYGdefaultZus{}speed}\PYGdefault{p}{)}
       \PYGdefault{c+cm}{/* fetch until IFETCH \PYGdefaultZhy{}\PYGdefaultZgt{} DISPATCH queue fills */}
       \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{fetch\PYGdefaultZus{}num} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size}
       \PYGdefault{c+cm}{/* and no IFETCH blocking condition encountered */}
       \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{o}{!}\PYGdefault{n}{done}\PYGdefault{p}{;}
       \PYGdefault{n}{i}\PYGdefault{o}{++}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}

      \PYGdefault{c+cm}{/* Wattch: add power for i\PYGdefaultZhy{}fetch stage */}
      \PYGdefault{n}{icache\PYGdefaultZus{}access}\PYGdefault{o}{++}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* fetch an instruction at the next predicted fetch address */}
      \PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* is this a bogus text address? (can happen on mis\PYGdefaultZhy{}spec path) */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{ld\PYGdefaultZus{}text\PYGdefaultZus{}base} \PYGdefault{o}{\PYGdefaultZlt{}=} \PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC}
	  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{p}{(}\PYGdefault{n}{ld\PYGdefaultZus{}text\PYGdefaultZus{}base}\PYGdefault{o}{+}\PYGdefault{n}{ld\PYGdefaultZus{}text\PYGdefaultZus{}size}\PYGdefault{p}{)}
	  \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{o}{!}\PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{)}\PYGdefault{o}{\PYGdefaultZhy{}}\PYGdefault{l+m+mi}{1}\PYGdefault{p}{)))}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* read instruction from memory */}
	  \PYGdefault{n}{MD\PYGdefaultZus{}FETCH\PYGdefaultZus{}INST}\PYGdefault{p}{(}\PYGdefault{n}{inst}\PYGdefault{p}{,} \PYGdefault{n}{mem}\PYGdefault{p}{,} \PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* address is within program text, read instruction from memory */}
	  \PYGdefault{n}{lat} \PYGdefault{o}{=} \PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}lat}\PYGdefault{p}{;}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il1}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* access the I\PYGdefaultZhy{}cache */}
	      \PYGdefault{n}{lat} \PYGdefault{o}{=}
		\PYGdefault{n}{cache\PYGdefaultZus{}access}\PYGdefault{p}{(}\PYGdefault{n}{cache\PYGdefaultZus{}il1}\PYGdefault{p}{,} \PYGdefault{n}{Read}\PYGdefault{p}{,} \PYGdefault{n}{IACOMPRESS}\PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC}\PYGdefault{p}{),}
			     \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{n}{ISCOMPRESS}\PYGdefault{p}{(}\PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{)),} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{,}
			     \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{lat} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}lat}\PYGdefault{p}{)}
		\PYGdefault{n}{last\PYGdefaultZus{}inst\PYGdefaultZus{}missed} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}

	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{itlb}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* access the I\PYGdefaultZhy{}TLB, NOTE: this code will initiate}
\PYGdefault{c+cm}{		 speculative TLB misses */}
	      \PYGdefault{n}{tlb\PYGdefaultZus{}lat} \PYGdefault{o}{=}
		\PYGdefault{n}{cache\PYGdefaultZus{}access}\PYGdefault{p}{(}\PYGdefault{n}{itlb}\PYGdefault{p}{,} \PYGdefault{n}{Read}\PYGdefault{p}{,} \PYGdefault{n}{IACOMPRESS}\PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC}\PYGdefault{p}{),}
			     \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{n}{ISCOMPRESS}\PYGdefault{p}{(}\PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{)),} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{,}
			     \PYGdefault{n+nb}{NULL}\PYGdefault{p}{,} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{);}
	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{tlb\PYGdefaultZus{}lat} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)}
		\PYGdefault{n}{last\PYGdefaultZus{}inst\PYGdefaultZus{}tmissed} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}

	      \PYGdefault{c+cm}{/* I\PYGdefaultZhy{}cache/I\PYGdefaultZhy{}TLB accesses occur in parallel */}
	      \PYGdefault{n}{lat} \PYGdefault{o}{=} \PYGdefault{n}{MAX}\PYGdefault{p}{(}\PYGdefault{n}{tlb\PYGdefaultZus{}lat}\PYGdefault{p}{,} \PYGdefault{n}{lat}\PYGdefault{p}{);}
	    \PYGdefault{p}{\PYGdefaultZcb{}}

	  \PYGdefault{c+cm}{/* I\PYGdefaultZhy{}cache/I\PYGdefaultZhy{}TLB miss? assumes I\PYGdefaultZhy{}cache hit \PYGdefaultZgt{}= I\PYGdefaultZhy{}TLB hit */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{lat} \PYGdefault{o}{!=} \PYGdefault{n}{cache\PYGdefaultZus{}il1\PYGdefaultZus{}lat}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* I\PYGdefaultZhy{}cache miss, block fetch until it is resolved */}
	      \PYGdefault{n}{ruu\PYGdefaultZus{}fetch\PYGdefaultZus{}issue\PYGdefaultZus{}delay} \PYGdefault{o}{+=} \PYGdefault{n}{lat} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{;}
	      \PYGdefault{k}{break}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	  \PYGdefault{c+cm}{/* else, I\PYGdefaultZhy{}cache/I\PYGdefaultZhy{}TLB hit */}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{else}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* fetch PC is bogus, send a NOP down the pipeline */}
	  \PYGdefault{n}{inst} \PYGdefault{o}{=} \PYGdefault{n}{MD\PYGdefaultZus{}NOP\PYGdefaultZus{}INST}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* have a valid inst, here */}

      \PYGdefault{c+cm}{/* possibly use the BTB target */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{pred}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{k}{enum} \PYGdefault{n}{md\PYGdefaultZus{}opcode} \PYGdefault{n}{op}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* pre\PYGdefaultZhy{}decode instruction, used for bpred stats recording */}
	  \PYGdefault{n}{MD\PYGdefaultZus{}SET\PYGdefaultZus{}OPCODE}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{,} \PYGdefault{n}{inst}\PYGdefault{p}{);}
	  
	  \PYGdefault{c+cm}{/* get the next predicted fetch address; only use branch predictor}
\PYGdefault{c+cm}{	     result for branches (assumes pre\PYGdefaultZhy{}decode bits); NOTE: returned}
\PYGdefault{c+cm}{	     value may be 1 if bpred can only predict a direction */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}CTRL}\PYGdefault{p}{)}
	    \PYGdefault{n}{fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC} \PYGdefault{o}{=}
	      \PYGdefault{n}{bpred\PYGdefaultZus{}lookup}\PYGdefault{p}{(}\PYGdefault{n}{pred}\PYGdefault{p}{,}
			   \PYGdefault{c+cm}{/* branch address */}\PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC}\PYGdefault{p}{,}
			   \PYGdefault{c+cm}{/* target address *//* FIXME: not computed */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,}
			   \PYGdefault{c+cm}{/* opcode */}\PYGdefault{n}{op}\PYGdefault{p}{,}
			   \PYGdefault{c+cm}{/* call? */}\PYGdefault{n}{MD\PYGdefaultZus{}IS\PYGdefaultZus{}CALL}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{),}
			   \PYGdefault{c+cm}{/* return? */}\PYGdefault{n}{MD\PYGdefaultZus{}IS\PYGdefaultZus{}RETURN}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{),}
			   \PYGdefault{c+cm}{/* updt */}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}tail}\PYGdefault{p}{].}\PYGdefault{n}{dir\PYGdefaultZus{}update}\PYGdefault{p}{),}
			   \PYGdefault{c+cm}{/* RSB index */}\PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx}\PYGdefault{p}{);}
	  \PYGdefault{k}{else}
	    \PYGdefault{n}{fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* valid address returned from branch predictor? */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* no predicted taken target, attempt not taken target */}
	      \PYGdefault{n}{fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC} \PYGdefault{o}{+} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{);}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	  \PYGdefault{k}{else}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{c+cm}{/* go with target, NOTE: discontinuous fetch, so terminate */}
	      \PYGdefault{n}{branch\PYGdefaultZus{}cnt}\PYGdefault{o}{++}\PYGdefault{p}{;}
	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{branch\PYGdefaultZus{}cnt} \PYGdefault{o}{\PYGdefaultZgt{}=} \PYGdefault{n}{fetch\PYGdefaultZus{}speed}\PYGdefault{p}{)}
		\PYGdefault{n}{done} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}
	\PYGdefault{p}{\PYGdefaultZcb{}}
      \PYGdefault{k}{else}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* no predictor, just default to predict not taken, and}
\PYGdefault{c+cm}{	     continue fetching instructions linearly */}
	  \PYGdefault{n}{fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC} \PYGdefault{o}{+} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* commit this instruction to the IFETCH \PYGdefaultZhy{}\PYGdefaultZgt{} DISPATCH queue */}
      \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}tail}\PYGdefault{p}{].}\PYGdefault{n}{IR} \PYGdefault{o}{=} \PYGdefault{n}{inst}\PYGdefault{p}{;}
      \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}tail}\PYGdefault{p}{].}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC}\PYGdefault{p}{;}
      \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}tail}\PYGdefault{p}{].}\PYGdefault{n}{pred\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC}\PYGdefault{p}{;}
      \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}tail}\PYGdefault{p}{].}\PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx} \PYGdefault{o}{=} \PYGdefault{n}{stack\PYGdefaultZus{}recover\PYGdefaultZus{}idx}\PYGdefault{p}{;}
      \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}tail}\PYGdefault{p}{].}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq} \PYGdefault{o}{=} \PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{o}{++}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* for pipe trace */}
      \PYGdefault{n}{ptrace\PYGdefaultZus{}newinst}\PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}tail}\PYGdefault{p}{].}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{,}
		     \PYGdefault{n}{inst}\PYGdefault{p}{,} \PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}tail}\PYGdefault{p}{].}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,}
		     \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}
      \PYGdefault{n}{ptrace\PYGdefaultZus{}newstage}\PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}data}\PYGdefault{p}{[}\PYGdefault{n}{fetch\PYGdefaultZus{}tail}\PYGdefault{p}{].}\PYGdefault{n}{ptrace\PYGdefaultZus{}seq}\PYGdefault{p}{,}
		      \PYGdefault{n}{PST\PYGdefaultZus{}IFETCH}\PYGdefault{p}{,}
		      \PYGdefault{p}{((}\PYGdefault{n}{last\PYGdefaultZus{}inst\PYGdefaultZus{}missed} \PYGdefault{o}{?} \PYGdefault{n+nl}{PEV\PYGdefaultZus{}CACHEMISS} \PYGdefault{p}{:} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
		       \PYGdefault{o}{|} \PYGdefault{p}{(}\PYGdefault{n}{last\PYGdefaultZus{}inst\PYGdefaultZus{}tmissed} \PYGdefault{o}{?} \PYGdefault{n+nl}{PEV\PYGdefaultZus{}TLBMISS} \PYGdefault{p}{:} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)));}
      \PYGdefault{n}{last\PYGdefaultZus{}inst\PYGdefaultZus{}missed} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}
      \PYGdefault{n}{last\PYGdefaultZus{}inst\PYGdefaultZus{}tmissed} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* adjust instruction fetch queue */}
      \PYGdefault{n}{fetch\PYGdefaultZus{}tail} \PYGdefault{o}{=} \PYGdefault{p}{(}\PYGdefault{n}{fetch\PYGdefaultZus{}tail} \PYGdefault{o}{+} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{p}{(}\PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{l+m+mi}{1}\PYGdefault{p}{);}
      \PYGdefault{n}{fetch\PYGdefaultZus{}num}\PYGdefault{o}{++}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}

\PYGdefault{c+cm}{/* default machine state accessor, used by DLite */}
\PYGdefault{k}{static} \PYGdefault{k+kt}{char} \PYGdefault{o}{*}					\PYGdefault{c+cm}{/* err str, NULL for no err */}
\PYGdefault{n}{simoo\PYGdefaultZus{}mstate\PYGdefaultZus{}obj}\PYGdefault{p}{(}\PYGdefault{k+kt}{FILE} \PYGdefault{o}{*}\PYGdefault{n}{stream}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* output stream */}
		 \PYGdefault{k+kt}{char} \PYGdefault{o}{*}\PYGdefault{n}{cmd}\PYGdefault{p}{,}			\PYGdefault{c+cm}{/* optional command string */}
		 \PYGdefault{k}{struct} \PYGdefault{k+kt}{regs\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{regs}\PYGdefault{p}{,}		\PYGdefault{c+cm}{/* registers to access */}
		 \PYGdefault{k}{struct} \PYGdefault{k+kt}{mem\PYGdefaultZus{}t} \PYGdefault{o}{*}\PYGdefault{n}{mem}\PYGdefault{p}{)}		\PYGdefault{c+cm}{/* memory space to access */}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{cmd} \PYGdefault{o}{||} \PYGdefault{o}{!}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}help\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{,}
\PYGdefault{l+s}{\PYGdefaultZdq{}mstate commands:}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    mstate help   \PYGdefaultZhy{} show all machine\PYGdefaultZhy{}specific commands (this list)}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    mstate stats  \PYGdefaultZhy{} dump all statistical variables}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    mstate res    \PYGdefaultZhy{} dump current functional unit resource states}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    mstate ruu    \PYGdefaultZhy{} dump contents of the register update unit}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    mstate lsq    \PYGdefaultZhy{} dump contents of the load/store queue}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    mstate eventq \PYGdefaultZhy{} dump contents of event queue}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    mstate readyq \PYGdefaultZhy{} dump contents of ready instruction queue}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    mstate cv     \PYGdefaultZhy{} dump contents of the register create vector}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    mstate rspec  \PYGdefaultZhy{} dump contents of speculative regs}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    mstate mspec  \PYGdefaultZhy{} dump contents of speculative memory}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}    mstate fetch  \PYGdefaultZhy{} dump contents of fetch stage registers and fetch queue}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}
	    \PYGdefault{p}{);}
  \PYGdefault{k}{else} \PYGdefault{n+nf}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}stats\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* just dump intermediate stats */}
      \PYGdefault{n}{sim\PYGdefaultZus{}print\PYGdefaultZus{}stats}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{n+nf}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}res\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* dump resource state */}
      \PYGdefault{n}{res\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{n}{fu\PYGdefaultZus{}pool}\PYGdefault{p}{,} \PYGdefault{n}{stream}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{n+nf}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}ruu\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* dump RUU contents */}
      \PYGdefault{n}{ruu\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{n+nf}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}lsq\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* dump LSQ contents */}
      \PYGdefault{n}{lsq\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{n+nf}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}eventq\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* dump event queue contents */}
      \PYGdefault{n}{eventq\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{n+nf}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}readyq\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* dump event queue contents */}
      \PYGdefault{n}{readyq\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{n+nf}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}cv\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* dump event queue contents */}
      \PYGdefault{n}{cv\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{n+nf}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}rspec\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* dump event queue contents */}
      \PYGdefault{n}{rspec\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{n+nf}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}mspec\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* dump event queue contents */}
      \PYGdefault{n}{mspec\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else} \PYGdefault{n+nf}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{strcmp}\PYGdefault{p}{(}\PYGdefault{n}{cmd}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}fetch\PYGdefaultZdq{}}\PYGdefault{p}{))}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* dump event queue contents */}
      \PYGdefault{n}{fetch\PYGdefaultZus{}dump}\PYGdefault{p}{(}\PYGdefault{n}{stream}\PYGdefault{p}{);}
    \PYGdefault{p}{\PYGdefaultZcb{}}
  \PYGdefault{k}{else}
    \PYGdefault{k}{return} \PYGdefault{l+s}{\PYGdefaultZdq{}unknown mstate command\PYGdefaultZdq{}}\PYGdefault{p}{;}

  \PYGdefault{c+cm}{/* no error */}
  \PYGdefault{k}{return} \PYGdefault{n+nb}{NULL}\PYGdefault{p}{;}
\PYGdefault{p}{\PYGdefaultZcb{}}


\PYGdefault{c+cm}{/* start simulation, program loaded, processor precise state initialized */}
\PYGdefault{k+kt}{void}
\PYGdefault{n}{sim\PYGdefaultZus{}main}\PYGdefault{p}{(}\PYGdefault{k+kt}{void}\PYGdefault{p}{)}
\PYGdefault{p}{\PYGdefaultZob{}}
  \PYGdefault{c+cm}{/* ignore any floating point exceptions, they may occur on mis\PYGdefaultZhy{}speculated}
\PYGdefault{c+cm}{     execution paths */}
  \PYGdefault{n}{signal}\PYGdefault{p}{(}\PYGdefault{n}{SIGFPE}\PYGdefault{p}{,} \PYGdefault{n}{SIG\PYGdefaultZus{}IGN}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* set up program entry state */}
  \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{ld\PYGdefaultZus{}prog\PYGdefaultZus{}entry}\PYGdefault{p}{;}
  \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{+} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* check for DLite debugger entry condition */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{dlite\PYGdefaultZus{}check\PYGdefaultZus{}break}\PYGdefault{p}{(}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* no access */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{c+cm}{/* addr */}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{,} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{))}
    \PYGdefault{n}{dlite\PYGdefaultZus{}main}\PYGdefault{p}{(}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{+} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{),}
	       \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{regs}\PYGdefault{p}{,} \PYGdefault{n}{mem}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* fast forward simulator loop, performs functional simulation for}
\PYGdefault{c+cm}{     FASTFWD\PYGdefaultZus{}COUNT insts, then turns on performance (timing) simulation */}
  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{fastfwd\PYGdefaultZus{}count} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{k+kt}{int} \PYGdefault{n}{icount}\PYGdefault{p}{;}
      \PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t} \PYGdefault{n}{inst}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* actual instruction bits */}
      \PYGdefault{k}{enum} \PYGdefault{n}{md\PYGdefaultZus{}opcode} \PYGdefault{n}{op}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* decoded opcode enum */}
      \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{target\PYGdefaultZus{}PC}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* actual next/target PC address */}
      \PYGdefault{k+kt}{md\PYGdefaultZus{}addr\PYGdefaultZus{}t} \PYGdefault{n}{addr}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* effective address, if load/store */}
      \PYGdefault{k+kt}{int} \PYGdefault{n}{is\PYGdefaultZus{}write}\PYGdefault{p}{;}			\PYGdefault{c+cm}{/* store? */}
      \PYGdefault{k+kt}{byte\PYGdefaultZus{}t} \PYGdefault{n}{temp\PYGdefaultZus{}byte} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* temp variable for spec mem access */}
      \PYGdefault{k+kt}{half\PYGdefaultZus{}t} \PYGdefault{n}{temp\PYGdefaultZus{}half} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* \PYGdefaultZdq{} ditto \PYGdefaultZdq{} */}
      \PYGdefault{k+kt}{word\PYGdefaultZus{}t} \PYGdefault{n}{temp\PYGdefaultZus{}word} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* \PYGdefaultZdq{} ditto \PYGdefaultZdq{} */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef HOST\PYGdefaultZus{}HAS\PYGdefaultZus{}QWORD}
      \PYGdefault{k+kt}{qword\PYGdefaultZus{}t} \PYGdefault{n}{temp\PYGdefaultZus{}qword} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}		\PYGdefault{c+cm}{/* \PYGdefaultZdq{} ditto \PYGdefaultZdq{} */}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif }\PYGdefault{c+cm}{/* HOST\PYGdefaultZus{}HAS\PYGdefaultZus{}QWORD */}
      \PYGdefault{k}{enum} \PYGdefault{n}{md\PYGdefaultZus{}fault\PYGdefaultZus{}type} \PYGdefault{n}{fault}\PYGdefault{p}{;}

      \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stderr}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim: ** fast forwarding \PYGdefaultZpc{}d insts **}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{fastfwd\PYGdefaultZus{}count}\PYGdefault{p}{);}

      \PYGdefault{k}{for} \PYGdefault{p}{(}\PYGdefault{n}{icount}\PYGdefault{o}{=}\PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{icount} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{fastfwd\PYGdefaultZus{}count}\PYGdefault{p}{;} \PYGdefault{n}{icount}\PYGdefault{o}{++}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* maintain \PYGdefaultZdl{}r0 semantics */}
	  \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}R}\PYGdefault{p}{[}\PYGdefault{n}{MD\PYGdefaultZus{}REG\PYGdefaultZus{}ZERO}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}ifdef TARGET\PYGdefaultZus{}ALPHA}
	  \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}F}\PYGdefault{p}{.}\PYGdefault{n}{d}\PYGdefault{p}{[}\PYGdefault{n}{MD\PYGdefaultZus{}REG\PYGdefaultZus{}ZERO}\PYGdefault{p}{]} \PYGdefault{o}{=} \PYGdefault{l+m+mf}{0.0}\PYGdefault{p}{;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}endif }\PYGdefault{c+cm}{/* TARGET\PYGdefaultZus{}ALPHA */}

	  \PYGdefault{c+cm}{/* get the next instruction to execute */}
	  \PYGdefault{n}{MD\PYGdefaultZus{}FETCH\PYGdefaultZus{}INST}\PYGdefault{p}{(}\PYGdefault{n}{inst}\PYGdefault{p}{,} \PYGdefault{n}{mem}\PYGdefault{p}{,} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* set default reference address */}
	  \PYGdefault{n}{addr} \PYGdefault{o}{=} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{;} \PYGdefault{n}{is\PYGdefaultZus{}write} \PYGdefault{o}{=} \PYGdefault{n}{FALSE}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* set default fault \PYGdefaultZhy{} none */}
	  \PYGdefault{n}{fault} \PYGdefault{o}{=} \PYGdefault{n}{md\PYGdefaultZus{}fault\PYGdefaultZus{}none}\PYGdefault{p}{;}

	  \PYGdefault{c+cm}{/* decode the instruction */}
	  \PYGdefault{n}{MD\PYGdefaultZus{}SET\PYGdefaultZus{}OPCODE}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{,} \PYGdefault{n}{inst}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* execute the instruction */}
	  \PYGdefault{k}{switch} \PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DEFINST(OP,MSK,NAME,OPFORM,RES,FLAGS,O1,O2,I1,I2,I3)		\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	    case OP:							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	      SYMCAT(OP,\PYGdefaultZus{}IMPL);						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	      break;}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DEFLINK(OP,MSK,NAME,MASK,SHIFT)					\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	    case OP:							\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	      panic(\PYGdefaultZdq{}attempted to execute a linking opcode\PYGdefaultZdq{});}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define CONNECT(OP)}
\PYGdefault{c+cp}{\PYGdefaultZsh{}undef DECLARE\PYGdefaultZus{}FAULT}
\PYGdefault{c+cp}{\PYGdefaultZsh{}define DECLARE\PYGdefaultZus{}FAULT(FAULT)						\PYGdefaultZbs{}}
\PYGdefault{c+cp}{	      \PYGdefaultZob{} fault = (FAULT); break; \PYGdefaultZcb{}}
\PYGdefault{c+cp}{\PYGdefaultZsh{}include \PYGdefaultZdq{}machine.def\PYGdefaultZdq{}}
	    \PYGdefault{k}{default}\PYGdefault{o}{:}
	      \PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}attempted to execute a bogus opcode\PYGdefaultZdq{}}\PYGdefault{p}{);}
	    \PYGdefault{p}{\PYGdefaultZcb{}}

	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{fault} \PYGdefault{o}{!=} \PYGdefault{n}{md\PYGdefaultZus{}fault\PYGdefaultZus{}none}\PYGdefault{p}{)}
	    \PYGdefault{n}{fatal}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}fault (\PYGdefaultZpc{}d) detected @ 0x\PYGdefaultZpc{}08p\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{fault}\PYGdefault{p}{,} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* update memory access stats */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}MEM}\PYGdefault{p}{)}
	    \PYGdefault{p}{\PYGdefaultZob{}}
	      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{MD\PYGdefaultZus{}OP\PYGdefaultZus{}FLAGS}\PYGdefault{p}{(}\PYGdefault{n}{op}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZam{}} \PYGdefault{n}{F\PYGdefaultZus{}STORE}\PYGdefault{p}{)}
		\PYGdefault{n}{is\PYGdefaultZus{}write} \PYGdefault{o}{=} \PYGdefault{n}{TRUE}\PYGdefault{p}{;}
	    \PYGdefault{p}{\PYGdefaultZcb{}}

	  \PYGdefault{c+cm}{/* check for DLite debugger entry condition */}
	  \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{dlite\PYGdefaultZus{}check\PYGdefaultZus{}break}\PYGdefault{p}{(}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC}\PYGdefault{p}{,}
				\PYGdefault{n}{is\PYGdefaultZus{}write} \PYGdefault{o}{?} \PYGdefault{n+nl}{ACCESS\PYGdefaultZus{}WRITE} \PYGdefault{p}{:} \PYGdefault{n}{ACCESS\PYGdefaultZus{}READ}\PYGdefault{p}{,}
				\PYGdefault{n}{addr}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}insn}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}insn}\PYGdefault{p}{))}
	    \PYGdefault{n}{dlite\PYGdefaultZus{}main}\PYGdefault{p}{(}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}insn}\PYGdefault{p}{,} \PYGdefault{o}{\PYGdefaultZam{}}\PYGdefault{n}{regs}\PYGdefault{p}{,} \PYGdefault{n}{mem}\PYGdefault{p}{);}

	  \PYGdefault{c+cm}{/* go to the next instruction */}
	  \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC}\PYGdefault{p}{;}
	  \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}NPC} \PYGdefault{o}{+=} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{);}
	\PYGdefault{p}{\PYGdefaultZcb{}}
    \PYGdefault{p}{\PYGdefaultZcb{}}

  \PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{stderr}\PYGdefault{p}{,} \PYGdefault{l+s}{\PYGdefaultZdq{}sim: ** starting performance simulation **}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* set up timing simulation entry state */}
  \PYGdefault{n}{fetch\PYGdefaultZus{}regs\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{);}
  \PYGdefault{n}{fetch\PYGdefaultZus{}pred\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{;}
  \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{=} \PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{k}{sizeof}\PYGdefault{p}{(}\PYGdefault{k+kt}{md\PYGdefaultZus{}inst\PYGdefaultZus{}t}\PYGdefault{p}{);}

  \PYGdefault{c+cm}{/* main simulator loop, NOTE: the pipe stages are traverse in reverse order}
\PYGdefault{c+cm}{     to eliminate this/next state synchronization and relaxation problems */}
  \PYGdefault{k}{for} \PYGdefault{p}{(;;)}
    \PYGdefault{p}{\PYGdefaultZob{}}
      \PYGdefault{c+cm}{/* RUU/LSQ sanity checks */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{RUU\PYGdefaultZus{}num} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{LSQ\PYGdefaultZus{}num}\PYGdefault{p}{)}
	\PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}RUU\PYGdefaultZus{}num \PYGdefaultZlt{} LSQ\PYGdefaultZus{}num\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{k}{if} \PYGdefault{p}{(((}\PYGdefault{n}{RUU\PYGdefaultZus{}head} \PYGdefault{o}{+} \PYGdefault{n}{RUU\PYGdefaultZus{}num}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{p}{)} \PYGdefault{o}{!=} \PYGdefault{n}{RUU\PYGdefaultZus{}tail}\PYGdefault{p}{)}
	\PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}RUU\PYGdefaultZus{}head/RUU\PYGdefaultZus{}tail wedged\PYGdefaultZdq{}}\PYGdefault{p}{);}
      \PYGdefault{k}{if} \PYGdefault{p}{(((}\PYGdefault{n}{LSQ\PYGdefaultZus{}head} \PYGdefault{o}{+} \PYGdefault{n}{LSQ\PYGdefaultZus{}num}\PYGdefault{p}{)} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{p}{)} \PYGdefault{o}{!=} \PYGdefault{n}{LSQ\PYGdefaultZus{}tail}\PYGdefault{p}{)}
	\PYGdefault{n}{panic}\PYGdefault{p}{(}\PYGdefault{l+s}{\PYGdefaultZdq{}LSQ\PYGdefaultZus{}head/LSQ\PYGdefaultZus{}tail wedged\PYGdefaultZdq{}}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* added for Wattch to clear hardware access counters */}
      \PYGdefault{n}{clear\PYGdefaultZus{}access\PYGdefaultZus{}stats}\PYGdefault{p}{();}

      \PYGdefault{c+cm}{/* check if pipetracing is still active */}
      \PYGdefault{n}{ptrace\PYGdefaultZus{}check\PYGdefaultZus{}active}\PYGdefault{p}{(}\PYGdefault{n}{regs}\PYGdefault{p}{.}\PYGdefault{n}{regs\PYGdefaultZus{}PC}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}insn}\PYGdefault{p}{,} \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* indicate new cycle in pipetrace */}
      \PYGdefault{n}{ptrace\PYGdefaultZus{}newcycle}\PYGdefault{p}{(}\PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* commit entries from RUU/LSQ to architected register file */}
      \PYGdefault{n}{ruu\PYGdefaultZus{}commit}\PYGdefault{p}{();}

      \PYGdefault{c+cm}{/* service function unit release events */}
      \PYGdefault{n}{ruu\PYGdefaultZus{}release\PYGdefaultZus{}fu}\PYGdefault{p}{();}

      \PYGdefault{c+cm}{/* ==\PYGdefaultZgt{} may have ready queue entries carried over from previous cycles */}

      \PYGdefault{c+cm}{/* service result completions, also readies dependent operations */}
      \PYGdefault{c+cm}{/* ==\PYGdefaultZgt{} inserts operations into ready queue \PYGdefaultZhy{}\PYGdefaultZhy{}\PYGdefaultZgt{} register deps resolved */}
      \PYGdefault{n}{ruu\PYGdefaultZus{}writeback}\PYGdefault{p}{();}

      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{bugcompat\PYGdefaultZus{}mode}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* try to locate memory operations that are ready to execute */}
	  \PYGdefault{c+cm}{/* ==\PYGdefaultZgt{} inserts operations into ready queue \PYGdefaultZhy{}\PYGdefaultZhy{}\PYGdefaultZgt{} mem deps resolved */}
	  \PYGdefault{n}{lsq\PYGdefaultZus{}refresh}\PYGdefault{p}{();}

	  \PYGdefault{c+cm}{/* issue operations ready to execute from a previous cycle */}
	  \PYGdefault{c+cm}{/* \PYGdefaultZlt{}== drains ready queue \PYGdefaultZlt{}\PYGdefaultZhy{}\PYGdefaultZhy{} ready operations commence execution */}
	  \PYGdefault{n}{ruu\PYGdefaultZus{}issue}\PYGdefault{p}{();}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* decode and dispatch new operations */}
      \PYGdefault{c+cm}{/* ==\PYGdefaultZgt{} insert ops w/ no deps or all regs ready \PYGdefaultZhy{}\PYGdefaultZhy{}\PYGdefaultZgt{} reg deps resolved */}
      \PYGdefault{n}{ruu\PYGdefaultZus{}dispatch}\PYGdefault{p}{();}

      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{bugcompat\PYGdefaultZus{}mode}\PYGdefault{p}{)}
	\PYGdefault{p}{\PYGdefaultZob{}}
	  \PYGdefault{c+cm}{/* try to locate memory operations that are ready to execute */}
	  \PYGdefault{c+cm}{/* ==\PYGdefaultZgt{} inserts operations into ready queue \PYGdefaultZhy{}\PYGdefaultZhy{}\PYGdefaultZgt{} mem deps resolved */}
	  \PYGdefault{n}{lsq\PYGdefaultZus{}refresh}\PYGdefault{p}{();}

	  \PYGdefault{c+cm}{/* issue operations ready to execute from a previous cycle */}
	  \PYGdefault{c+cm}{/* \PYGdefaultZlt{}== drains ready queue \PYGdefaultZlt{}\PYGdefaultZhy{}\PYGdefaultZhy{} ready operations commence execution */}
	  \PYGdefault{n}{ruu\PYGdefaultZus{}issue}\PYGdefault{p}{();}
	\PYGdefault{p}{\PYGdefaultZcb{}}

      \PYGdefault{c+cm}{/* call instruction fetch unit if it is not blocked */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{o}{!}\PYGdefault{n}{ruu\PYGdefaultZus{}fetch\PYGdefaultZus{}issue\PYGdefaultZus{}delay}\PYGdefault{p}{)}
	\PYGdefault{n}{ruu\PYGdefaultZus{}fetch}\PYGdefault{p}{();}
      \PYGdefault{k}{else}
	\PYGdefault{n}{ruu\PYGdefaultZus{}fetch\PYGdefaultZus{}issue\PYGdefaultZus{}delay}\PYGdefault{o}{\PYGdefaultZhy{}\PYGdefaultZhy{}}\PYGdefault{p}{;}

      \PYGdefault{c+cm}{/* Added by Wattch to update per\PYGdefaultZhy{}cycle power statistics */}
      \PYGdefault{n}{update\PYGdefaultZus{}power\PYGdefaultZus{}stats}\PYGdefault{p}{();}

      \PYGdefault{c+cm}{/* update buffer occupancy stats */}
      \PYGdefault{n}{IFQ\PYGdefaultZus{}count} \PYGdefault{o}{+=} \PYGdefault{n}{fetch\PYGdefaultZus{}num}\PYGdefault{p}{;}
      \PYGdefault{n}{IFQ\PYGdefaultZus{}fcount} \PYGdefault{o}{+=} \PYGdefault{p}{((}\PYGdefault{n}{fetch\PYGdefaultZus{}num} \PYGdefault{o}{==} \PYGdefault{n}{ruu\PYGdefaultZus{}ifq\PYGdefaultZus{}size}\PYGdefault{p}{)} \PYGdefault{o}{?} \PYGdefault{l+m+mi}{1} \PYGdefault{o}{:} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}
      \PYGdefault{n}{RUU\PYGdefaultZus{}count} \PYGdefault{o}{+=} \PYGdefault{n}{RUU\PYGdefaultZus{}num}\PYGdefault{p}{;}
      \PYGdefault{n}{RUU\PYGdefaultZus{}fcount} \PYGdefault{o}{+=} \PYGdefault{p}{((}\PYGdefault{n}{RUU\PYGdefaultZus{}num} \PYGdefault{o}{==} \PYGdefault{n}{RUU\PYGdefaultZus{}size}\PYGdefault{p}{)} \PYGdefault{o}{?} \PYGdefault{l+m+mi}{1} \PYGdefault{o}{:} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}
      \PYGdefault{n}{LSQ\PYGdefaultZus{}count} \PYGdefault{o}{+=} \PYGdefault{n}{LSQ\PYGdefaultZus{}num}\PYGdefault{p}{;}
      \PYGdefault{n}{LSQ\PYGdefaultZus{}fcount} \PYGdefault{o}{+=} \PYGdefault{p}{((}\PYGdefault{n}{LSQ\PYGdefaultZus{}num} \PYGdefault{o}{==} \PYGdefault{n}{LSQ\PYGdefaultZus{}size}\PYGdefault{p}{)} \PYGdefault{o}{?} \PYGdefault{l+m+mi}{1} \PYGdefault{o}{:} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{);}

      \PYGdefault{c+cm}{/* go to next cycle */}
      \PYGdefault{n}{sim\PYGdefaultZus{}cycle}\PYGdefault{o}{++}\PYGdefault{p}{;}
      
\PYGdefault{c+cm}{/************************************************************************************************/}	       
\PYGdefault{c+cm}{/* CS 203A DVFS Controller                                                                      */}	       
\PYGdefault{c+cm}{/************************************************************************************************/}	       
            
	\PYGdefault{k}{if}\PYGdefault{p}{(}\PYGdefault{n}{sim\PYGdefaultZus{}cycle} \PYGdefault{o}{\PYGdefaultZpc{}} \PYGdefault{n}{DVFSInterval} \PYGdefault{o}{==} \PYGdefault{l+m+mi}{0}\PYGdefault{p}{)\PYGdefaultZob{}}
		\PYGdefault{n}{power\PYGdefaultZus{}this\PYGdefaultZus{}interval} \PYGdefault{o}{=} \PYGdefault{n}{total} \PYGdefault{o}{\PYGdefaultZhy{}} \PYGdefault{n}{previous\PYGdefaultZus{}total}\PYGdefault{p}{;}
		\PYGdefault{n}{avg\PYGdefaultZus{}power} \PYGdefault{o}{=} \PYGdefault{n}{power\PYGdefaultZus{}this\PYGdefaultZus{}interval} \PYGdefault{o}{/} \PYGdefault{n}{DVFSInterval}\PYGdefault{p}{;} 
		
		\PYGdefault{k}{if}\PYGdefault{p}{(}\PYGdefault{n}{DVFSTurnOff} \PYGdefault{o}{==} \PYGdefault{n}{FALSE}\PYGdefault{p}{)\PYGdefaultZob{}}
			\PYGdefault{k}{if}\PYGdefault{p}{(}\PYGdefault{n}{power\PYGdefaultZus{}this\PYGdefaultZus{}interval} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{n}{DVFSTargetPower} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{VSF} \PYGdefault{o}{\PYGdefaultZgt{}} \PYGdefault{l+m+mf}{0.3}\PYGdefault{p}{)\PYGdefaultZob{}}
				\PYGdefault{n}{VSF} \PYGdefault{o}{\PYGdefaultZhy{}=} \PYGdefault{n}{DVFSIncrement}\PYGdefault{p}{;}
				\PYGdefault{n}{FSF} \PYGdefault{o}{\PYGdefaultZhy{}=} \PYGdefault{n}{DVFSIncrement}\PYGdefault{p}{;}
			\PYGdefault{p}{\PYGdefaultZcb{}}
			\PYGdefault{k}{if}\PYGdefault{p}{(}\PYGdefault{n}{power\PYGdefaultZus{}this\PYGdefaultZus{}interval} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{n}{DVFSTargetPower} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{VSF} \PYGdefault{o}{\PYGdefaultZlt{}} \PYGdefault{l+m+mf}{10.0}\PYGdefault{p}{)\PYGdefaultZob{}}
				\PYGdefault{n}{VSF} \PYGdefault{o}{+=} \PYGdefault{n}{DVFSIncrement}\PYGdefault{p}{;}
				\PYGdefault{n}{FSF} \PYGdefault{o}{+=} \PYGdefault{n}{DVFSIncrement}\PYGdefault{p}{;}
			\PYGdefault{p}{\PYGdefaultZcb{}}
		\PYGdefault{p}{\PYGdefaultZcb{}}
		
		\PYGdefault{n}{fprintf}\PYGdefault{p}{(}\PYGdefault{n}{output}\PYGdefault{p}{,}\PYGdefault{l+s}{\PYGdefaultZdq{}\PYGdefaultZpc{}f:\PYGdefaultZpc{}f:\PYGdefaultZpc{}f:\PYGdefaultZpc{}f:\PYGdefaultZpc{}f}\PYGdefault{l+s+se}{\PYGdefaultZbs{}n}\PYGdefault{l+s}{\PYGdefaultZdq{}}\PYGdefault{p}{,} \PYGdefault{n}{power\PYGdefaultZus{}this\PYGdefaultZus{}interval}\PYGdefault{p}{,} \PYGdefault{n}{avg\PYGdefaultZus{}power}\PYGdefault{p}{,} \PYGdefault{n}{VSF}\PYGdefault{p}{,} \PYGdefault{n}{FSF}\PYGdefault{p}{,} \PYGdefault{n}{FSF}\PYGdefault{o}{*}\PYGdefault{n}{Mhz}\PYGdefault{p}{);}
		\PYGdefault{n}{previous\PYGdefaultZus{}total} \PYGdefault{o}{+=} \PYGdefault{n}{power\PYGdefaultZus{}this\PYGdefaultZus{}interval}\PYGdefault{p}{;}
	\PYGdefault{p}{\PYGdefaultZcb{}}
	  
\PYGdefault{c+cm}{/************************************************************************************************/}	       
\PYGdefault{c+cm}{/*                                                                                              */}	       
\PYGdefault{c+cm}{/************************************************************************************************/}	       

      \PYGdefault{c+cm}{/* finish early? */}
      \PYGdefault{k}{if} \PYGdefault{p}{(}\PYGdefault{n}{max\PYGdefaultZus{}insts} \PYGdefault{o}{\PYGdefaultZam{}\PYGdefaultZam{}} \PYGdefault{n}{sim\PYGdefaultZus{}num\PYGdefaultZus{}insn} \PYGdefault{o}{\PYGdefaultZgt{}=} \PYGdefault{n}{max\PYGdefaultZus{}insts}\PYGdefault{p}{)}
	\PYGdefault{k}{return}\PYGdefault{p}{;}
    \PYGdefault{p}{\PYGdefaultZcb{}}
\PYGdefault{p}{\PYGdefaultZcb{}}
\end{Verbatim}
